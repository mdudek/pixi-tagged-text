{"version":3,"file":"pixi-tagged-text.modern.js","sources":["../src/functionalUtils.ts","../src/types.ts","../src/tags.ts","../src/stringUtil.ts","../src/pixiUtils.ts","../src/style.ts","../src/layout.ts","../src/TaggedText.ts"],"sourcesContent":["import { Nested } from \"./types\";\r\n\r\n/**\r\n * a -> boolean\r\n */\r\ntype Predicate<T> = (t: T) => boolean;\r\n\r\nexport const combineRecords = <\r\n  A extends Record<string, unknown>,\r\n  B extends Record<string, unknown> = A\r\n>(\r\n  a: A,\r\n  b: B\r\n): A & B => ({\r\n  ...a,\r\n  ...b,\r\n});\r\n\r\n/**\r\n * Returns the first item in a list. AKA head\r\n * List a -> a\r\n */\r\nexport const first = <T>(a: T[]): T => a[0];\r\n\r\n/**\r\n * Return the last item in a list. Aka tail\r\n * List f => f a -> a\r\n */\r\nexport const last = <T>(a: T[]): T => a[a.length - 1];\r\n\r\nexport const isDefined: Predicate<unknown | undefined> = (a): boolean =>\r\n  a !== undefined;\r\n\r\n/**\r\n * Predicate p => p -> p\r\n */\r\nexport const complement =\r\n  <T>(predicate: Predicate<T>) =>\r\n    (input: T): boolean =>\r\n      !predicate(input);\r\n\r\n/**\r\n * List f => string -> f {string: a} -> f a\r\n */\r\nexport const pluck =\r\n  <T, U>(key: keyof U) =>\r\n    (objects: U[]): T[] =>\r\n      (objects as (U & Record<string, T>)[]).map<T>((o) => o[key]);\r\n\r\nexport const assoc =\r\n  <T extends Record<string, U>, U>(key: keyof T) =>\r\n    (value: U) =>\r\n      (object: T): T => ({\r\n        ...object,\r\n        ...{ [key]: value },\r\n      });\r\n\r\n/**\r\n * Takes a key (k), a function (f) and an object (o) and applies f to the property k\r\n * of the object and stores the result in o[k].\r\n * Key k, Record r => k -> (a -> a) -> r k a -> r k a\r\n */\r\nexport const mapProp =\r\n  <T, U>(k: keyof U) =>\r\n    (f: (t: T) => T) =>\r\n      (o: U): U => ({\r\n        ...o,\r\n        [k]: f((o as U & Record<string, T>)[k]),\r\n      });\r\n\r\nexport const flatReduce =\r\n  <T, U>(f: (acc: U, t: T) => U, acc: U) =>\r\n    (nested: Nested<T>): U =>\r\n      // @ts-ignore-next-line\r\n      [nested].flat(255).reduce(f, acc);\r\n\r\ntype FlatReduceRetrun<T, U> = (nested: Nested<T>) => U;\r\n\r\nexport const flatEvery = <T>(p: Predicate<T>): FlatReduceRetrun<T, boolean> =>\r\n  flatReduce<T, boolean>((acc: boolean, t: T) => acc && p(t), true);\r\n\r\nexport const nestedMap =\r\n  <T, U>(f: (t: T) => U) =>\r\n    (nested: Nested<T>): Nested<U> =>\r\n      nested instanceof Array ? nested.map(nestedMap(f)) : f(nested);\r\n\r\n/**\r\n * Takes a list and a predicate and returns a number that represents the number of\r\n * true statements when applied to the elements in the list.\r\n * In other words, the number of elements that pass the test.\r\n * (a -> boolean) -> a[] -> number\r\n */\r\nexport const countIf =\r\n  <T>(p: Predicate<T>) =>\r\n    (a: Array<T>): number =>\r\n      a.reduce((count, item) => (p(item) ? count + 1 : count), 0);\r\n\r\nexport type Unary<Param, Return> = (p: Param) => Return;\r\n","import { BaseTexture, Texture } from \"@pixi/core\";\r\nimport { Rectangle as PixiRectangle } from \"@pixi/math\";\r\nimport { Sprite } from \"@pixi/sprite\";\r\nimport { TextStyle as PixiTextStyle } from \"@pixi/text\";\r\nimport { complement, flatEvery } from \"./functionalUtils\";\r\n\r\n///// GENERAL PURPOSE\r\n\r\nexport type Point = {\r\n  x: number;\r\n  y: number;\r\n};\r\nexport type Rectangle = Point & {\r\n  width: number;\r\n  height: number;\r\n};\r\n\r\nexport interface IFontMetrics {\r\n  ascent: number;\r\n  descent: number;\r\n  fontSize: number;\r\n}\r\n\r\nexport type Bounds = Rectangle;\r\n\r\nexport type Nested<T> = T | Array<Nested<T>>;\r\n\r\n///// OPTIONS\r\n\r\nexport type SpriteSource =\r\n  | string\r\n  | Texture\r\n  | HTMLCanvasElement\r\n  | HTMLVideoElement;\r\n\r\nexport type TextureSource =\r\n  | string\r\n  | HTMLImageElement\r\n  | HTMLCanvasElement\r\n  | HTMLVideoElement\r\n  | BaseTexture;\r\n\r\nexport type ImageSource = Sprite | SpriteSource | TextureSource;\r\n\r\nexport const isSpriteSource = (s: ImageSource): s is SpriteSource =>\r\n  typeof s === \"string\" ||\r\n  s instanceof Texture ||\r\n  s instanceof HTMLCanvasElement ||\r\n  s instanceof HTMLVideoElement;\r\nexport const isTextureSource = (s: ImageSource): s is TextureSource =>\r\n  s instanceof HTMLImageElement || s instanceof BaseTexture;\r\n\r\nexport type ImageSourceMap = Record<string, ImageSource>;\r\nexport type ImageMap = Record<string, Sprite>;\r\n\r\nexport type SplitStyle = \"words\" | \"characters\";\r\nexport interface TaggedTextOptions {\r\n  debug?: boolean;\r\n  debugConsole?: boolean;\r\n  splitStyle?: SplitStyle;\r\n  imgMap?: ImageSourceMap;\r\n  skipUpdates?: boolean;\r\n  skipDraw?: boolean;\r\n  drawWhitespace?: boolean;\r\n  wrapEmoji?: boolean;\r\n}\r\n\r\n///// STYLE PROPERTIES\r\n\r\n// PROPERTY NAMES\r\nexport const IMG_REFERENCE_PROPERTY = \"imgSrc\";\r\nexport const IMG_DISPLAY_PROPERTY = \"imgDisplay\";\r\n\r\n// todo: add text-transform: uppercase\r\nexport type Thickness = number;\r\nexport type Color = string | number;\r\nexport type Fill = Color | string[] | number[] | CanvasGradient | CanvasPattern;\r\nexport type VAlign = \"top\" | \"middle\" | \"bottom\" | \"baseline\" | number;\r\nexport type Align = \"left\" | \"right\" | \"center\" | \"justify\";\r\nexport type ImageDisplayMode = \"icon\" | \"block\" | \"inline\";\r\nexport type ImageReference = string;\r\nexport type ImageDimensionPercentage = string;\r\nexport type ImageDimension = number | string | ImageDimensionPercentage;\r\nexport type TextTransform = \"normal\" | \"capitalize\" | \"uppercase\" | \"lowercase\";\r\nexport type FontStyle = \"normal\" | \"italic\" | \"oblique\";\r\nexport type TextDecorationValue = \"underline\" | \"overline\" | \"line-through\";\r\nexport type TextDecoration =\r\n  | \"normal\"\r\n  | TextDecorationValue\r\n  | `${TextDecorationValue} ${TextDecorationValue}`\r\n  | `${TextDecorationValue} ${TextDecorationValue} ${TextDecorationValue}`;\r\n\r\nexport interface TextStyle\r\n  extends Record<string, unknown>,\r\n    Partial<PixiTextStyle> {\r\n  align?: Align;\r\n  fontStyle?: FontStyle;\r\n}\r\n\r\nexport interface ImageStyles {\r\n  [IMG_REFERENCE_PROPERTY]?: ImageReference;\r\n  [IMG_DISPLAY_PROPERTY]?: ImageDisplayMode;\r\n  imgScale?: ImageDimensionPercentage;\r\n  imgScaleX?: ImageDimensionPercentage;\r\n  imgScaleY?: ImageDimensionPercentage;\r\n  imgWidth?: ImageDimension;\r\n  imgHeight?: ImageDimension;\r\n}\r\n\r\nexport interface UnderlineStyle {\r\n  underlineColor?: Color;\r\n  underlineThickness?: Thickness;\r\n  underlineOffset?: number;\r\n}\r\nexport interface OverlineStyle {\r\n  overlineColor?: Color;\r\n  overlineThickness?: Thickness;\r\n  overlineOffset?: number;\r\n}\r\nexport interface LineThroughStyle {\r\n  lineThroughColor?: Color;\r\n  lineThroughThickness?: Thickness;\r\n  lineThroughOffset?: number;\r\n}\r\n\r\nexport interface TextDecorationStyles\r\n  extends UnderlineStyle,\r\n    OverlineStyle,\r\n    LineThroughStyle {}\r\nexport interface TextStyleExtended\r\n  extends TextStyle,\r\n    ImageStyles,\r\n    TextDecorationStyles {\r\n  lineSpacing?: number;\r\n  valign?: VAlign;\r\n  textTransform?: TextTransform;\r\n  textDecoration?: TextDecoration;\r\n  fontScaleWidth?: number;\r\n  fontScaleHeight?: number;\r\n}\r\n\r\nexport interface TextDecorationMetrics {\r\n  color: Color;\r\n  bounds: Bounds;\r\n}\r\n\r\nexport type TextStyleSet = Record<string, TextStyleExtended>;\r\n\r\n///// TAG PARSING\r\n\r\ntype TagName = string;\r\ntype AttributeName = string;\r\ntype AttributeValue = string | number;\r\nexport type AttributesList = Record<AttributeName, AttributeValue>;\r\nexport interface TagWithAttributes {\r\n  tagName: string;\r\n  attributes: AttributesList;\r\n}\r\n\r\nexport interface TagMatchData extends TagWithAttributes {\r\n  tag: string;\r\n  isOpening: boolean;\r\n  index: number;\r\n}\r\nexport type TagStack = TagMatchData[];\r\n\r\n///// PARSED TOKENS\r\n\r\nexport type NewlineToken = \"\\n\";\r\nexport type WhitespaceToken = \" \" | \"\\t\" | NewlineToken;\r\nexport type TextToken = string;\r\nexport type SpriteToken = Sprite;\r\n\r\nexport interface CompositeToken<T extends Token = Token> {\r\n  children: T[];\r\n}\r\n\r\nexport type Token = TextToken | CompositeToken | SpriteToken;\r\nexport type Tokens = CompositeToken;\r\n\r\nexport interface TagToken extends CompositeToken<TagToken | TextToken> {\r\n  tag?: TagName;\r\n  attributes?: AttributesList;\r\n}\r\nexport type TagTokens = TagToken;\r\n\r\nexport interface StyledToken\r\n  extends CompositeToken<StyledToken | TextToken | SpriteToken> {\r\n  style: TextStyleExtended;\r\n  tags: string;\r\n}\r\n\r\nexport type StyledTokens = StyledToken;\r\nexport interface FinalToken {\r\n  content: TextToken | SpriteToken;\r\n  bounds: Rectangle;\r\n  fontProperties: IFontMetrics;\r\n  style: TextStyleExtended;\r\n  tags: string;\r\n  textDecorations?: TextDecorationMetrics[];\r\n}\r\n\r\nexport const createEmptyFinalToken = (): FinalToken => ({\r\n  content: \"\",\r\n  bounds: new PixiRectangle(),\r\n  fontProperties: { ascent: 0, descent: 0, fontSize: 0 },\r\n  style: {},\r\n  tags: \"\",\r\n  textDecorations: [],\r\n});\r\n\r\nexport type WordToken = FinalToken[];\r\nexport type LineToken = WordToken[];\r\nexport type ParagraphToken = LineToken[];\r\n\r\nexport interface SpriteFinalToken extends FinalToken {\r\n  content: SpriteToken;\r\n}\r\nexport interface TextFinalToken extends FinalToken {\r\n  content: TextToken;\r\n}\r\n\r\nexport interface WhitespaceFinalToken extends TextFinalToken {\r\n  content: WhitespaceToken;\r\n}\r\nexport interface NewlineFinalToken extends TextFinalToken {\r\n  content: NewlineToken;\r\n}\r\n\r\nexport const isWhitespace = (s: string): s is WhitespaceToken =>\r\n  s !== \"\" &&\r\n  s.split(\"\").every((char: string): boolean => char.search(/\\s/) === 0);\r\nexport const isNewline = (s: string): s is NewlineToken =>\r\n  isWhitespace(s) && s === \"\\n\";\r\n\r\nexport const _isSpriteToken = (t: FinalToken): t is SpriteFinalToken =>\r\n  t.content instanceof Sprite;\r\nexport const isSpriteToken = flatEvery(_isSpriteToken);\r\n\r\nexport const _isTextToken = (t: FinalToken): t is TextFinalToken =>\r\n  typeof t.content === \"string\";\r\nexport const isTextToken = flatEvery(_isTextToken);\r\n\r\nexport const _isWhitespaceToken = (t: FinalToken): t is WhitespaceFinalToken =>\r\n  t !== undefined && _isTextToken(t) && isWhitespace(t.content);\r\nexport const isWhitespaceToken = flatEvery(_isWhitespaceToken);\r\n\r\nexport const _isNewlineToken = (t: FinalToken): t is NewlineFinalToken =>\r\n  t !== undefined && _isTextToken(t) && isNewline(t.content);\r\nexport const isNewlineToken = (t?: Nested<FinalToken>): boolean =>\r\n  t === undefined ? false : flatEvery(_isNewlineToken)(t);\r\n\r\nexport const isNotWhitespaceToken = complement(isWhitespaceToken);\r\n\r\nexport const isEmptyObject = <T extends unknown>(a: T): boolean =>\r\n  a instanceof Object && Object.keys(a).length === 0;\r\n","import getEmojiRegex from \"emoji-regex\";\r\n\r\nimport { last } from \"./functionalUtils\";\r\nimport {\r\n  TagMatchData,\r\n  AttributesList,\r\n  TagWithAttributes,\r\n  CompositeToken,\r\n  TagToken,\r\n  TextToken,\r\n  isEmptyObject,\r\n} from \"./types\";\r\n\r\n// TODO: this can probably be just a static value without all the options and parameters.\r\n// Seems doing one pass will be enough to gather all relevant info.\r\n// TODO: support self closing tags?\r\n\r\n/**\r\n * Generates a regular expression object for identifying tags and attributes.\r\n * @param tagNamesToMatch List of tag-names that will be matched by the RegExp\r\n */\r\nexport const getTagRegex = (tagNamesToMatch: string[] = [\"\\\\w+\"]): RegExp => {\r\n  const matchingTagNames = tagNamesToMatch.join(\"|\");\r\n\r\n  const captureGroup = (a: string) => `(${a})`;\r\n  const noCaptureGroup = (a: string) => `(?:${a})`;\r\n\r\n  const OR = \"|\";\r\n  const WHITESPACE = `\\\\s`;\r\n  const S = WHITESPACE + \"*\";\r\n  const SS = WHITESPACE + \"+\";\r\n  const CHAR = \"[A-Za-z0-9_\\\\-]\";\r\n  const QUOTE = noCaptureGroup(`\"|'`);\r\n  const NOT_QUOTE = `[^${QUOTE}]`;\r\n  const TAG_NAMES = captureGroup(matchingTagNames);\r\n  const ATTRIBUTE_NAME = CHAR + \"+\";\r\n  const ATTRIBUTE_VALUE = NOT_QUOTE + \"+\";\r\n\r\n  const ATTRIBUTES =\r\n    captureGroup(\r\n      noCaptureGroup(\r\n        SS +\r\n          noCaptureGroup(ATTRIBUTE_NAME) +\r\n          `=` +\r\n          QUOTE +\r\n          noCaptureGroup(ATTRIBUTE_VALUE) +\r\n          QUOTE\r\n      ) + \"*\"\r\n    ) + \"+\";\r\n  const TAG_OPEN = `<` + TAG_NAMES + ATTRIBUTES + S + `>`;\r\n  const TAG_CLOSE = `</${TAG_NAMES}${S}>`;\r\n\r\n  const pattern = TAG_OPEN + OR + TAG_CLOSE;\r\n\r\n  return new RegExp(pattern, \"g\");\r\n};\r\n\r\nexport const EMOJI_TAG = \"__EMOJI__\";\r\n\r\n/**\r\n * Takes a string of attributes and returns an object with key value pairs for each attribute.\r\n * Converts \"true\" | \"false\" into booleans and number-like strings into numbers.\r\n * @param attributesString  XML style attributes like \"src='/image.png' alt='foo'\"\r\n */\r\nexport const parseAttributes = (attributesString = \"\"): AttributesList => {\r\n  if (attributesString === \"\") {\r\n    return {};\r\n  }\r\n\r\n  const attributes = attributesString.trim().split(/\\s+/);\r\n\r\n  return attributes.reduce((obj: AttributesList, attribute: string) => {\r\n    const attributePair = attribute.split(\"=\");\r\n    const name = attributePair[0].trim();\r\n    const valueStr: string = attributePair[1]\r\n      .substr(1, attributePair[1].length - 2)\r\n      .trim();\r\n\r\n    obj[name] = valueStr;\r\n    return obj;\r\n  }, {});\r\n};\r\n\r\n/** Converts from RegExpExecArray to TagMatchData */\r\nexport const createTagMatchData = (match: RegExpExecArray): TagMatchData => {\r\n  const {\r\n    0: tag,\r\n    1: openTagName,\r\n    2: attributes,\r\n    3: closeTagName,\r\n    index,\r\n  } = match;\r\n  const tagName = openTagName ?? closeTagName;\r\n  const isOpening = openTagName !== undefined;\r\n  return {\r\n    tag,\r\n    tagName,\r\n    isOpening,\r\n    attributes: parseAttributes(attributes),\r\n    index,\r\n  };\r\n};\r\n\r\n/** Converts TagMatchData to TagWithAttributes */\r\nexport const tagMatchDataToTagWithAttributes = (\r\n  tag: TagMatchData\r\n): TagWithAttributes => ({\r\n  tagName: tag.tagName,\r\n  attributes: tag.attributes,\r\n});\r\n\r\n/**\r\n * Splits original text into an untagged list of string segments.\r\n * @param input Original text input\r\n * @param tagMatchData Results of regexp exect converted to tag matches.\r\n */\r\nexport const extractSegments = (\r\n  input: string,\r\n  tagMatchData: TagMatchData[]\r\n): string[] => {\r\n  const segments: string[] = [];\r\n\r\n  let remaining = input;\r\n  let offset = 0;\r\n  let tagMatch: TagMatchData;\r\n  for (tagMatch of tagMatchData) {\r\n    if (remaining !== undefined) {\r\n      const { tag, index } = tagMatch;\r\n      const startOfTag = index - offset;\r\n      const endOfTag = startOfTag + tag.length;\r\n      offset += endOfTag;\r\n\r\n      const segment = remaining.substr(0, startOfTag);\r\n      segments.push(segment);\r\n\r\n      remaining = remaining.substr(endOfTag);\r\n    }\r\n  }\r\n  segments.push(remaining);\r\n\r\n  return segments;\r\n};\r\n\r\nconst selfClosingTagSearch = (() => {\r\n  const group = (s: string) => `(${s})`;\r\n  const any = (s: string) => s + `*`;\r\n  const not = (...s: string[]) => `[^${s.join(\"\")}]`;\r\n  const WORD_START = `[A-Za-z_]`;\r\n  const WORD = `[A-Za-z0-9_]`;\r\n  const TAG_OPEN = `<`;\r\n  const TAG_SLASH = `/`;\r\n  const TAG_CLOSE = `>`;\r\n  const TAG_SELF_CLOSE = TAG_SLASH + TAG_CLOSE;\r\n\r\n  return new RegExp(\r\n    TAG_OPEN +\r\n      // tag group\r\n      group(WORD_START + any(WORD)) +\r\n      // attribute group\r\n      group(any(not(TAG_SLASH, TAG_CLOSE))) +\r\n      TAG_SELF_CLOSE,\r\n    `gs`\r\n  );\r\n})();\r\n\r\nexport const wrapEmoji = (input: string): string => {\r\n  const emojiRegex = new RegExp(\r\n    `((<|</)[^>]*)?(${getEmojiRegex().source})+`,\r\n    \"gums\"\r\n  );\r\n\r\n  return input.replaceAll(emojiRegex, (match, tagStart) => {\r\n    if (tagStart?.length > 0) {\r\n      // if the emoji is inside a tag, ignore it.\r\n      return match;\r\n    }\r\n    return `<${EMOJI_TAG}>${match}</${EMOJI_TAG}>`;\r\n  });\r\n};\r\n\r\nexport const replaceSelfClosingTags = (input: string): string =>\r\n  input.replace(selfClosingTagSearch, (_, tag, attributes = \"\") => {\r\n    let output = `<${tag}${attributes}></${tag}>`;\r\n    output = output.replace(/\\s+/g, \" \");\r\n    output = output.replace(/\\s>/g, \">\");\r\n    return output;\r\n  });\r\n\r\nexport const removeTags = (input: string): string =>\r\n  input.replace(getTagRegex(), \"\");\r\n\r\n// export const isTextToken = (token: Token): boolean => typeof token === \"string\";\r\n// export const isNewlineToken = (token: Token): boolean =>\r\n//   isWhitespaceToken(token) && token === \"\\n\";\r\n// export const isCompositeToken = (token: Token): boolean =>\r\n//   isTextToken(token) === false && \"children\" in (token as CompositeToken);\r\n\r\n// export const makeSpacesSeparateWords = (segment: string): string[] =>\r\n//   segment.replace(\" \", \"__SPACE__ __SPACE__\").split(\"__SPACE__\");\r\n\r\nexport const tagMatchToTagToken = (tag: TagMatchData): TagToken => {\r\n  return {\r\n    tag: tag.tagName,\r\n    children: [],\r\n\r\n    // Add attributes unless undefined\r\n    ...(isEmptyObject(tag.attributes) ? {} : { attributes: tag.attributes }),\r\n  };\r\n};\r\n\r\nexport const createTokensNew = (\r\n  segments: string[],\r\n  tags: TagMatchData[]\r\n): (TagToken | TextToken)[] => {\r\n  const rootTokens: CompositeToken<TagToken | TextToken> = { children: [] };\r\n  if (segments[0] !== \"\") {\r\n    rootTokens.children.push(segments[0]);\r\n  }\r\n  // Track which tags are opened and closed and add them to the list.\r\n  const tokenStack: TagToken[] = [rootTokens];\r\n\r\n  for (let i = 0; i < tags.length; i++) {\r\n    const tag = tags[i];\r\n    const segment = segments[i + 1] ?? \"\";\r\n    if (tag.isOpening) {\r\n      const token = tagMatchToTagToken(tag);\r\n      if (segment !== \"\") {\r\n        token.children.push(segment);\r\n      }\r\n      last(tokenStack).children.push(token);\r\n      tokenStack.push(token as CompositeToken<TagToken | TextToken>);\r\n    } else {\r\n      const poppedToken = tokenStack.pop();\r\n      if (poppedToken === undefined || poppedToken.tag !== tag.tagName) {\r\n        throw new Error(\r\n          `Unexpected tag nesting. Found a closing tag \"${tag.tagName}\" that doesn't match the previously open tag \"${poppedToken?.tag}\"`\r\n        );\r\n      }\r\n      if (segment !== \"\") {\r\n        last(tokenStack).children.push(segment);\r\n      }\r\n    }\r\n  }\r\n  if (tokenStack.length > 1) {\r\n    console.warn(\r\n      `Found ${tokenStack.length - 1} unclosed tags in\\n${tokenStack\r\n        .map((token) => token.tag)\r\n        .join(\"-\")}`\r\n    );\r\n  }\r\n\r\n  return rootTokens.children;\r\n};\r\n\r\nexport const containsEmoji = (input: string): boolean =>\r\n  getEmojiRegex().test(input);\r\n\r\n/**\r\n * Converts a string into a list of tokens that match segments of text with styles.\r\n *\r\n * @param input Input string with XML-style tags.\r\n * @param tagNamesToMatch Used to only tokenize tags that have styles defined for them.\r\n */\r\nexport const parseTagsNew = (\r\n  input: string,\r\n  tagNamesToMatch?: string[],\r\n  shouldWrapEmoji?: boolean\r\n): CompositeToken<TagToken | TextToken> => {\r\n  // TODO: Warn the user if tags were found that are not defined in the tagStyles.\r\n\r\n  if (shouldWrapEmoji && containsEmoji(input)) {\r\n    input = wrapEmoji(input);\r\n  }\r\n\r\n  input = replaceSelfClosingTags(input);\r\n  const re = getTagRegex(tagNamesToMatch);\r\n  const matchesRaw: RegExpExecArray[] = [];\r\n  const tagMatches: TagMatchData[] = [];\r\n  let match;\r\n  while ((match = re.exec(input))) {\r\n    matchesRaw.push(match);\r\n\r\n    const tagMatch = createTagMatchData(match);\r\n    tagMatches.push(tagMatch);\r\n  }\r\n\r\n  const segments = extractSegments(input, tagMatches);\r\n\r\n  const tokens = createTokensNew(segments, tagMatches);\r\n\r\n  return { children: tokens };\r\n};\r\n","// modified from: https://github.com/h26k2/capitalize-text/blob/master/index.js\r\nexport const capitalize = (str: string): string => {\r\n  const chars = str.split(\" \");\r\n  let converted = ``;\r\n\r\n  for (let i = 0; i < chars.length; i++) {\r\n    converted += `${chars[i].charAt(0).toUpperCase()}${chars[i].substr(1)} `;\r\n  }\r\n\r\n  return converted.trim();\r\n};\r\n","import { Container, DisplayObject } from \"@pixi/display\";\r\nimport { ICanvasRenderingContext2D } from '@pixi/settings';\r\nimport { Sprite } from \"@pixi/sprite\";\r\nimport { Text, TextMetrics } from \"@pixi/text\";\r\nimport { IFontMetrics } from \"./types\";\r\n\r\nconst PX_PER_EM = 16;\r\nconst PX_PER_PERCENT = 16 / 100;\r\nconst PX_PER_PT = 1.3281472327365;\r\n\r\nexport const measureFont = (context: ICanvasRenderingContext2D): IFontMetrics =>\r\n  TextMetrics.measureFont(context.font);\r\n\r\nexport const INITIAL_FONT_PROPS: IFontMetrics = {\r\n  ascent: 10,\r\n  descent: 2,\r\n  fontSize: 12,\r\n};\r\n\r\n// TODO: Memoize\r\nexport const getFontPropertiesOfText = (\r\n  textField: Text,\r\n  forceUpdate = false\r\n): IFontMetrics => {\r\n  if (forceUpdate) {\r\n    textField.updateText(false);\r\n    return measureFont(textField.context);\r\n  } else {\r\n    const props = measureFont(textField.context);\r\n    const fs = textField.style.fontSize ?? NaN;\r\n    if (\r\n      props.ascent === INITIAL_FONT_PROPS.ascent &&\r\n      props.descent === INITIAL_FONT_PROPS.descent &&\r\n      (isNaN(Number(fs)) || fs as number > INITIAL_FONT_PROPS.fontSize)\r\n    ) {\r\n      throw new Error(\r\n        \"getFontPropertiesOfText() returned metrics associated with a Text field that has not been updated yet. Please try using the forceUpdate parameter when you call this function.\"\r\n      );\r\n    }\r\n    return measureFont(textField.context);\r\n  }\r\n};\r\n\r\nexport const checkPixiVersion = (\r\n  version: string,\r\n  expectedMajorVersion: number\r\n): number => {\r\n  const majorVersion = parseInt(version.split(\".\")[0], 10);\r\n  if (majorVersion !== expectedMajorVersion) {\r\n    throw new Error(\r\n      `Detected Pixi.js version ${version}. pixi-multistyle-text supports Pixi.js version ${expectedMajorVersion}. (Please use v0.8.0 of this package for Pixi 4 support.)`\r\n    );\r\n  }\r\n  return 0;\r\n};\r\n\r\nexport const addChildrenToContainer = (\r\n  children: DisplayObject[],\r\n  container: Container\r\n): void => children.forEach((child) => container.addChild(child));\r\n\r\nexport const cloneSprite = (sprite: Sprite): Sprite =>\r\n  new Sprite(sprite.texture);\r\n\r\nexport const fontSizeStringToNumber = (size: string): number => {\r\n  const [valueString, unit] = size.split(/(%|pt|px|r?em)/);\r\n  const value = parseFloat(valueString);\r\n\r\n  if (isNaN(value)) {\r\n    NaN;\r\n  }\r\n\r\n  switch (unit) {\r\n    case \"%\":\r\n      return value * PX_PER_PERCENT;\r\n    case \"em\":\r\n    case \"rem\":\r\n      return value * PX_PER_EM;\r\n    case \"pt\":\r\n      return value * PX_PER_PT;\r\n    case \"px\":\r\n    default:\r\n      // keep as is.\r\n      return value;\r\n  }\r\n};\r\n","import { Sprite } from \"@pixi/sprite\";\r\nimport { combineRecords, isDefined, pluck } from \"./functionalUtils\";\r\nimport {\r\n  AttributesList,\r\n  TagWithAttributes,\r\n  TextStyleExtended,\r\n  TextStyleSet,\r\n  IMG_REFERENCE_PROPERTY,\r\n  IMG_DISPLAY_PROPERTY,\r\n  ImageMap,\r\n  TextToken,\r\n  TagToken,\r\n  TagTokens,\r\n  StyledTokens,\r\n  StyledToken,\r\n  SpriteToken,\r\n  isEmptyObject,\r\n  TextDecorationValue,\r\n  Bounds,\r\n  TextDecorationMetrics,\r\n  Thickness,\r\n  Color,\r\n  IFontMetrics,\r\n} from \"./types\";\r\nimport { cloneSprite } from \"./pixiUtils\";\r\n\r\nexport const DEFAULT_STYLE: TextStyleExtended = {\r\n  align: \"left\",\r\n  valign: \"baseline\",\r\n  [IMG_DISPLAY_PROPERTY]: \"inline\",\r\n  wordWrap: true,\r\n  wordWrapWidth: 500,\r\n  lineSpacing: 0,\r\n  fill: 0x000000,\r\n};\r\n\r\n/**\r\n * Combine 2 styles into one.\r\n */\r\nexport const combineStyles: (\r\n  a: TextStyleExtended,\r\n  b: TextStyleExtended\r\n) => TextStyleExtended = combineRecords;\r\n\r\n/**\r\n * Combines multiple styles into one.\r\n * @param styles List of styles to combine.\r\n */\r\nexport const combineAllStyles = (\r\n  styles: (TextStyleExtended | undefined)[]\r\n): TextStyleExtended =>\r\n  (styles.filter(isDefined) as TextStyleExtended[]).reduce(combineStyles, {});\r\n\r\nexport const convertAttributeValues = (\r\n  attributes: AttributesList\r\n): AttributesList => {\r\n  const convertedAttributes: AttributesList = {};\r\n  for (const key in attributes) {\r\n    const value = attributes[key] as string;\r\n    if (isNaN(parseFloat(value)) === false) {\r\n      convertedAttributes[key] = parseFloat(value);\r\n    } else {\r\n      convertedAttributes[key] = value;\r\n    }\r\n  }\r\n  return convertedAttributes;\r\n};\r\n\r\n/**\r\n * Replaces properties of a TextStyle object with new values.\r\n * (Since AttributeLists are basically partially defined styles, this is the same as combineStyles)\r\n * @param attributes List of attributes to overwrite in the target style.\r\n * @param style The style to modify.\r\n */\r\nexport const injectAttributes = (\r\n  attributes: AttributesList = {},\r\n  style: TextStyleExtended = {}\r\n): TextStyleExtended | undefined => {\r\n  if (isEmptyObject(style) && isEmptyObject(attributes)) return undefined;\r\n  return combineRecords(style, convertAttributeValues(attributes));\r\n};\r\n\r\n/**\r\n * Looks up a tag in a list of tag styles (with optional attributes) and returns it.\r\n * @param tagName Tag name to check.\r\n * @param tagStyles Set of tag styles to search.\r\n * @param attributes Attributes to inject into the style (optional).\r\n */\r\nexport const getStyleForTag = (\r\n  tagName: string,\r\n  tagStyles: TextStyleSet,\r\n  attributes: AttributesList = {}\r\n): TextStyleExtended | undefined => {\r\n  const style = injectAttributes(attributes, tagStyles[tagName]) ?? {};\r\n  if (Object.values(style).length === 0) return undefined;\r\n  return style;\r\n};\r\n\r\n/**\r\n * Converts TagWithAttributes into a style object.\r\n * @param param0 A TagWithAttributes object that has a tag name matched with any optional attributes.\r\n * @param tagStyles Set of tag styles to search.\r\n */\r\nexport const tagWithAttributesToStyle = (\r\n  { tagName, attributes }: TagWithAttributes,\r\n  tagStyles: TextStyleSet\r\n): TextStyleExtended =>\r\n  getStyleForTag(tagName, tagStyles, attributes) as TextStyleExtended;\r\n\r\n/**\r\n * Gets styles for several tags and returns a single combined style object.\r\n * Results are cached for future requests.\r\n * @param tags Tags (with attribues) to look up.\r\n * @param tagStyles Set of tag styles to search.\r\n * @param styleCache An object that holds the cached values for the combined styles.\r\n * @returns\r\n */\r\nexport const getStyleForTags = (\r\n  tags: TagWithAttributes[],\r\n  tagStyles: TextStyleSet,\r\n  styleCache: TextStyleSet\r\n): TextStyleExtended => {\r\n  const tagHash = JSON.stringify(tags);\r\n  if (styleCache[tagHash] === undefined) {\r\n    const defaultStyle = tagStyles.default;\r\n    const styles = tags.map((tag) => tagWithAttributesToStyle(tag, tagStyles));\r\n    const stylesWithDefault = [defaultStyle, ...styles];\r\n    styleCache[tagHash] = combineAllStyles(stylesWithDefault);\r\n  }\r\n  return styleCache[tagHash];\r\n};\r\n\r\nexport const mapTagsToStyles = (\r\n  tokens: TagTokens,\r\n  styles: TextStyleSet,\r\n  spriteTemplates?: ImageMap\r\n): StyledTokens => {\r\n  const defaultStyle: TextStyleExtended = styles.default ?? {};\r\n  const tagStack: TagWithAttributes[] = [];\r\n  const styleCache = {};\r\n\r\n  const convertTagTokenToStyledToken = (\r\n    token: TagToken | TextToken\r\n  ): StyledToken | TextToken => {\r\n    if (typeof token === \"string\") {\r\n      return token as TextToken;\r\n    }\r\n\r\n    const { tag, attributes = {} } = token;\r\n    let style: TextStyleExtended = defaultStyle;\r\n    let tags = \"\";\r\n\r\n    if (tag) {\r\n      // Put the current tag on the stack.\r\n      tagStack.push({ tagName: tag, attributes });\r\n      // Get tag names as comma separates string\r\n      tags = pluck(\"tagName\")(tagStack).join(\",\");\r\n      // Merge all tags into a style object.\r\n      style = getStyleForTags(tagStack, styles, styleCache);\r\n      style = convertDecorationToLineProps(style);\r\n    }\r\n\r\n    const styledToken: StyledToken = {\r\n      style,\r\n      tags,\r\n      children: token.children.map(convertTagTokenToStyledToken),\r\n    };\r\n\r\n    // If a matching sprite exits in the imgMap...\r\n    const imgKey = style[IMG_REFERENCE_PROPERTY] ?? \"\";\r\n    if (imgKey) {\r\n      if (spriteTemplates === undefined) {\r\n        throw new Error(\r\n          `An image tag with ${IMG_REFERENCE_PROPERTY}=\"${imgKey}\" was encountered, but no imgMap was provided. Please include a valid Sprite in the imgMap property in the options in your TaggedText constructor.`\r\n        );\r\n      }\r\n      const sprite: SpriteToken | undefined = spriteTemplates[imgKey];\r\n      if (sprite === undefined) {\r\n        throw new Error(\r\n          `An image tag with ${IMG_REFERENCE_PROPERTY}=\"${imgKey}\" was encountered, but there was no matching sprite in the sprite map. Please include a valid Sprite in the imgMap property in the options in your TaggedText constructor.`\r\n        );\r\n      }\r\n      if (sprite instanceof Sprite === false) {\r\n        throw new Error(\r\n          `The image reference you provided for \"${imgKey}\" is not a Sprite. The imgMap can only accept PIXI.Sprite instances.`\r\n        );\r\n      }\r\n\r\n      // insert sprite as first token.\r\n      const cloneOfSprite = cloneSprite(sprite);\r\n      styledToken.children = [cloneOfSprite, ...styledToken.children];\r\n    }\r\n\r\n    // Remove the last tag from the stack\r\n    tagStack.pop();\r\n\r\n    return styledToken;\r\n  };\r\n\r\n  return convertTagTokenToStyledToken(tokens) as StyledTokens;\r\n};\r\n\r\nexport const convertDecorationToLineProps = (\r\n  style: TextStyleExtended\r\n): TextStyleExtended => {\r\n  const { textDecoration } = style;\r\n\r\n  if (textDecoration === undefined || textDecoration === \"normal\") {\r\n    return style;\r\n  }\r\n\r\n  const { decorationColor, decorationThickness } = style;\r\n  const defaultColor = decorationColor || style.fill || DEFAULT_STYLE.fill;\r\n  const defaultThickness = decorationThickness || 1;\r\n  const defaultOffset = 0;\r\n\r\n  function mergeDecoration(\r\n    decorationLineType: TextDecorationValue,\r\n    decorationLineTypeCamelCase: string = decorationLineType\r\n  ): Partial<TextStyleExtended> {\r\n    if (style.textDecoration?.includes(decorationLineType)) {\r\n      return {\r\n        [`${decorationLineTypeCamelCase}Color`]:\r\n          style[`${decorationLineTypeCamelCase}Color`] ?? defaultColor,\r\n        [`${decorationLineTypeCamelCase}Thickness`]:\r\n          style[`${decorationLineTypeCamelCase}Thickness`] ?? defaultThickness,\r\n        [`${decorationLineTypeCamelCase}Offset`]:\r\n          style[`${decorationLineTypeCamelCase}Offset`] ?? defaultOffset,\r\n      };\r\n    }\r\n    return {};\r\n  }\r\n\r\n  return {\r\n    ...style,\r\n    ...mergeDecoration(\"underline\"),\r\n    ...mergeDecoration(\"overline\"),\r\n    ...mergeDecoration(\"line-through\", \"lineThrough\"),\r\n  };\r\n};\r\n\r\nexport const extractDecorations = (\r\n  style: TextStyleExtended,\r\n  textBounds: Bounds,\r\n  fontProperties: IFontMetrics\r\n): TextDecorationMetrics[] => {\r\n  const { ascent, descent } = fontProperties;\r\n  const baseline = ascent;\r\n  const ascender = descent;\r\n  const xHeight = baseline - ascender;\r\n  const { width } = textBounds;\r\n  const x = 0;\r\n\r\n  function styleToMetrics(key: string): TextDecorationMetrics | undefined {\r\n    const color = style[`${key}Color`] as Color;\r\n    const height = style[`${key}Thickness`] as Thickness;\r\n    const offset = (style[`${key}Offset`] as number) ?? 0;\r\n\r\n    if (color === undefined || height === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    let y = offset;\r\n    if (key === \"underline\") {\r\n      // position underline below baseline\r\n      y += baseline + descent / 2;\r\n    } else if (key === \"lineThrough\") {\r\n      // position lineThrough in center of ascent\r\n      y += ascender + xHeight / 2;\r\n    }\r\n    // else, position overline at top of text\r\n\r\n    return {\r\n      color,\r\n      bounds: { x, y, width, height },\r\n    };\r\n  }\r\n\r\n  const keySuffices = [\"underline\", \"overline\", \"lineThrough\"];\r\n  const metrics = keySuffices\r\n    .map(styleToMetrics)\r\n    .filter((x) => x !== undefined) as TextDecorationMetrics[];\r\n  return metrics;\r\n};\r\n","import { Container } from \"@pixi/display\";\r\nimport { Point as PixiPoint, Rectangle } from \"@pixi/math\";\r\nimport { Sprite } from \"@pixi/sprite\";\r\nimport { Text as PixiText } from \"@pixi/text\";\r\nimport {\r\n  assoc,\r\n  first,\r\n  flatReduce,\r\n  last,\r\n  mapProp,\r\n  Unary,\r\n} from \"./functionalUtils\";\r\nimport { getFontPropertiesOfText } from \"./pixiUtils\";\r\nimport { capitalize } from \"./stringUtil\";\r\nimport { extractDecorations } from \"./style\";\r\nimport {\r\n  Align,\r\n  Bounds,\r\n  createEmptyFinalToken,\r\n  FinalToken,\r\n  IFontMetrics,\r\n  IMG_DISPLAY_PROPERTY,\r\n  isNewlineToken,\r\n  isNotWhitespaceToken,\r\n  isSpriteToken,\r\n  isWhitespaceToken,\r\n  LineToken,\r\n  Nested,\r\n  ParagraphToken,\r\n  Point,\r\n  SplitStyle,\r\n  SpriteToken,\r\n  StyledToken,\r\n  StyledTokens,\r\n  TextStyleExtended,\r\n  TextToken,\r\n  VAlign,\r\n  WordToken,\r\n} from \"./types\";\r\n\r\nconst ICON_SCALE_BASE = 0.8;\r\n\r\n/**\r\n * Translates the current location point to the beginning of the next line.\r\n *\r\n * @param offset An offset coordinate. The function will make a clone of this with new coordinates.\r\n * @param largestLineHeight The largest height in the line of text.\r\n * @param lineSpacing The amount of extra space to insert between each line.\r\n */\r\nexport const updateOffsetForNewLine = (\r\n  offset: Point,\r\n  largestLineHeight: number,\r\n  lineSpacing: number\r\n): Point => new PixiPoint(0, offset.y + largestLineHeight + lineSpacing);\r\n\r\nconst rectFromContainer = (\r\n  container: Container,\r\n  offset: Point = { x: 0, y: 0 }\r\n): Bounds => {\r\n  const w = container.width;\r\n  const h = container.height;\r\n  const x = offset.x + container.x;\r\n  const y = offset.y + container.y;\r\n\r\n  return new Rectangle(x, y, w, h);\r\n};\r\n\r\n/**\r\n * Move a point by an offset.\r\n * Point p => p -> p-> -> p\r\n * @param offset Amount to translate the target.\r\n * @param point Target to translate.\r\n */\r\nexport const translatePoint =\r\n  <P extends Point>(offset: Point) =>\r\n  (point: P): P => ({\r\n    ...point,\r\n    x: point.x + offset.x,\r\n    y: point.y + offset.y,\r\n  });\r\n\r\n/**\r\n * Same as translatePoint but for all the points in an array.\r\n */\r\nexport const translateLine =\r\n  (offset: Point) =>\r\n  (line: Bounds[]): Bounds[] =>\r\n    line.map(translatePoint(offset));\r\n\r\nexport const translateWordPosition =\r\n  (offset: Point) =>\r\n  (word: WordToken): WordToken =>\r\n    word.map((token) =>\r\n      mapProp<Bounds, FinalToken>(\"bounds\")(translatePoint(offset))(token)\r\n    );\r\n\r\nexport const translateTokenLine =\r\n  (offset: Point) =>\r\n  (line: LineToken): LineToken =>\r\n    line.map(translateWordPosition(offset));\r\n\r\nexport const lineWidth = (wordsInLine: Bounds[]): number => {\r\n  const firstWord = first(wordsInLine);\r\n  const lastWord = last(wordsInLine);\r\n\r\n  if (firstWord === undefined) {\r\n    return 0;\r\n  }\r\n  if (lastWord === firstWord) {\r\n    return firstWord.width;\r\n  }\r\n  return lastWord.x + lastWord.width - firstWord.x;\r\n};\r\n\r\nexport const center = (x: number, context: number): number => (context - x) / 2;\r\n\r\nconst setBoundsX = assoc<Bounds, number>(\"x\");\r\n\r\nconst positionWordX =\r\n  (x: number) =>\r\n  (word: WordToken): WordToken => {\r\n    let prevBounds: Bounds;\r\n    return word.map((token) => {\r\n      if (prevBounds === undefined) {\r\n        token.bounds.x = x;\r\n        prevBounds = token.bounds;\r\n      } else {\r\n        token.bounds.x = prevBounds.x + prevBounds.width;\r\n        prevBounds = token.bounds;\r\n      }\r\n      return token;\r\n    });\r\n  };\r\n\r\nexport const concatBounds = (\r\n  originalBounds: Bounds = { x: NaN, y: NaN, width: NaN, height: NaN },\r\n  bounds: Bounds = { x: NaN, y: NaN, width: NaN, height: NaN }\r\n): Bounds => {\r\n  if (isNaN(originalBounds.x)) {\r\n    return bounds;\r\n  }\r\n\r\n  const x = Math.min(originalBounds.x, bounds.x);\r\n  const y = Math.min(originalBounds.y, bounds.y);\r\n  const right = Math.max(\r\n    originalBounds.x + originalBounds.width,\r\n    bounds.x + bounds.width\r\n  );\r\n  const bottom = Math.max(\r\n    originalBounds.y + originalBounds.height,\r\n    bounds.y + bounds.height\r\n  );\r\n  const width = right - x;\r\n  const height = bottom - y;\r\n\r\n  return { x, y, width, height };\r\n};\r\n\r\nconst getCombinedBounds = (bounds: Bounds[]): Bounds =>\r\n  bounds.reduce(concatBounds);\r\n\r\nexport const getBoundsNested: Unary<Nested<FinalToken>, Bounds> = flatReduce<\r\n  FinalToken,\r\n  Bounds\r\n>((acc: Bounds, t: FinalToken) => concatBounds(acc, t.bounds), {\r\n  x: NaN,\r\n  y: NaN,\r\n  width: NaN,\r\n  height: NaN,\r\n});\r\n\r\nexport const alignLeft = (line: Bounds[]): Bounds[] =>\r\n  line.reduce(\r\n    (newLine: Bounds[], bounds: Bounds, i: number): Bounds[] =>\r\n      // is first word?\r\n      i === 0\r\n        ? [setBoundsX(0)(bounds)]\r\n        : newLine.concat([\r\n            setBoundsX(newLine[i - 1].x + newLine[i - 1].width)(bounds),\r\n          ]),\r\n    []\r\n  );\r\n\r\nexport const alignRight =\r\n  (maxWidth: number) =>\r\n  (line: Bounds[]): Bounds[] =>\r\n    translateLine({\r\n      x: maxWidth - lineWidth(line),\r\n      y: 0,\r\n    })(alignLeft(line));\r\n\r\nexport const alignCenter =\r\n  (maxWidth: number) =>\r\n  (line: Bounds[]): Bounds[] =>\r\n    translateLine({ x: center(lineWidth(line), maxWidth), y: 0 })(\r\n      alignLeft(line)\r\n    );\r\n\r\nexport const alignJustify =\r\n  (maxLineWidth: number) =>\r\n  (line: Bounds[]): Bounds[] => {\r\n    const count = line.length;\r\n    if (count === 0) {\r\n      return [];\r\n    }\r\n\r\n    const nonZeroWidthWords: Bounds[] = line.filter(({ width }) => width > 0);\r\n    const countNonZeroWidthWords = nonZeroWidthWords.length;\r\n\r\n    if (countNonZeroWidthWords === 1) {\r\n      const [first, ...rest] = line;\r\n      first.x = 0;\r\n      return [first, ...rest];\r\n    }\r\n\r\n    const result: Bounds[] = [];\r\n    const combinedBounds = getCombinedBounds(nonZeroWidthWords);\r\n    const w = combinedBounds.width;\r\n    const totalSpace = maxLineWidth - w;\r\n    const spacerWidth = totalSpace / (countNonZeroWidthWords - 1);\r\n\r\n    let previousWord;\r\n    for (let i = 0; i < line.length; i++) {\r\n      const bounds = line[i];\r\n      if (bounds.width === 0) {\r\n        result[i] = { ...bounds };\r\n        continue;\r\n      }\r\n      let x;\r\n      if (previousWord === undefined) {\r\n        x = 0;\r\n      } else {\r\n        x = previousWord.x + previousWord.width + spacerWidth;\r\n      }\r\n      if (isNaN(x)) {\r\n        throw new Error(\r\n          `Something went wrong with the justified layout calculation. x is NaN.`\r\n        );\r\n      }\r\n      const newWord: Bounds = setBoundsX(x)(bounds);\r\n      previousWord = newWord;\r\n      result[i] = newWord;\r\n    }\r\n    return result;\r\n  };\r\n\r\nexport const alignLines = (\r\n  align: Align,\r\n  maxWidth: number,\r\n  lines: ParagraphToken\r\n): ParagraphToken => {\r\n  // do horizontal alignment.\r\n  let alignFunction: (l: Bounds[]) => Bounds[];\r\n  switch (align) {\r\n    case \"left\":\r\n      alignFunction = alignLeft;\r\n      break;\r\n    case \"right\":\r\n      alignFunction = alignRight(maxWidth);\r\n      break;\r\n    case \"center\":\r\n      alignFunction = alignCenter(maxWidth);\r\n      break;\r\n    case \"justify\":\r\n      alignFunction = alignJustify(maxWidth);\r\n      break;\r\n    default:\r\n      throw new Error(\r\n        `Unsupported alignment type ${align}! Use one of : \"left\", \"right\", \"center\", \"justify\"`\r\n      );\r\n  }\r\n\r\n  for (const line of lines) {\r\n    const wordBoundsForLine: Bounds[] = [];\r\n    for (const word of line) {\r\n      const wordBounds = getBoundsNested(word);\r\n      wordBoundsForLine.push(wordBounds);\r\n      if (isNaN(wordBounds.x)) {\r\n        throw new Error(\"wordBounds not correct\");\r\n      }\r\n    }\r\n    const alignedLine = alignFunction(wordBoundsForLine);\r\n    for (let i = 0; i < line.length; i++) {\r\n      const bounds = alignedLine[i];\r\n      const word = line[i];\r\n      line[i] = positionWordX(bounds.x)(word);\r\n    }\r\n  }\r\n  return lines;\r\n};\r\n\r\nconst getTallestToken = (line: LineToken): FinalToken =>\r\n  flatReduce<FinalToken, FinalToken>((tallest, current) => {\r\n    let h = current.bounds.height ?? 0;\r\n    if (isSpriteToken(current)) {\r\n      h += current.fontProperties.descent;\r\n    }\r\n    if (h > (tallest?.bounds.height ?? 0)) {\r\n      return current;\r\n    }\r\n    return tallest;\r\n  }, createEmptyFinalToken())(line);\r\n\r\n/**\r\n * @param If you want to override the valign from the styles object, set it here.\r\n */\r\nexport const verticalAlignInLines = (\r\n  lines: ParagraphToken,\r\n  lineSpacing: number,\r\n  overrideValign?: VAlign\r\n): ParagraphToken => {\r\n  let previousTallestToken: FinalToken = createEmptyFinalToken();\r\n\r\n  let previousLineBottom = 0;\r\n  const newLines: ParagraphToken = [];\r\n\r\n  for (const line of lines) {\r\n    const newLine: LineToken = [];\r\n    // const nonZeroWidthWords: Bounds[] = line.filter(({ width }) => width > 0);\r\n\r\n    let tallestToken: FinalToken = getTallestToken(line);\r\n    let tallestHeight = tallestToken.bounds?.height ?? 0;\r\n    let tallestAscent = tallestToken.fontProperties?.ascent ?? 0;\r\n    if (isSpriteToken(tallestToken)) {\r\n      tallestHeight += tallestToken.fontProperties.descent;\r\n      tallestAscent = tallestToken.bounds.height;\r\n    }\r\n\r\n    // const previousTallestHeight = previousTallestToken.bounds.height;\r\n\r\n    // if (line.length === 1 && isWhitespaceToken(line[0])) {\r\n    //   tallestHeight = previousTallestHeight;\r\n    // }\r\n\r\n    if (tallestHeight === 0) {\r\n      tallestToken = previousTallestToken;\r\n    } else {\r\n      previousTallestToken = tallestToken;\r\n    }\r\n\r\n    for (const word of line) {\r\n      const newWord: WordToken = [];\r\n      for (const segment of word) {\r\n        if (isNewlineToken(segment)) {\r\n          const newToken = {\r\n            ...segment,\r\n          };\r\n          newWord.push(newToken);\r\n          continue;\r\n        }\r\n        const { bounds, fontProperties, style } = segment;\r\n        const height = bounds.height;\r\n\r\n        const newBounds: Bounds = { ...bounds };\r\n        const valign = overrideValign ?? style.valign;\r\n\r\n        let { ascent } = fontProperties;\r\n        if (isSpriteToken(segment)) {\r\n          ascent = segment.bounds.height;\r\n        }\r\n\r\n        let newY = 0;\r\n        switch (valign) {\r\n          case \"bottom\":\r\n            newY = previousLineBottom + tallestHeight - height;\r\n            break;\r\n          case \"middle\":\r\n            newY = previousLineBottom + (tallestHeight - height) / 2;\r\n            break;\r\n          case \"top\":\r\n            newY = previousLineBottom;\r\n            break;\r\n          case \"baseline\":\r\n          default:\r\n            newY = previousLineBottom + tallestAscent - ascent;\r\n        }\r\n\r\n        newBounds.y = newY;\r\n\r\n        const newToken = {\r\n          ...segment,\r\n          bounds: newBounds,\r\n        };\r\n        newWord.push(newToken);\r\n      }\r\n      newLine.push(newWord);\r\n    }\r\n\r\n    previousLineBottom += tallestHeight + lineSpacing;\r\n    newLines.push(newLine);\r\n  }\r\n\r\n  return newLines;\r\n\r\n  // ? lines.map(valignTop)\r\n  //   : valign === \"middle\"\r\n  //   ? lines.map(valignMiddle)\r\n  //   : valign === \"bottom\"\r\n  //   ? lines.map(valignBottom)\r\n  //   : lines;\r\n};\r\n\r\nexport const collapseWhitespacesOnEndOfLines = (\r\n  lines: ParagraphToken\r\n): ParagraphToken => {\r\n  for (const line of lines) {\r\n    const l = line.length;\r\n    let i = l;\r\n    while (i >= 0) {\r\n      i -= 1;\r\n      const word = line[i];\r\n      if (isNotWhitespaceToken(word)) {\r\n        break;\r\n      } else {\r\n        for (const token of word) {\r\n          token.bounds.width = 0;\r\n          token.bounds.height = Math.min(\r\n            token.bounds.height,\r\n            token.fontProperties.fontSize\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return lines;\r\n};\r\n\r\nconst layout = (\r\n  tokens: FinalToken[],\r\n  maxWidth: number,\r\n  lineSpacing: number,\r\n  align: Align\r\n): ParagraphToken => {\r\n  const cursor = { x: 0, y: 0 };\r\n  let wordWidth = 0;\r\n  let word: WordToken = [];\r\n  let line: LineToken = [];\r\n  const allLines: ParagraphToken = [];\r\n  let tallestHeightInLine = 0;\r\n\r\n  function addWordBufferToLineBuffer() {\r\n    if (word !== undefined && word.length > 0) {\r\n      // add word to line\r\n      line.push(word);\r\n    }\r\n\r\n    // reset word buffer\r\n    word = [];\r\n    wordWidth = 0;\r\n  }\r\n\r\n  function addLineToListOfLines() {\r\n    allLines.push(line);\r\n    line = [];\r\n  }\r\n\r\n  function addLineToListOfLinesAndMoveCursorToNextLine(token: FinalToken) {\r\n    // finalize Line\r\n    addLineToListOfLines();\r\n\r\n    // move cursor to next line\r\n    cursor.x = 0;\r\n    cursor.y = cursor.y + tallestHeightInLine;\r\n\r\n    // reset tallestHeight\r\n    tallestHeightInLine = 0;\r\n    setTallestHeight(token);\r\n  }\r\n\r\n  function setTallestHeight(token?: FinalToken): void {\r\n    const fontSize = token?.fontProperties?.fontSize ?? 0;\r\n    const height = token?.bounds?.height ?? 0;\r\n\r\n    tallestHeightInLine = Math.max(tallestHeightInLine, fontSize, lineSpacing);\r\n    // Don't try to measure the height of newline tokens\r\n    if (isNewlineToken(token) === false) {\r\n      tallestHeightInLine = Math.max(tallestHeightInLine, height);\r\n    }\r\n  }\r\n\r\n  function positionTokenAtCursorAndAdvanceCursor(token: FinalToken): void {\r\n    // position token at cursor\r\n    setTallestHeight(token);\r\n    token.bounds.x = cursor.x;\r\n    token.bounds.y = cursor.y;\r\n    // advance cursor\r\n    cursor.x += token.bounds.width;\r\n  }\r\n\r\n  function positionWordBufferAtCursorAndAdvanceCursor(): void {\r\n    word.forEach(positionTokenAtCursorAndAdvanceCursor);\r\n  }\r\n\r\n  function wordInBufferExceedsLineLength(): boolean {\r\n    return cursor.x + wordWidth > maxWidth;\r\n  }\r\n\r\n  function isBlockImage(token: FinalToken): boolean {\r\n    return token.style[IMG_DISPLAY_PROPERTY] === \"block\";\r\n  }\r\n\r\n  function addTokenToWordAndUpdateWordWidth(token: FinalToken): void {\r\n    // add the token to the current word buffer.\r\n    word.push(token);\r\n    wordWidth += token.bounds.width;\r\n  }\r\n\r\n  let token;\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    token = tokens[i];\r\n    const isWhitespace = isWhitespaceToken(token);\r\n    const isNewline = isNewlineToken(token);\r\n    const isImage = isSpriteToken(token);\r\n    const isWordEndingToken = isWhitespace || isImage;\r\n\r\n    if (isWordEndingToken) {\r\n      positionWordBufferAtCursorAndAdvanceCursor();\r\n      addWordBufferToLineBuffer();\r\n    }\r\n\r\n    addTokenToWordAndUpdateWordWidth(token);\r\n    setTallestHeight(token);\r\n\r\n    // always immediately add whitespace to the line.\r\n    if (isWhitespace) {\r\n      positionWordBufferAtCursorAndAdvanceCursor();\r\n      addWordBufferToLineBuffer();\r\n    }\r\n\r\n    // If the token is a newline character,\r\n    // move the cursor to next line immediately\r\n    if (isNewline || isBlockImage(token)) {\r\n      addLineToListOfLinesAndMoveCursorToNextLine(token);\r\n    } else if (wordInBufferExceedsLineLength()) {\r\n      // don't wrap if it's the first word in the line.\r\n      if (line.length > 0) {\r\n        addLineToListOfLinesAndMoveCursorToNextLine(token);\r\n      }\r\n    }\r\n  }\r\n\r\n  // After we reach the last token, add it to the word and finalize both buffers.\r\n  if (word.length > 0) {\r\n    positionWordBufferAtCursorAndAdvanceCursor();\r\n    addWordBufferToLineBuffer();\r\n  }\r\n  if (line.length > 0) {\r\n    addLineToListOfLines();\r\n  }\r\n\r\n  const collapsedWhitespace = collapseWhitespacesOnEndOfLines(allLines);\r\n  const alignedLines = alignLines(align, maxWidth, collapsedWhitespace);\r\n  const valignedLines = verticalAlignInLines(alignedLines, lineSpacing);\r\n\r\n  return valignedLines;\r\n};\r\n\r\nconst notEmptyString = (s: string) => s !== \"\";\r\n\r\nconst SPLIT_MARKER = `__`;\r\nexport const splitAroundWhitespace = (s: string): string[] =>\r\n  s\r\n    .replace(/\\s/g, `${SPLIT_MARKER}$&${SPLIT_MARKER}`)\r\n    .split(SPLIT_MARKER)\r\n    .filter((s) => s !== \"\");\r\n\r\nexport const splitText = (s: string, splitStyle: SplitStyle): string[] => {\r\n  if (splitStyle === \"words\") {\r\n    return [s].flatMap(splitAroundWhitespace).filter(notEmptyString);\r\n  } else if (splitStyle === \"characters\") {\r\n    return s.split(\"\");\r\n  } else {\r\n    // unsupported splitStyle.\r\n    let suggestion = ` Supported styles are \"words\" and \"characters\"`;\r\n    const badStyle = (splitStyle as string).toLowerCase();\r\n    if (badStyle.indexOf(\"char\") === 0) {\r\n      suggestion = `Did you mean \"characters\"?`;\r\n    } else if (badStyle.indexOf(\"wor\") === 0) {\r\n      suggestion = `Did you mean \"words\"?`;\r\n    }\r\n    throw new Error(`Unsupported split style \"${splitStyle}\". ${suggestion}`);\r\n  }\r\n};\r\n\r\nexport const calculateFinalTokens = (\r\n  styledTokens: StyledTokens,\r\n  splitStyle: SplitStyle = \"words\"\r\n): ParagraphToken => {\r\n  // Create a text field to use for measurements.\r\n  const sizer = new PixiText(\"\");\r\n  const defaultStyle = styledTokens.style;\r\n\r\n  let fontProperties: IFontMetrics;\r\n\r\n  const generateFinalTokenFromStyledToken =\r\n    (style: TextStyleExtended, tags: string) =>\r\n    (token: StyledToken | TextToken | SpriteToken): FinalToken[] => {\r\n      let output: FinalToken[] = [];\r\n\r\n      sizer.style = {\r\n        ...style,\r\n        // Override some styles for the purposes of sizing text.\r\n        wordWrap: false,\r\n        dropShadowBlur: 0,\r\n        dropShadowDistance: 0,\r\n        dropShadowAngle: 0,\r\n        dropShadow: false,\r\n      };\r\n\r\n      if (typeof token === \"string\") {\r\n        // split into pieces and convert into tokens.\r\n\r\n        const textSegments = splitText(token, splitStyle);\r\n\r\n        const textTokens = textSegments.map((str): FinalToken => {\r\n          switch (style.textTransform) {\r\n            case \"uppercase\":\r\n              sizer.text = str.toUpperCase();\r\n              break;\r\n            case \"lowercase\":\r\n              sizer.text = str.toLowerCase();\r\n              break;\r\n            case \"capitalize\":\r\n              sizer.text = capitalize(str);\r\n              break;\r\n            default:\r\n              sizer.text = str;\r\n          }\r\n\r\n          const sw = style.fontScaleWidth ?? 1.0;\r\n          const sh = style.fontScaleHeight ?? 1.0;\r\n          // clamp negative or NaN fontScales to 0\r\n          const scaleWidth = isNaN(sw) || sw < 0 ? 0.0 : sw;\r\n          const scaleHeight = isNaN(sh) || sh < 0 ? 0.0 : sh;\r\n\r\n          sizer.scale.set(scaleWidth, scaleHeight);\r\n\r\n          fontProperties = { ...getFontPropertiesOfText(sizer, true) };\r\n          fontProperties.ascent *= scaleHeight;\r\n          fontProperties.descent *= scaleHeight;\r\n          fontProperties.fontSize *= scaleHeight;\r\n\r\n          const bounds = rectFromContainer(sizer);\r\n\r\n          // Incorporate the size of the stroke into the size of the text.\r\n          const stroke = sizer.style.strokeThickness ?? 0;\r\n          if (stroke > 0) {\r\n            fontProperties.descent += stroke / 2;\r\n            fontProperties.ascent += stroke / 2;\r\n            fontProperties.fontSize =\r\n              fontProperties.ascent + fontProperties.descent;\r\n          }\r\n\r\n          const textDecorations = extractDecorations(\r\n            style,\r\n            bounds,\r\n            fontProperties\r\n          );\r\n\r\n          return {\r\n            content: str,\r\n            style,\r\n            tags,\r\n            bounds,\r\n            fontProperties,\r\n            textDecorations,\r\n          };\r\n        });\r\n\r\n        output = output.concat(textTokens);\r\n      } else if (token instanceof Sprite) {\r\n        const sprite = token;\r\n        const imgDisplay = style[IMG_DISPLAY_PROPERTY];\r\n        // const isBlockImage = imgDisplay === \"block\";\r\n        const isIcon = imgDisplay === \"icon\";\r\n        fontProperties = { ...getFontPropertiesOfText(sizer, true) };\r\n\r\n        if (isIcon) {\r\n          // Set to minimum of 1 to avoid devide by zero.\r\n          // if it's height is zero or one it probably hasn't loaded yet.\r\n          // It will get refreshed after it loads.\r\n          const h = Math.max(sprite.height, 1);\r\n\r\n          if (h > 1 && sprite.scale.y === 1) {\r\n            const ratio = (fontProperties.ascent / h) * ICON_SCALE_BASE;\r\n            sprite.scale.set(ratio);\r\n          }\r\n        }\r\n\r\n        // handle images\r\n        const bounds = rectFromContainer(sprite);\r\n        output.push({\r\n          content: sprite,\r\n          style,\r\n          tags,\r\n          bounds,\r\n          fontProperties,\r\n          textDecorations: undefined,\r\n        });\r\n      } else {\r\n        // token is a composite\r\n        const styledToken = token as StyledToken;\r\n        const { children } = styledToken;\r\n        // set tags and styles for children of this composite token.\r\n        const newStyle = styledToken.style;\r\n        const newTags = styledToken.tags;\r\n\r\n        if (newStyle === undefined) {\r\n          throw new Error(\r\n            `Expected to find a 'style' property on ${styledToken}`\r\n          );\r\n        }\r\n\r\n        output = output.concat(\r\n          children.flatMap(generateFinalTokenFromStyledToken(newStyle, newTags))\r\n        );\r\n      }\r\n      return output;\r\n    };\r\n\r\n  // when starting out, use the default style\r\n  const tags = \"\";\r\n  const style: TextStyleExtended = defaultStyle;\r\n\r\n  const finalTokens = styledTokens.children.flatMap(\r\n    generateFinalTokenFromStyledToken(style, tags)\r\n  );\r\n\r\n  const { wordWrap: ww, wordWrapWidth: www } = defaultStyle;\r\n  const hasWordWrapWidth =\r\n    www !== undefined && !isNaN(www as number) && (www as number) > 0;\r\n  const maxWidth =\r\n    ww && hasWordWrapWidth ? (www as number) : Number.POSITIVE_INFINITY;\r\n\r\n  const lineSpacing = defaultStyle.lineSpacing ?? 0;\r\n  const align = defaultStyle.align ?? \"left\";\r\n\r\n  return layout(finalTokens, maxWidth, lineSpacing, align);\r\n};\r\n","import { BaseTexture, Texture } from \"@pixi/core\";\r\nimport { Sprite } from \"@pixi/sprite\";\r\nimport { Text } from \"@pixi/text\";\r\nimport { Container, DisplayObject } from \"@pixi/display\";\r\nimport { Graphics } from \"@pixi/graphics\";\r\nimport \"@pixi/events\";\r\n\r\nimport { parseTagsNew, removeTags, EMOJI_TAG } from \"./tags\";\r\nimport {\r\n  TaggedTextOptions,\r\n  TextStyleSet,\r\n  TextStyleExtended,\r\n  TagWithAttributes,\r\n  AttributesList,\r\n  ImageMap,\r\n  ImageSourceMap,\r\n  IMG_REFERENCE_PROPERTY,\r\n  FinalToken,\r\n  isSpriteToken,\r\n  TextFinalToken,\r\n  isTextToken,\r\n  isNotWhitespaceToken,\r\n  isNewlineToken,\r\n  isWhitespaceToken,\r\n  Point,\r\n  ParagraphToken,\r\n  TextDecorationMetrics,\r\n  isSpriteSource,\r\n  isTextureSource,\r\n} from \"./types\";\r\nimport { capitalize } from \"./stringUtil\";\r\nimport { calculateFinalTokens, getBoundsNested } from \"./layout\";\r\nimport {\r\n  combineAllStyles,\r\n  DEFAULT_STYLE,\r\n  getStyleForTag as getStyleForTagExt,\r\n  mapTagsToStyles,\r\n} from \"./style\";\r\nimport { fontSizeStringToNumber } from \"./pixiUtils\";\r\n\r\nexport const DEFAULT_OPTIONS: TaggedTextOptions = {\r\n  debug: false,\r\n  debugConsole: false,\r\n  splitStyle: \"words\",\r\n  imgMap: {},\r\n  skipUpdates: false,\r\n  skipDraw: false,\r\n  drawWhitespace: false,\r\n  wrapEmoji: true,\r\n};\r\n\r\n// TODO: make customizable\r\nconst DEBUG = {\r\n  WORD_STROKE_COLOR: 0xffcccc, // #FCC\r\n  WORD_FILL_COLOR: 0xeeeeee, // #EEE\r\n  TEXT_FIELD_STROKE_COLOR: 0xff00ff, // #F0F\r\n  WHITESPACE_COLOR: 0xcccccc, // #CCC\r\n  WHITESPACE_STROKE_COLOR: 0xaaaaaa, // #AAA\r\n  BASELINE_COLOR: 0xffff99, // #FF9\r\n  LINE_COLOR: 0xffff00, // #FF0\r\n  OUTLINE_COLOR: 0xffcccc, // #FCC\r\n  OUTLINE_SHADOW_COLOR: 0x000000, // #000\r\n  TEXT_STYLE: {\r\n    fontFamily: \"courier\",\r\n    fontSize: 10,\r\n    fill: 0xffffff, // #FFF\r\n    dropShadow: true,\r\n  },\r\n};\r\nconst DEFAULT_STYLE_SET = { default: DEFAULT_STYLE };\r\n\r\nObject.freeze(DEFAULT_STYLE_SET);\r\nObject.freeze(DEFAULT_STYLE);\r\nexport default class TaggedText extends Sprite {\r\n  public static get defaultStyles(): TextStyleSet {\r\n    return DEFAULT_STYLE_SET;\r\n  }\r\n  public static get defaultOptions(): TaggedTextOptions {\r\n    return DEFAULT_OPTIONS;\r\n  }\r\n\r\n  // todo: allow setting options after the constructor is called. Make sure to call update()\r\n  /** Settings for the TaggedText component. */\r\n  private _options: TaggedTextOptions;\r\n  public get options(): TaggedTextOptions {\r\n    return this._options;\r\n  }\r\n\r\n  private _needsUpdate = true;\r\n  public get needsUpdate(): boolean {\r\n    return this._needsUpdate;\r\n  }\r\n  private _needsDraw = true;\r\n  public get needsDraw(): boolean {\r\n    return this._needsDraw;\r\n  }\r\n\r\n  private _tokens: ParagraphToken = [];\r\n  public get tokensFlat(): FinalToken[] {\r\n    return this._tokens.flat(3);\r\n  }\r\n  /**\r\n   * Tokens representing parsed out and styled tagged text. This is generated by update.\r\n   * They contain all the information needed to render the text fields and other children in your component.\r\n   */\r\n  public get tokens(): ParagraphToken {\r\n    return this._tokens;\r\n  }\r\n\r\n  private _text = \"\";\r\n  public get text(): string {\r\n    return this._text;\r\n  }\r\n\r\n  /**\r\n   * Alternative implicit setter for text. Always uses default for skipUpdate.\r\n   */\r\n  public set text(text: string) {\r\n    this.setText(text);\r\n  }\r\n\r\n  /**\r\n   * Setter for text that allows you to override the default for skipping the update.\r\n   * @param text Text to add to component with (optional) tags.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the text.\r\n   * When true, setText() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public setText(text: string, skipUpdate?: boolean): void {\r\n    if (text === this._text && this._needsUpdate === false) {\r\n      return;\r\n    }\r\n    this._text = text;\r\n    this._needsUpdate = true;\r\n    this.updateIfShould(skipUpdate);\r\n  }\r\n\r\n  /**\r\n   * Returns the text content with all tags stripped out.\r\n   */\r\n  public get untaggedText(): string {\r\n    return removeTags(this.text);\r\n  }\r\n\r\n  private _tagStyles: TextStyleSet = {};\r\n  public get tagStyles(): TextStyleSet {\r\n    return this._tagStyles;\r\n  }\r\n\r\n  /**\r\n   * Alternative implicit setter for tagStyles. Always uses default for skipUpdate.\r\n   */\r\n  public set tagStyles(styles: TextStyleSet) {\r\n    this.setTagStyles(styles);\r\n  }\r\n\r\n  /**\r\n   * Setter for tagStyles.\r\n   * @param styles Object with strings for keys representing tag names, mapped to style objects.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\r\n   * When true, setTagStyles() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public setTagStyles(styles: TextStyleSet, skipUpdate?: boolean): void {\r\n    Object.entries(styles).forEach(([tag, style]) =>\r\n      this.setStyleForTag(tag, style, true)\r\n    );\r\n    // TODO: add a way to test for identical styles to prevent unnecessary updates.\r\n    this._needsUpdate = true;\r\n    this.updateIfShould(skipUpdate);\r\n  }\r\n\r\n  public getStyleForTag(\r\n    tag: string,\r\n    attributes: AttributesList = {}\r\n  ): TextStyleExtended | undefined {\r\n    return getStyleForTagExt(tag, this.tagStyles, attributes);\r\n  }\r\n\r\n  public getStyleForTags(tags: TagWithAttributes[]): TextStyleExtended {\r\n    const styles = tags.map(({ tagName, attributes }) =>\r\n      this.getStyleForTag(tagName, attributes)\r\n    );\r\n    return combineAllStyles(styles);\r\n  }\r\n\r\n  /**\r\n   * Set a style to be used by a single tag.\r\n   * @param tag Name of the tag to set style for\r\n   * @param styles Style object to assign to the tag.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\r\n   * When true, setStyleForTag() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public setStyleForTag(\r\n    tag: string,\r\n    styles: TextStyleExtended,\r\n    skipUpdate?: boolean\r\n  ): boolean {\r\n    this.tagStyles[tag] = styles;\r\n\r\n    // TODO: warn user when trying to set styles on a tag that doesn't support it...\r\n    // e.g. wordWrapWidth on a styel other than default.\r\n\r\n    // Override some settings on default styles.\r\n    if (tag === \"default\" && this.defaultStyle[IMG_REFERENCE_PROPERTY]) {\r\n      // prevents accidentally setting all text to images.\r\n      console.error(\r\n        `Style \"${IMG_REFERENCE_PROPERTY}\" can not be set on the \"default\" style because it will add images to EVERY tag!`\r\n      );\r\n      this.defaultStyle[IMG_REFERENCE_PROPERTY] = undefined;\r\n    }\r\n    // TODO: add a way to test for identical styles to prevent unnecessary updates.\r\n    this._needsUpdate = true;\r\n    this.updateIfShould(skipUpdate);\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * Removes a style associated with a tag. Note, inline attributes are not affected.\r\n   * @param tag Name of the tag to delete the style of.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\r\n   * When true, removeStylesForTag() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public removeStylesForTag(tag: string, skipUpdate?: boolean): boolean {\r\n    if (tag in this.tagStyles) {\r\n      delete this.tagStyles[tag];\r\n\r\n      this._needsUpdate = true;\r\n      this.updateIfShould(skipUpdate);\r\n\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public get defaultStyle(): TextStyleExtended {\r\n    return this.tagStyles?.default;\r\n  }\r\n  /**\r\n   * Alternative implicit setter for defaultStyle. Always uses default for skipUpdate.\r\n   */\r\n  public set defaultStyle(defaultStyles: TextStyleExtended) {\r\n    this.setDefaultStyle(defaultStyles);\r\n  }\r\n  /**\r\n   * Setter for default styles. A shortcut to this.setStyleForTag(\"default\",...)\r\n   * @param styles A style object to use as the default styles for all text in the component.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\r\n   * When true, setDefaultStyle() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public setDefaultStyle(\r\n    defaultStyles: TextStyleExtended,\r\n    skipUpdate?: boolean\r\n  ): void {\r\n    this.setStyleForTag(\"default\", defaultStyles, skipUpdate);\r\n  }\r\n\r\n  // References to internal elements.\r\n  private _textFields: Text[] = [];\r\n  public get textFields(): Text[] {\r\n    return this._textFields;\r\n  }\r\n  private _sprites: Sprite[] = [];\r\n  public get sprites(): Sprite[] {\r\n    return this._sprites;\r\n  }\r\n  private _decorations: Graphics[] = [];\r\n  public get decorations(): Graphics[] {\r\n    return this._decorations;\r\n  }\r\n  private _spriteTemplates: ImageMap = {};\r\n  public get spriteTemplates(): ImageMap {\r\n    return this._spriteTemplates;\r\n  }\r\n  private _debugGraphics: Graphics | null = null;\r\n\r\n  // Containers for children\r\n  private _textContainer: Container;\r\n  public get textContainer(): Container {\r\n    return this._textContainer;\r\n  }\r\n\r\n  private _decorationContainer: Container;\r\n  public get decorationContainer(): Container {\r\n    return this._decorationContainer;\r\n  }\r\n\r\n  private _spriteContainer: Container;\r\n  public get spriteContainer(): Container {\r\n    return this._spriteContainer;\r\n  }\r\n  private _debugContainer: Container;\r\n  public get debugContainer(): Container {\r\n    return this._debugContainer;\r\n  }\r\n\r\n  constructor(\r\n    text = \"\",\r\n    tagStyles: TextStyleSet = {},\r\n    options: TaggedTextOptions = {},\r\n    texture?: Texture\r\n  ) {\r\n    super(texture);\r\n\r\n    this._textContainer = new Container();\r\n    this._spriteContainer = new Container();\r\n    this._decorationContainer = new Container();\r\n    this._debugContainer = new Container();\r\n\r\n    this.addChild(this._textContainer);\r\n    this.addChild(this._spriteContainer);\r\n    this.addChild(this._decorationContainer);\r\n    this.addChild(this._debugContainer);\r\n\r\n    this.resetChildren();\r\n\r\n    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\r\n    this._options = mergedOptions;\r\n\r\n    tagStyles = { default: {}, ...tagStyles };\r\n\r\n    if (this.options.wrapEmoji) {\r\n      tagStyles[EMOJI_TAG] = { fontFamily: \"sans-serif\" };\r\n    }\r\n    const mergedDefaultStyles = { ...DEFAULT_STYLE, ...tagStyles.default };\r\n    tagStyles.default = mergedDefaultStyles;\r\n    this.tagStyles = tagStyles;\r\n\r\n    if (this.options.imgMap) {\r\n      this.createSpriteTemplatesFromSourceMap(this.options.imgMap);\r\n    }\r\n\r\n    this.text = text;\r\n  }\r\n\r\n  /**\r\n   * Removes all PIXI children from this component's containers.\r\n   * Deletes references to sprites and text fields.\r\n   */\r\n  private resetChildren() {\r\n    this._debugContainer.removeChildren();\r\n    this._textContainer.removeChildren();\r\n    this._spriteContainer.removeChildren();\r\n    this._decorationContainer.removeChildren();\r\n\r\n    this._textFields = [];\r\n    this._sprites = [];\r\n    this._decorations = [];\r\n  }\r\n\r\n  /**\r\n   * Creates associations between string-based keys like \"img\" and\r\n   * image Sprite objects which are included in the text.\r\n   * @param imgMap\r\n   */\r\n  private createSpriteTemplatesFromSourceMap(imgMap: ImageSourceMap) {\r\n    this._spriteTemplates = {};\r\n\r\n    Object.entries(imgMap).forEach(([key, spriteSource]) => {\r\n      let sprite: Sprite;\r\n      if (spriteSource instanceof Sprite) {\r\n        sprite = spriteSource;\r\n      } else {\r\n        // if the entry is not a sprite, attempt to load the sprite as if it is a reference to the sprite source (e.g. an Image element, url, or texture).\r\n        if (isSpriteSource(spriteSource)) {\r\n          sprite = Sprite.from(spriteSource);\r\n        } else if (isTextureSource(spriteSource)) {\r\n          sprite = Sprite.from(Texture.from(spriteSource));\r\n        } else {\r\n          throw new TypeError(\r\n            `The spriteSource provided for key ${key} was not in a valid format. Please use a Sprite, Texture, BaseTexture, string, HTMLImageElement, HTMLVideoElement, HTMLCanvasElement, or SVGElement`\r\n          );\r\n        }\r\n      }\r\n      // Listen for changes to sprites (e.g. when they load.)\r\n      const texture = sprite.texture;\r\n      if (texture !== undefined) {\r\n        texture.baseTexture.addListener(\"update\", (baseTexture: BaseTexture) =>\r\n          this.onImageTextureUpdate(baseTexture)\r\n        );\r\n      }\r\n\r\n      this.spriteTemplates[key] = sprite;\r\n\r\n      // create a style for each of these by default.\r\n      const existingStyle = this.getStyleForTag(key) ?? {};\r\n      const style = { [IMG_REFERENCE_PROPERTY]: key, ...existingStyle };\r\n      this.setStyleForTag(key, style);\r\n    });\r\n  }\r\n\r\n  private onImageTextureUpdate(baseTexture: BaseTexture): void {\r\n    baseTexture;\r\n    this._needsUpdate = true;\r\n    this._needsDraw = true;\r\n    // const didUpdate = this.updateIfShould();\r\n    this.updateIfShould();\r\n\r\n    // this.dispactchEvent(new Event(\"imageUpdate\", texture));\r\n  }\r\n\r\n  /**\r\n   * Determines whether to call update based on the parameter and the options set then calls it or sets needsUpdate to true.\r\n   * @param forcedSkipUpdate This is the parameter provided to some functions that allow you to skip the update.\r\n   * It's factored in along with the defaults to figure out what to do.\r\n   */\r\n  private updateIfShould(forcedSkipUpdate?: boolean): boolean {\r\n    if (\r\n      forcedSkipUpdate === false ||\r\n      (forcedSkipUpdate === undefined && this.options.skipUpdates === false)\r\n    ) {\r\n      this.update();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Calculates styles, positioning, etc. of the text and styles and creates a\r\n   * set of objects that represent where each portion of text and image should\r\n   * be drawn.\r\n   * @param skipDraw *For advanced users* overrides default for redrawing the styles.\r\n   * When true, update() will skip the call to draw() (even if the default is false).\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public update(skipDraw?: boolean): ParagraphToken {\r\n    // Determine default style properties\r\n    const tagStyles = this.tagStyles;\r\n    const { splitStyle } = this.options;\r\n    const spriteTemplates = this.options.imgMap && this.spriteTemplates;\r\n    // const wordWrapWidth = this.defaultStyle.wordWrap\r\n    //   ? this.defaultStyle.wordWrapWidth\r\n    //   : Number.POSITIVE_INFINITY;\r\n    // const align = this.defaultStyle.align;\r\n    // const lineSpacing = this.defaultStyle.lineSpacing;\r\n\r\n    // Pre-process text.\r\n    // Parse tags in the text.\r\n    const tagTokensNew = parseTagsNew(\r\n      this.text,\r\n      Object.keys(this.tagStyles),\r\n      this.options.wrapEmoji\r\n    );\r\n    // Assign styles to each segment.\r\n    const styledTokens = mapTagsToStyles(\r\n      tagTokensNew,\r\n      tagStyles,\r\n      spriteTemplates\r\n    );\r\n    styledTokens;\r\n    // Measure font for each style\r\n    // Measure each segment\r\n    // Create the text segments, position and add them. (draw)\r\n    const newFinalTokens = calculateFinalTokens(styledTokens, splitStyle);\r\n\r\n    this._tokens = newFinalTokens;\r\n    this._needsDraw = true;\r\n\r\n    // Wait one frame to draw so that this doesn't happen multiple times in one frame.\r\n    // if (this.animationRequest) {\r\n    //   window.cancelAnimationFrame(this.animationRequest);\r\n    // }\r\n    // this.animationRequest = window.requestAnimationFrame(\r\n\r\n    this.drawIfShould(skipDraw);\r\n\r\n    if (this.options.debugConsole) {\r\n      console.log(this.toDebugString());\r\n    }\r\n\r\n    this._needsUpdate = false;\r\n\r\n    return newFinalTokens;\r\n  }\r\n\r\n  /**\r\n   * Determines whether to call draw() based on the parameter and the options set then calls it or sets needsDraw to true.\r\n   * @param forcedSkipDraw This is the parameter provided to some functions that allow you to skip the update.\r\n   * It's factored in along with the defaults to figure out what to do.\r\n   */\r\n  private drawIfShould(forcedSkipDraw?: boolean): boolean {\r\n    if (\r\n      forcedSkipDraw === false ||\r\n      (forcedSkipDraw === undefined && this.options.skipDraw === false)\r\n    ) {\r\n      this.draw();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Create and position the display objects based on the tokens.\r\n   */\r\n  public draw(): void {\r\n    this.resetChildren();\r\n    const { drawWhitespace } = this.options;\r\n    const tokens = drawWhitespace\r\n      ? this.tokensFlat\r\n      : // remove any tokens that are purely whitespace unless drawWhitespace is specified\r\n        this.tokensFlat.filter(isNotWhitespaceToken);\r\n\r\n    let drewDecorations = false;\r\n    let displayObject: DisplayObject;\r\n\r\n    tokens.forEach((t) => {\r\n      if (isTextToken(t)) {\r\n        displayObject = this.createTextFieldForToken(t as TextFinalToken);\r\n        this.textContainer.addChild(displayObject);\r\n        this.textFields.push(displayObject as Text);\r\n\r\n        if (t.textDecorations && t.textDecorations.length > 0) {\r\n          for (const d of t.textDecorations) {\r\n            const drawing = this.createDrawingForTextDecoration(d);\r\n            (displayObject as Text).addChild(drawing);\r\n            this._decorations.push(drawing);\r\n          }\r\n          drewDecorations = true;\r\n        }\r\n      }\r\n      if (isSpriteToken(t)) {\r\n        displayObject = t.content as Sprite;\r\n        this.sprites.push(displayObject as Sprite);\r\n        this.spriteContainer.addChild(displayObject);\r\n      }\r\n\r\n      const { bounds } = t;\r\n      displayObject.x = bounds.x;\r\n      displayObject.y = bounds.y;\r\n    });\r\n\r\n    if (drawWhitespace === false && drewDecorations) {\r\n      console.warn(\r\n        \"Warning: you may want to set the `drawWhitespace` option to `true` when using textDecoration (e.g. underlines) otherwise, spaces will not have text decorations.\"\r\n      );\r\n    }\r\n\r\n    if (this.options.debug) {\r\n      this.drawDebug();\r\n    }\r\n    this._needsDraw = false;\r\n  }\r\n\r\n  private createDrawingForTextDecoration(\r\n    textDecoration: TextDecorationMetrics\r\n  ): Graphics {\r\n    const { bounds } = textDecoration;\r\n    let { color } = textDecoration;\r\n    const drawing = new Graphics();\r\n\r\n    if (typeof color === \"string\") {\r\n      if (color.indexOf(\"#\") === 0) {\r\n        color = \"0x\" + color.substring(1);\r\n        color = parseInt(color, 16) as number;\r\n      } else {\r\n        throw new Error(\r\n          \"Sorry, at this point, only hex colors are supported for textDecorations like underlines. Please use either a hex number like 0x66FF33 or a string like '#66FF33'\"\r\n        );\r\n      }\r\n    }\r\n\r\n    drawing\r\n      .beginFill(color as number)\r\n      .drawRect(bounds.x, bounds.y, bounds.width, bounds.height)\r\n      .endFill();\r\n\r\n    return drawing;\r\n  }\r\n\r\n  private createTextFieldForToken(token: TextFinalToken): Text {\r\n    const { textTransform = \"\" } = token.style;\r\n\r\n    let text = token.content;\r\n    switch (textTransform.toLowerCase()) {\r\n      case \"lowercase\":\r\n        text = text.toLowerCase();\r\n        break;\r\n      case \"uppercase\":\r\n        text = text.toUpperCase();\r\n        break;\r\n      case \"capitalize\":\r\n        text = capitalize(text);\r\n        break;\r\n      default:\r\n    }\r\n\r\n    const textField = new Text(text, token.style);\r\n\r\n    let { fontScaleWidth = 1.0, fontScaleHeight = 1.0 } = token.style;\r\n    fontScaleWidth =\r\n      isNaN(fontScaleWidth) || fontScaleWidth < 0 ? 0 : fontScaleWidth;\r\n    fontScaleHeight =\r\n      isNaN(fontScaleHeight) || fontScaleHeight < 0 ? 0 : fontScaleHeight;\r\n\r\n    let finalScaleWidth = fontScaleWidth;\r\n    let finalScaleHeight = fontScaleHeight;\r\n    const largerScale = Math.max(fontScaleWidth, fontScaleHeight);\r\n\r\n    if (largerScale > 1) {\r\n      if (largerScale === fontScaleHeight) {\r\n        finalScaleWidth /= largerScale;\r\n        finalScaleHeight = 1.0;\r\n      } else {\r\n        finalScaleHeight /= largerScale;\r\n        finalScaleWidth = 1.0;\r\n      }\r\n\r\n      const fs = textField.style.fontSize ?? 0;\r\n      const fontSizePx =\r\n        (typeof fs === \"string\" ? fontSizeStringToNumber(fs) : fs) *\r\n        largerScale;\r\n\r\n      textField.style.fontSize = fontSizePx;\r\n    }\r\n\r\n    textField.scale.set(finalScaleWidth, finalScaleHeight);\r\n    return textField;\r\n  }\r\n\r\n  /**\r\n   * Converts the text properties from this.tokens into a human readable string.\r\n   * This is automatically logged to the console on update when debug option is set to true.\r\n   */\r\n  public toDebugString(): string {\r\n    const lines = this.tokens;\r\n    let s = this.untaggedText + \"\\n=====\\n\";\r\n    const nl = \"\\n    \";\r\n    if (lines !== undefined) {\r\n      s += lines.map((line, lineNumber) =>\r\n        line.map((word, wordNumber) =>\r\n          word\r\n            .map((token, tokenNumber) => {\r\n              let text = \"\";\r\n              if (isTextToken(token)) {\r\n                if (isNewlineToken(token)) {\r\n                  text = `\\\\n`;\r\n                } else {\r\n                  text = `\"${token.content}\"`;\r\n                }\r\n              } else if (isSpriteToken(token)) {\r\n                text = `[Image]`;\r\n              }\r\n              let s = `\\n${text}: (${lineNumber}/${wordNumber}/${tokenNumber})`;\r\n              s += `${nl}tags: ${\r\n                token.tags.length === 0\r\n                  ? \"<none>\"\r\n                  : token.tags\r\n                      .split(\",\")\r\n                      .map((tag) => `<${tag}>`)\r\n                      .join(\", \")\r\n              }`;\r\n              s += `${nl}style: ${Object.entries(token.style)\r\n                .map((e) => e.join(\":\"))\r\n                .join(\"; \")}`;\r\n              s += `${nl}size: x:${token.bounds.x} y:${token.bounds.y} width:${\r\n                token.bounds.width\r\n              } height:${token.bounds.height} bottom:${\r\n                token.bounds.height + token.bounds.y\r\n              } right:${token.bounds.x + token.bounds.width}`;\r\n              s += `${nl}font: fontSize:${token.fontProperties.fontSize} ascent:${token.fontProperties.ascent} descent:${token.fontProperties.descent}`;\r\n              return s;\r\n            })\r\n            .join(\"\\n\")\r\n        )\r\n      );\r\n    }\r\n    return s;\r\n  }\r\n\r\n  public drawDebug(): void {\r\n    const paragraph = this.tokens;\r\n    this._debugGraphics = new Graphics();\r\n    this.debugContainer.addChild(this._debugGraphics);\r\n\r\n    const g = this._debugGraphics;\r\n    g.clear();\r\n\r\n    // const { width, height } = this.getBounds();\r\n    // // frame shadow\r\n    // g.lineStyle(2, DEBUG.OUTLINE_SHADOW_COLOR, 0.5);\r\n    // // g.beginFill();\r\n    // g.drawRect(1, 1, width, height);\r\n    // // g.endFill();\r\n\r\n    // // frame\r\n    // g.lineStyle(2, DEBUG.OUTLINE_COLOR, 1);\r\n    // // g.beginFill();\r\n    // g.drawRect(0, 0, width - 1, height - 1);\r\n    // // g.endFill();\r\n\r\n    function createInfoText(text: string, position: Point): Text {\r\n      const info = new Text(text, DEBUG.TEXT_STYLE);\r\n      info.x = position.x + 1;\r\n      info.y = position.y + 1;\r\n      return info;\r\n    }\r\n\r\n    // for (const line of tokens) {\r\n    for (let lineNumber = 0; lineNumber < paragraph.length; lineNumber++) {\r\n      const line = paragraph[lineNumber];\r\n      const lineBounds = getBoundsNested(line);\r\n\r\n      if (this.defaultStyle.wordWrap) {\r\n        const w = this.defaultStyle.wordWrapWidth ?? this.width;\r\n        g.endFill()\r\n          .lineStyle(0.5, DEBUG.LINE_COLOR, 0.2)\r\n          .drawRect(0, lineBounds.y, w, lineBounds.height)\r\n          .endFill();\r\n      }\r\n\r\n      for (let wordNumber = 0; wordNumber < line.length; wordNumber++) {\r\n        const word = line[wordNumber];\r\n        for (const segmentToken of word) {\r\n          const isSprite = isSpriteToken(segmentToken);\r\n          const { x, y, width } = segmentToken.bounds;\r\n          const baseline =\r\n            y +\r\n            (isSprite\r\n              ? segmentToken.bounds.height\r\n              : segmentToken.fontProperties.ascent);\r\n\r\n          let { height } = segmentToken.bounds;\r\n          if (isSprite) {\r\n            height += segmentToken.fontProperties.descent;\r\n          }\r\n\r\n          if (\r\n            isWhitespaceToken(segmentToken) &&\r\n            this.options.drawWhitespace === false\r\n          ) {\r\n            g.lineStyle(1, DEBUG.WHITESPACE_STROKE_COLOR, 1).beginFill(\r\n              DEBUG.WHITESPACE_COLOR,\r\n              0.2\r\n            );\r\n          } else {\r\n            g.lineStyle(1, DEBUG.WORD_STROKE_COLOR, 1).beginFill(\r\n              DEBUG.WORD_FILL_COLOR,\r\n              0.2\r\n            );\r\n          }\r\n\r\n          if (isNewlineToken(segmentToken)) {\r\n            this.debugContainer.addChild(\r\n              createInfoText(\"\", { x, y: y + 10 })\r\n            );\r\n          } else {\r\n            g.lineStyle(0.5, DEBUG.LINE_COLOR, 0.2)\r\n              .drawRect(x, y, width, height)\r\n              .endFill()\r\n\r\n              .lineStyle(1, DEBUG.BASELINE_COLOR, 1)\r\n              .beginFill()\r\n              .drawRect(x, baseline, width, 1)\r\n              .endFill();\r\n          }\r\n\r\n          let info;\r\n          // info = `${token.bounds.width}${token.bounds.height}`;\r\n          if (isTextToken(segmentToken)) {\r\n            // info += ` ${token.tags}`;\r\n            info = `${segmentToken.tags}`;\r\n            this.debugContainer.addChild(createInfoText(info, { x, y }));\r\n          }\r\n          // this.debugContainer.addChild(createInfoText(info, { x, y }));\r\n        }\r\n      }\r\n    }\r\n    // }\r\n\r\n    // Show the outlines of the actual text fields,\r\n    // not just where the tokens say they should be\r\n    // const fields: Text[] = this.textFields;\r\n    // for (const text of fields) {\r\n    //   g.lineStyle(1, DEBUG.TEXT_FIELD_STROKE_COLOR, 1);\r\n    //   g.drawRect(text.x, text.y, text.width, text.height);\r\n    // }\r\n  }\r\n}\r\n"],"names":["combineRecords","a","b","_extends","last","length","isDefined","undefined","flatReduce","f","acc","nested","flat","reduce","flatEvery","p","t","IMG_REFERENCE_PROPERTY","IMG_DISPLAY_PROPERTY","createEmptyFinalToken","content","bounds","PixiRectangle","fontProperties","ascent","descent","fontSize","style","tags","textDecorations","isWhitespace","s","split","every","char","search","isSpriteToken","Sprite","_isTextToken","isTextToken","isWhitespaceToken","_isNewlineToken","isNewlineToken","isNotWhitespaceToken","predicate","input","isEmptyObject","Object","keys","getTagRegex","tagNamesToMatch","matchingTagNames","join","captureGroup","noCaptureGroup","QUOTE","NOT_QUOTE","TAG_NAMES","ATTRIBUTE_VALUE","ATTRIBUTES","WHITESPACE","CHAR","RegExp","TAG_OPEN","EMOJI_TAG","parseAttributes","attributesString","trim","obj","attribute","attributePair","name","valueStr","substr","createTagMatchData","match","tag","openTagName","attributes","closeTagName","index","tagName","isOpening","selfClosingTagSearch","group","any","not","TAG_SLASH","tagMatchToTagToken","children","capitalize","str","chars","converted","i","charAt","toUpperCase","measureFont","context","TextMetrics","font","getFontPropertiesOfText","textField","forceUpdate","updateText","_textField$style$font","props","fs","NaN","isNaN","Number","Error","DEFAULT_STYLE","align","valign","wordWrap","wordWrapWidth","lineSpacing","fill","combineStyles","combineAllStyles","styles","filter","getStyleForTag","tagStyles","_injectAttributes","injectAttributes","convertedAttributes","key","value","parseFloat","convertAttributeValues","values","rectFromContainer","container","offset","x","y","Rectangle","width","height","translateLine","line","map","point","translatePoint","lineWidth","wordsInLine","firstWord","lastWord","setBoundsX","object","positionWordX","word","prevBounds","token","concatBounds","originalBounds","Math","min","max","getBoundsNested","alignLeft","newLine","concat","getTallestToken","tallest","current","_current$bounds$heigh","_tallest$bounds$heigh","h","notEmptyString","SPLIT_MARKER","splitAroundWhitespace","replace","DEFAULT_OPTIONS","debug","debugConsole","splitStyle","imgMap","skipUpdates","skipDraw","drawWhitespace","wrapEmoji","DEBUG","fontFamily","dropShadow","DEFAULT_STYLE_SET","default","freeze","TaggedText","defaultStyles","defaultOptions","options","this","_options","needsUpdate","_needsUpdate","needsDraw","_needsDraw","tokensFlat","_tokens","tokens","text","_text","setText","skipUpdate","updateIfShould","untaggedText","_tagStyles","setTagStyles","entries","forEach","setStyleForTag","getStyleForTagExt","getStyleForTags","defaultStyle","console","error","removeStylesForTag","_this$tagStyles","setDefaultStyle","textFields","_textFields","sprites","_sprites","decorations","_decorations","spriteTemplates","_spriteTemplates","textContainer","_textContainer","decorationContainer","_decorationContainer","spriteContainer","_spriteContainer","debugContainer","_debugContainer","constructor","texture","super","_debugGraphics","Container","addChild","resetChildren","mergedOptions","mergedDefaultStyles","createSpriteTemplatesFromSourceMap","removeChildren","spriteSource","_this$getStyleForTag","sprite","Texture","HTMLCanvasElement","HTMLVideoElement","from","isTextureSource","HTMLImageElement","BaseTexture","TypeError","baseTexture","addListener","onImageTextureUpdate","existingStyle","forcedSkipUpdate","update","styledTokens","mapTagsToStyles","_styles$default","tagStack","styleCache","convertTagTokenToStyledToken","_style$IMG_REFERENCE_","objects","push","o","tagHash","JSON","stringify","tagWithAttributesToStyle","stylesWithDefault","textDecoration","decorationColor","decorationThickness","defaultColor","defaultThickness","mergeDecoration","decorationLineType","decorationLineTypeCamelCase","_style$textDecoration","_style","_style2","_style3","includes","convertDecorationToLineProps","styledToken","imgKey","cloneOfSprite","cloneSprite","pop","parseTagsNew","shouldWrapEmoji","getEmojiRegex","test","containsEmoji","emojiRegex","source","replaceAll","tagStart","_","output","replaceSelfClosingTags","re","tagMatches","exec","tagMatch","segments","extractSegments","tagMatchData","remaining","startOfTag","endOfTag","segment","createTokensNew","rootTokens","tokenStack","_segments","poppedToken","warn","newFinalTokens","calculateFinalTokens","_defaultStyle$lineSpa","_defaultStyle$align","sizer","PixiText","generateFinalTokenFromStyledToken","dropShadowBlur","dropShadowDistance","dropShadowAngle","textSegments","splitText","flatMap","suggestion","badStyle","toLowerCase","indexOf","textTokens","_style$fontScaleWidth","_style$fontScaleHeigh","_sizer$style$strokeTh","textTransform","sw","fontScaleWidth","sh","fontScaleHeight","scaleWidth","scaleHeight","scale","set","stroke","strokeThickness","extractDecorations","textBounds","baseline","ascender","xHeight","_style4","color","metrics","isIcon","newStyle","newTags","finalTokens","ww","www","hasWordWrapWidth","layout","maxWidth","cursor","wordWidth","allLines","tallestHeightInLine","addWordBufferToLineBuffer","addLineToListOfLines","addLineToListOfLinesAndMoveCursorToNextLine","setTallestHeight","_token$fontProperties","_token$fontProperties2","_token$bounds$height","_token$bounds","positionTokenAtCursorAndAdvanceCursor","positionWordBufferAtCursorAndAdvanceCursor","isBlockImage","addTokenToWordAndUpdateWordWidth","isNewline","isImage","collapsedWhitespace","lines","collapseWhitespacesOnEndOfLines","valignedLines","verticalAlignInLines","overrideValign","previousTallestToken","previousLineBottom","newLines","_tallestToken$bounds$","_tallestToken$bounds","_tallestToken$fontPro","_tallestToken$fontPro2","tallestToken","tallestHeight","tallestAscent","newWord","newToken","newBounds","newY","alignLines","alignFunction","alignRight","center","alignCenter","maxLineWidth","nonZeroWidthWords","countNonZeroWidthWords","first","rest","result","combinedBounds","spacerWidth","previousWord","wordBoundsForLine","wordBounds","alignedLine","POSITIVE_INFINITY","drawIfShould","log","toDebugString","forcedSkipDraw","draw","displayObject","drewDecorations","createTextFieldForToken","d","drawing","createDrawingForTextDecoration","drawDebug","Graphics","substring","parseInt","beginFill","drawRect","endFill","Text","finalScaleWidth","finalScaleHeight","largerScale","fontSizePx","size","valueString","unit","fontSizeStringToNumber","nl","lineNumber","wordNumber","tokenNumber","e","paragraph","g","createInfoText","position","info","clear","lineBounds","_this$defaultStyle$wo","w","lineStyle","segmentToken","isSprite"],"mappings":"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"}