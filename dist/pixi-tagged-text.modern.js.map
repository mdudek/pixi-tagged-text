{"version":3,"file":"pixi-tagged-text.modern.js","sources":["../src/functionalUtils.ts","../src/types.ts","../src/tags.ts","../src/stringUtil.ts","../src/pixiUtils.ts","../src/style.ts","../src/layout.ts","../src/TaggedText.ts"],"sourcesContent":["import { Nested } from \"./types\";\n\n/**\n * a -> boolean\n */\ntype Predicate<T extends unknown> = (t: T) => boolean;\n\nexport const combineRecords = <\n  A extends Record<string, unknown>,\n  B extends Record<string, unknown> = A\n>(\n  a: A,\n  b: B\n): A & B => ({\n  ...a,\n  ...b,\n});\n\nexport const first = <T>(a: T[]): T => a[0];\n\n/**\n * Return the last item in a list.\n * List f => f a -> a\n */\nexport const last = <T>(a: T[]): T => a[a.length - 1];\n\nexport const isDefined: Predicate<unknown | undefined> = (a): boolean =>\n  a !== undefined;\n\n/**\n * Predicate p => p -> p\n */\nexport const complement =\n  <T extends unknown>(predicate: Predicate<T>) =>\n  (input: T): boolean =>\n    !predicate(input);\n\n/**\n * List f => string -> f {string: a} -> f a\n */\nexport const pluck =\n  <T extends unknown, U extends unknown>(key: keyof U) =>\n  (objects: U[]): T[] =>\n    (objects as (U & Record<string, T>)[]).map<T>((o) => o[key]);\n\nexport const assoc =\n  <T extends Record<string, U>, U extends unknown>(key: keyof T) =>\n  (value: U) =>\n  (object: T): T => ({\n    ...object,\n    ...{ [key]: value },\n  });\n\nexport const mapProp =\n  <T, U>(k: keyof U) =>\n  (f: (t: T) => T) =>\n  (o: U): U => ({\n    ...o,\n    [k]: f((o as U & Record<string, T>)[k]),\n  });\n\n// export const every = <T>(p: Predicate<T>) => (a: T[]): boolean => a.every(p);\n\nexport const flatReduce =\n  <T, U>(f: (acc: U, t: T) => U, acc: U) =>\n  (nested: Nested<T>): U =>\n    [nested].flat(255).reduce(f, acc);\n\ntype FlatReduceRetrun<T, U> = (nested: Nested<T>) => U;\n\nexport const flatEvery = <T>(p: Predicate<T>): FlatReduceRetrun<T, boolean> =>\n  flatReduce<T, boolean>((acc: boolean, t: T) => acc && p(t), true);\n\nexport const nestedMap =\n  <T, U>(f: (t: T) => U) =>\n  (nested: Nested<T>): Nested<U> =>\n    nested instanceof Array ? nested.map(nestedMap(f)) : f(nested);\n\nexport const countIf =\n  <T>(p: Predicate<T>) =>\n  (a: Array<T>): number =>\n    a.reduce((count, item) => (p(item) ? count + 1 : count), 0);\n\nexport type Unary<Param, Return> = (p: Param) => Return;\n","import { BaseTexture, Texture } from \"@pixi/core\";\nimport { Rectangle as PixiRectangle } from \"@pixi/math\";\nimport { Sprite } from \"@pixi/sprite\";\nimport { TextStyle as PixiTextStyle } from \"@pixi/text\";\nimport { complement, flatEvery } from \"./functionalUtils\";\n\n///// GENERAL PURPOSE\n\nexport type Point = {\n  x: number;\n  y: number;\n};\nexport type Rectangle = Point & {\n  width: number;\n  height: number;\n};\n\nexport interface IFontMetrics {\n  ascent: number;\n  descent: number;\n  fontSize: number;\n}\n\nexport type Bounds = Rectangle;\n\nexport type Nested<T> = T | Array<Nested<T>>;\n\n///// OPTIONS\n\nexport type SpriteSource =\n  | string\n  | Texture\n  | HTMLCanvasElement\n  | HTMLVideoElement;\n\nexport type TextureSource =\n  | string\n  | HTMLImageElement\n  | HTMLCanvasElement\n  | HTMLVideoElement\n  | BaseTexture;\n\nexport type ImageSource = Sprite | SpriteSource | TextureSource;\n\nexport const isSpriteSource = (s: ImageSource): s is SpriteSource =>\n  typeof s === \"string\" ||\n  s instanceof Texture ||\n  s instanceof HTMLCanvasElement ||\n  s instanceof HTMLVideoElement;\nexport const isTextureSource = (s: ImageSource): s is TextureSource =>\n  s instanceof HTMLImageElement || s instanceof BaseTexture;\n\nexport type ImageSourceMap = Record<string, ImageSource>;\nexport type ImageMap = Record<string, Sprite>;\n\nexport type SplitStyle = \"words\" | \"characters\";\nexport interface TaggedTextOptions {\n  debug?: boolean;\n  debugConsole?: boolean;\n  splitStyle?: SplitStyle;\n  imgMap?: ImageSourceMap;\n  skipUpdates?: boolean;\n  skipDraw?: boolean;\n  drawWhitespace?: boolean;\n  wrapEmoji?: boolean;\n}\n\n///// STYLE PROPERTIES\n\n// PROPERTY NAMES\nexport const IMG_REFERENCE_PROPERTY = \"imgSrc\";\nexport const IMG_DISPLAY_PROPERTY = \"imgDisplay\";\n\n// todo: add text-transform: uppercase\nexport type Thickness = number;\nexport type Color = string | number;\nexport type Fill = Color | string[] | number[] | CanvasGradient | CanvasPattern;\nexport type VAlign = \"top\" | \"middle\" | \"bottom\" | \"baseline\" | number;\nexport type Align = \"left\" | \"right\" | \"center\" | \"justify\";\nexport type ImageDisplayMode = \"icon\" | \"block\" | \"inline\";\nexport type ImageReference = string;\nexport type ImageDimensionPercentage = string;\nexport type ImageDimension = number | string | ImageDimensionPercentage;\nexport type TextTransform = \"normal\" | \"capitalize\" | \"uppercase\" | \"lowercase\";\nexport type FontStyle = \"normal\" | \"italic\" | \"oblique\";\nexport type TextDecorationValue = \"underline\" | \"overline\" | \"line-through\";\nexport type TextDecoration =\n  | \"normal\"\n  | TextDecorationValue\n  | `${TextDecorationValue} ${TextDecorationValue}`\n  | `${TextDecorationValue} ${TextDecorationValue} ${TextDecorationValue}`;\n\nexport interface TextStyle\n  extends Record<string, unknown>,\n    Partial<PixiTextStyle> {\n  align?: Align;\n  fontStyle?: FontStyle;\n}\n\nexport interface ImageStyles {\n  [IMG_REFERENCE_PROPERTY]?: ImageReference;\n  [IMG_DISPLAY_PROPERTY]?: ImageDisplayMode;\n  imgScale?: ImageDimensionPercentage;\n  imgScaleX?: ImageDimensionPercentage;\n  imgScaleY?: ImageDimensionPercentage;\n  imgWidth?: ImageDimension;\n  imgHeight?: ImageDimension;\n}\n\nexport interface UnderlineStyle {\n  underlineColor?: Color;\n  underlineThickness?: Thickness;\n  underlineOffset?: number;\n}\nexport interface OverlineStyle {\n  overlineColor?: Color;\n  overlineThickness?: Thickness;\n  overlineOffset?: number;\n}\nexport interface LineThroughStyle {\n  lineThroughColor?: Color;\n  lineThroughThickness?: Thickness;\n  lineThroughOffset?: number;\n}\n\nexport interface TextDecorationStyles\n  extends UnderlineStyle,\n    OverlineStyle,\n    LineThroughStyle {}\nexport interface TextStyleExtended\n  extends TextStyle,\n    ImageStyles,\n    TextDecorationStyles {\n  lineSpacing?: number;\n  valign?: VAlign;\n  textTransform?: TextTransform;\n  textDecoration?: TextDecoration;\n  fontScaleWidth?: number;\n  fontScaleHeight?: number;\n}\n\nexport interface TextDecorationMetrics {\n  color: Color;\n  bounds: Bounds;\n}\n\nexport type TextStyleSet = Record<string, TextStyleExtended>;\n\n///// TAG PARSING\n\ntype TagName = string;\ntype AttributeName = string;\ntype AttributeValue = string | number;\nexport type AttributesList = Record<AttributeName, AttributeValue>;\nexport interface TagWithAttributes {\n  tagName: string;\n  attributes: AttributesList;\n}\n\nexport interface TagMatchData extends TagWithAttributes {\n  tag: string;\n  isOpening: boolean;\n  index: number;\n}\nexport type TagStack = TagMatchData[];\n\n///// PARSED TOKENS\n\nexport type NewlineToken = \"\\n\";\nexport type WhitespaceToken = \" \" | \"\\t\" | NewlineToken;\nexport type TextToken = string;\nexport type SpriteToken = Sprite;\n\nexport interface CompositeToken<T extends Token = Token> {\n  children: T[];\n}\n\nexport type Token = TextToken | CompositeToken | SpriteToken;\nexport type Tokens = CompositeToken;\n\nexport interface TagToken extends CompositeToken<TagToken | TextToken> {\n  tag?: TagName;\n  attributes?: AttributesList;\n}\nexport type TagTokens = TagToken;\n\nexport interface StyledToken\n  extends CompositeToken<StyledToken | TextToken | SpriteToken> {\n  style: TextStyleExtended;\n  tags: string;\n}\n\nexport type StyledTokens = StyledToken;\nexport interface FinalToken {\n  content: TextToken | SpriteToken;\n  bounds: Rectangle;\n  fontProperties: IFontMetrics;\n  style: TextStyleExtended;\n  tags: string;\n  textDecorations?: TextDecorationMetrics[];\n}\n\nexport const createEmptyFinalToken = (): FinalToken => ({\n  content: \"\",\n  bounds: new PixiRectangle(),\n  fontProperties: { ascent: 0, descent: 0, fontSize: 0 },\n  style: {},\n  tags: \"\",\n  textDecorations: [],\n});\n\nexport type WordToken = FinalToken[];\nexport type LineToken = WordToken[];\nexport type ParagraphToken = LineToken[];\n\nexport interface SpriteFinalToken extends FinalToken {\n  content: SpriteToken;\n}\nexport interface TextFinalToken extends FinalToken {\n  content: TextToken;\n}\n\nexport interface WhitespaceFinalToken extends TextFinalToken {\n  content: WhitespaceToken;\n}\nexport interface NewlineFinalToken extends TextFinalToken {\n  content: NewlineToken;\n}\n\nexport const isWhitespace = (s: string): s is WhitespaceToken =>\n  s !== \"\" &&\n  s.split(\"\").every((char: string): boolean => char.search(/\\s/) === 0);\nexport const isNewline = (s: string): s is NewlineToken =>\n  isWhitespace(s) && s === \"\\n\";\n\nexport const _isSpriteToken = (t: FinalToken): t is SpriteFinalToken =>\n  t.content instanceof Sprite;\nexport const isSpriteToken = flatEvery(_isSpriteToken);\n\nexport const _isTextToken = (t: FinalToken): t is TextFinalToken =>\n  typeof t.content === \"string\";\nexport const isTextToken = flatEvery(_isTextToken);\n\nexport const _isWhitespaceToken = (t: FinalToken): t is WhitespaceFinalToken =>\n  t !== undefined && _isTextToken(t) && isWhitespace(t.content);\nexport const isWhitespaceToken = flatEvery(_isWhitespaceToken);\n\nexport const _isNewlineToken = (t: FinalToken): t is NewlineFinalToken =>\n  t !== undefined && _isTextToken(t) && isNewline(t.content);\nexport const isNewlineToken = (t?: Nested<FinalToken>): boolean =>\n  t === undefined ? false : flatEvery(_isNewlineToken)(t);\n\nexport const isNotWhitespaceToken = complement(isWhitespaceToken);\n\nexport const isEmptyObject = <T extends unknown>(a: T): boolean =>\n  a instanceof Object && Object.keys(a).length === 0;\n","import getEmojiRegex from \"emoji-regex/es2015/RGI_Emoji\";\n\nimport { last } from \"./functionalUtils\";\nimport {\n  TagMatchData,\n  AttributesList,\n  TagWithAttributes,\n  CompositeToken,\n  TagToken,\n  TextToken,\n  isEmptyObject,\n} from \"./types\";\n\n// TODO: this can probably be just a static value without all the options and parameters.\n// Seems doing one pass will be enough to gather all relevant info.\n// TODO: support self closing tags?\n\n/**\n * Generates a regular expression object for identifying tags and attributes.\n * @param tagNamesToMatch List of tag-names that will be matched by the RegExp\n */\nexport const getTagRegex = (tagNamesToMatch: string[] = [\"\\\\w+\"]): RegExp => {\n  const matchingTagNames = tagNamesToMatch.join(\"|\");\n\n  const captureGroup = (a: string) => `(${a})`;\n  const noCaptureGroup = (a: string) => `(?:${a})`;\n\n  const OR = \"|\";\n  const WHITESPACE = `\\\\s`;\n  const S = WHITESPACE + \"*\";\n  const SS = WHITESPACE + \"+\";\n  const CHAR = \"[A-Za-z0-9_\\\\-]\";\n  const QUOTE = noCaptureGroup(`\"|'`);\n  const NOT_QUOTE = `[^${QUOTE}]`;\n  const TAG_NAMES = captureGroup(matchingTagNames);\n  const ATTRIBUTE_NAME = CHAR + \"+\";\n  const ATTRIBUTE_VALUE = NOT_QUOTE + \"+\";\n\n  const ATTRIBUTES =\n    captureGroup(\n      noCaptureGroup(\n        SS +\n          noCaptureGroup(ATTRIBUTE_NAME) +\n          `=` +\n          QUOTE +\n          noCaptureGroup(ATTRIBUTE_VALUE) +\n          QUOTE\n      ) + \"*\"\n    ) + \"+\";\n  const TAG_OPEN = `<` + TAG_NAMES + ATTRIBUTES + S + `>`;\n  const TAG_CLOSE = `</${TAG_NAMES}${S}>`;\n\n  const pattern = TAG_OPEN + OR + TAG_CLOSE;\n\n  return new RegExp(pattern, \"g\");\n};\n\nexport const EMOJI_TAG = \"__EMOJI__\";\n\n/**\n * Takes a string of attributes and returns an object with key value pairs for each attribute.\n * Converts \"true\" | \"false\" into booleans and number-like strings into numbers.\n * @param attributesString  XML style attributes like \"src='/image.png' alt='foo'\"\n */\nexport const parseAttributes = (attributesString = \"\"): AttributesList => {\n  if (attributesString === \"\") {\n    return {};\n  }\n\n  const attributes = attributesString.trim().split(/\\s+/);\n\n  return attributes.reduce((obj: AttributesList, attribute: string) => {\n    const attributePair = attribute.split(\"=\");\n    const name = attributePair[0].trim();\n    const valueStr: string = attributePair[1]\n      .substr(1, attributePair[1].length - 2)\n      .trim();\n\n    obj[name] = valueStr;\n    return obj;\n  }, {});\n};\n\n/** Converts from RegExpExecArray to TagMatchData */\nexport const createTagMatchData = (match: RegExpExecArray): TagMatchData => {\n  const {\n    0: tag,\n    1: openTagName,\n    2: attributes,\n    3: closeTagName,\n    index,\n  } = match;\n  const tagName = openTagName ?? closeTagName;\n  const isOpening = openTagName !== undefined;\n  return {\n    tag,\n    tagName,\n    isOpening,\n    attributes: parseAttributes(attributes),\n    index,\n  };\n};\n\n/** Converts TagMatchData to TagWithAttributes */\nexport const tagMatchDataToTagWithAttributes = (\n  tag: TagMatchData\n): TagWithAttributes => ({\n  tagName: tag.tagName,\n  attributes: tag.attributes,\n});\n\n/**\n * Splits original text into an untagged list of string segments.\n * @param input Original text input\n * @param tagMatchData Results of regexp exect converted to tag matches.\n */\nexport const extractSegments = (\n  input: string,\n  tagMatchData: TagMatchData[]\n): string[] => {\n  const segments: string[] = [];\n\n  let remaining = input;\n  let offset = 0;\n  let tagMatch: TagMatchData;\n  for (tagMatch of tagMatchData) {\n    if (remaining !== undefined) {\n      const { tag, index } = tagMatch;\n      const startOfTag = index - offset;\n      const endOfTag = startOfTag + tag.length;\n      offset += endOfTag;\n\n      const segment = remaining.substr(0, startOfTag);\n      segments.push(segment);\n\n      remaining = remaining.substr(endOfTag);\n    }\n  }\n  segments.push(remaining);\n\n  return segments;\n};\n\nconst selfClosingTagSearch = (() => {\n  const group = (s: string) => `(${s})`;\n  const any = (s: string) => s + `*`;\n  const not = (...s: string[]) => `[^${s.join(\"\")}]`;\n  const WORD_START = `[A-Za-z_]`;\n  const WORD = `[A-Za-z0-9_]`;\n  const TAG_OPEN = `<`;\n  const TAG_SLASH = `/`;\n  const TAG_CLOSE = `>`;\n  const TAG_SELF_CLOSE = TAG_SLASH + TAG_CLOSE;\n\n  return new RegExp(\n    TAG_OPEN +\n      // tag group\n      group(WORD_START + any(WORD)) +\n      // attribute group\n      group(any(not(TAG_SLASH, TAG_CLOSE))) +\n      TAG_SELF_CLOSE,\n    `gs`\n  );\n})();\n\nexport const wrapEmoji = (input: string): string => {\n  const emojiRegex = new RegExp(\n    `((<|</)[^>]*)?(${getEmojiRegex().source})+`,\n    \"gums\"\n  );\n\n  return input.replaceAll(emojiRegex, (match, tagStart) => {\n    if (tagStart?.length > 0) {\n      // if the emoji is inside a tag, ignore it.\n      return match;\n    }\n    return `<${EMOJI_TAG}>${match}</${EMOJI_TAG}>`;\n  });\n};\n\nexport const replaceSelfClosingTags = (input: string): string =>\n  input.replace(selfClosingTagSearch, (_, tag, attributes = \"\") => {\n    let output = `<${tag}${attributes}></${tag}>`;\n    output = output.replace(/\\s+/g, \" \");\n    output = output.replace(/\\s>/g, \">\");\n    return output;\n  });\n\nexport const removeTags = (input: string): string =>\n  input.replace(getTagRegex(), \"\");\n\n// export const isTextToken = (token: Token): boolean => typeof token === \"string\";\n// export const isNewlineToken = (token: Token): boolean =>\n//   isWhitespaceToken(token) && token === \"\\n\";\n// export const isCompositeToken = (token: Token): boolean =>\n//   isTextToken(token) === false && \"children\" in (token as CompositeToken);\n\n// export const makeSpacesSeparateWords = (segment: string): string[] =>\n//   segment.replace(\" \", \"__SPACE__ __SPACE__\").split(\"__SPACE__\");\n\nexport const tagMatchToTagToken = (tag: TagMatchData): TagToken => {\n  return {\n    tag: tag.tagName,\n    children: [],\n\n    // Add attributes unless undefined\n    ...(isEmptyObject(tag.attributes) ? {} : { attributes: tag.attributes }),\n  };\n};\n\nexport const createTokensNew = (\n  segments: string[],\n  tags: TagMatchData[]\n): (TagToken | TextToken)[] => {\n  const rootTokens: CompositeToken<TagToken | TextToken> = { children: [] };\n  if (segments[0] !== \"\") {\n    rootTokens.children.push(segments[0]);\n  }\n  // Track which tags are opened and closed and add them to the list.\n  const tokenStack: TagToken[] = [rootTokens];\n\n  for (let i = 0; i < tags.length; i++) {\n    const tag = tags[i];\n    const segment = segments[i + 1] ?? \"\";\n    if (tag.isOpening) {\n      const token = tagMatchToTagToken(tag);\n      if (segment !== \"\") {\n        token.children.push(segment);\n      }\n      last(tokenStack).children.push(token);\n      tokenStack.push(token as CompositeToken<TagToken | TextToken>);\n    } else {\n      const poppedToken = tokenStack.pop();\n      if (poppedToken === undefined || poppedToken.tag !== tag.tagName) {\n        throw new Error(\n          `Unexpected tag nesting. Found a closing tag \"${tag.tagName}\" that doesn't match the previously open tag \"${poppedToken?.tag}\"`\n        );\n      }\n      if (segment !== \"\") {\n        last(tokenStack).children.push(segment);\n      }\n    }\n  }\n  if (tokenStack.length > 1) {\n    console.warn(\n      `Found ${tokenStack.length - 1} unclosed tags in\\n${tokenStack\n        .map((token) => token.tag)\n        .join(\"-\")}`\n    );\n  }\n\n  return rootTokens.children;\n};\n\nexport const containsEmoji = (input: string): boolean =>\n  getEmojiRegex().test(input);\n\n/**\n * Converts a string into a list of tokens that match segments of text with styles.\n *\n * @param input Input string with XML-style tags.\n * @param tagNamesToMatch Used to only tokenize tags that have styles defined for them.\n */\nexport const parseTagsNew = (\n  input: string,\n  tagNamesToMatch?: string[],\n  shouldWrapEmoji?: boolean\n): CompositeToken<TagToken | TextToken> => {\n  // TODO: Warn the user if tags were found that are not defined in the tagStyles.\n\n  if (shouldWrapEmoji && containsEmoji(input)) {\n    input = wrapEmoji(input);\n  }\n\n  input = replaceSelfClosingTags(input);\n  const re = getTagRegex(tagNamesToMatch);\n  const matchesRaw: RegExpExecArray[] = [];\n  const tagMatches: TagMatchData[] = [];\n  let match;\n  while ((match = re.exec(input))) {\n    matchesRaw.push(match);\n\n    const tagMatch = createTagMatchData(match);\n    tagMatches.push(tagMatch);\n  }\n\n  const segments = extractSegments(input, tagMatches);\n\n  const tokens = createTokensNew(segments, tagMatches);\n\n  return { children: tokens };\n};\n","// modified from: https://github.com/h26k2/capitalize-text/blob/master/index.js\nexport const capitalize = (str: string): string => {\n  const chars = str.split(\" \");\n  let converted = ``;\n\n  for (let i = 0; i < chars.length; i++) {\n    converted += `${chars[i].charAt(0).toUpperCase()}${chars[i].substr(1)} `;\n  }\n\n  return converted.trim();\n};\n","import { Container, DisplayObject } from \"@pixi/display\";\nimport { Sprite } from \"@pixi/sprite\";\nimport { Text, TextMetrics } from \"@pixi/text\";\nimport { IFontMetrics } from \"./types\";\n\nconst PX_PER_EM = 16;\nconst PX_PER_PERCENT = 16 / 100;\nconst PX_PER_PT = 1.3281472327365;\n\nexport const measureFont = (context: CanvasRenderingContext2D): IFontMetrics =>\n  TextMetrics.measureFont(context.font);\n\nexport const INITIAL_FONT_PROPS: IFontMetrics = {\n  ascent: 10,\n  descent: 2,\n  fontSize: 12,\n};\n\n// TODO: Memoize\nexport const getFontPropertiesOfText = (\n  textField: Text,\n  forceUpdate = false\n): IFontMetrics => {\n  if (forceUpdate) {\n    textField.updateText(false);\n    return measureFont(textField.context);\n  } else {\n    const props = measureFont(textField.context);\n    if (\n      props.ascent === INITIAL_FONT_PROPS.ascent &&\n      props.descent === INITIAL_FONT_PROPS.descent &&\n      (!textField.style.fontSize ||\n        textField.style.fontSize > INITIAL_FONT_PROPS.fontSize ||\n        isNaN(textField.style.fontSize as number))\n    ) {\n      throw new Error(\n        \"getFontPropertiesOfText() returned metrics associated with a Text field that has not been updated yet. Please try using the forceUpdate parameter when you call this function.\"\n      );\n    }\n    return measureFont(textField.context);\n  }\n};\n\nexport const checkPixiVersion = (\n  version: string,\n  expectedMajorVersion: number\n): number => {\n  const majorVersion = parseInt(version.split(\".\")[0], 10);\n  if (majorVersion !== expectedMajorVersion) {\n    throw new Error(\n      `Detected Pixi.js version ${version}. pixi-multistyle-text supports Pixi.js version ${expectedMajorVersion}. (Please use v0.8.0 of this package for Pixi 4 support.)`\n    );\n  }\n  return 0;\n};\n\nexport const addChildrenToContainer = (\n  children: DisplayObject[],\n  container: Container\n): void => children.forEach((child) => container.addChild(child));\n\nexport const cloneSprite = (sprite: Sprite): Sprite =>\n  new Sprite(sprite.texture);\n\nexport const fontSizeStringToNumber = (size: string): number => {\n  const [valueString, unit] = size.split(/(%|pt|px|r?em)/);\n  const value = parseFloat(valueString);\n\n  if (isNaN(value)) {\n    NaN;\n  }\n\n  switch (unit) {\n    case \"%\":\n      return value * PX_PER_PERCENT;\n    case \"em\":\n    case \"rem\":\n      return value * PX_PER_EM;\n    case \"pt\":\n      return value * PX_PER_PT;\n    case \"px\":\n    default:\n      // keep as is.\n      return value;\n  }\n};\n","import { Sprite } from \"@pixi/sprite\";\nimport { combineRecords, isDefined, pluck } from \"./functionalUtils\";\nimport {\n  AttributesList,\n  TagWithAttributes,\n  TextStyleExtended,\n  TextStyleSet,\n  IMG_REFERENCE_PROPERTY,\n  IMG_DISPLAY_PROPERTY,\n  ImageMap,\n  TextToken,\n  TagToken,\n  TagTokens,\n  StyledTokens,\n  StyledToken,\n  SpriteToken,\n  isEmptyObject,\n  TextDecorationValue,\n  Bounds,\n  TextDecorationMetrics,\n  Thickness,\n  Color,\n  IFontMetrics,\n} from \"./types\";\nimport { cloneSprite } from \"./pixiUtils\";\n\nexport const DEFAULT_STYLE: TextStyleExtended = {\n  align: \"left\",\n  valign: \"baseline\",\n  [IMG_DISPLAY_PROPERTY]: \"inline\",\n  wordWrap: true,\n  wordWrapWidth: 500,\n  lineSpacing: 0,\n  fill: 0x000000,\n};\n\n/**\n * Combine 2 styles into one.\n */\nexport const combineStyles: (\n  a: TextStyleExtended,\n  b: TextStyleExtended\n) => TextStyleExtended = combineRecords;\n\n/**\n * Combines multiple styles into one.\n * @param styles List of styles to combine.\n */\nexport const combineAllStyles = (\n  styles: (TextStyleExtended | undefined)[]\n): TextStyleExtended =>\n  (styles.filter(isDefined) as TextStyleExtended[]).reduce(combineStyles, {});\n\nexport const convertAttributeValues = (\n  attributes: AttributesList\n): AttributesList => {\n  const convertedAttributes: AttributesList = {};\n  for (const key in attributes) {\n    const value = attributes[key] as string;\n    if (isNaN(parseFloat(value)) === false) {\n      convertedAttributes[key] = parseFloat(value);\n    } else {\n      convertedAttributes[key] = value;\n    }\n  }\n  return convertedAttributes;\n};\n\n/**\n * Replaces properties of a TextStyle object with new values.\n * (Since AttributeLists are basically partially defined styles, this is the same as combineStyles)\n * @param attributes List of attributes to overwrite in the target style.\n * @param style The style to modify.\n */\nexport const injectAttributes = (\n  attributes: AttributesList = {},\n  style: TextStyleExtended = {}\n): TextStyleExtended | undefined => {\n  if (isEmptyObject(style) && isEmptyObject(attributes)) return undefined;\n  return combineRecords(style, convertAttributeValues(attributes));\n};\n\n/**\n * Looks up a tag in a list of tag styles (with optional attributes) and returns it.\n * @param tagName Tag name to check.\n * @param tagStyles Set of tag styles to search.\n * @param attributes Attributes to inject into the style (optional).\n */\nexport const getStyleForTag = (\n  tagName: string,\n  tagStyles: TextStyleSet,\n  attributes: AttributesList = {}\n): TextStyleExtended | undefined => {\n  const style = injectAttributes(attributes, tagStyles[tagName]);\n  if (style == {}) return undefined;\n  return style;\n};\n\n/**\n * Converts TagWithAttributes into a style object.\n * @param param0 A TagWithAttributes object that has a tag name matched with any optional attributes.\n * @param tagStyles Set of tag styles to search.\n */\nexport const tagWithAttributesToStyle = (\n  { tagName, attributes }: TagWithAttributes,\n  tagStyles: TextStyleSet\n): TextStyleExtended =>\n  getStyleForTag(tagName, tagStyles, attributes) as TextStyleExtended;\n\n/**\n * Gets styles for several tags and returns a single combined style object.\n * Results are cached for future requests.\n * @param tags Tags (with attribues) to look up.\n * @param tagStyles Set of tag styles to search.\n * @param styleCache An object that holds the cached values for the combined styles.\n * @returns\n */\nexport const getStyleForTags = (\n  tags: TagWithAttributes[],\n  tagStyles: TextStyleSet,\n  styleCache: TextStyleSet\n): TextStyleExtended => {\n  const tagHash = JSON.stringify(tags);\n  if (styleCache[tagHash] === undefined) {\n    const defaultStyle = tagStyles.default;\n    const styles = tags.map((tag) => tagWithAttributesToStyle(tag, tagStyles));\n    const stylesWithDefault = [defaultStyle, ...styles];\n    styleCache[tagHash] = combineAllStyles(stylesWithDefault);\n  }\n  return styleCache[tagHash];\n};\n\nexport const mapTagsToStyles = (\n  tokens: TagTokens,\n  styles: TextStyleSet,\n  spriteTemplates?: ImageMap\n): StyledTokens => {\n  const defaultStyle: TextStyleExtended = styles.default ?? {};\n  const tagStack: TagWithAttributes[] = [];\n  const styleCache = {};\n\n  const convertTagTokenToStyledToken = (\n    token: TagToken | TextToken\n  ): StyledToken | TextToken => {\n    if (typeof token === \"string\") {\n      return token as TextToken;\n    }\n\n    const { tag, attributes = {} } = token;\n    let style: TextStyleExtended = defaultStyle;\n    let tags = \"\";\n\n    if (tag) {\n      // Put the current tag on the stack.\n      tagStack.push({ tagName: tag, attributes });\n      // Get tag names as comma separates string\n      tags = pluck(\"tagName\")(tagStack).join(\",\");\n      // Merge all tags into a style object.\n      style = getStyleForTags(tagStack, styles, styleCache);\n      style = convertDecorationToLineProps(style);\n    }\n\n    const styledToken: StyledToken = {\n      style,\n      tags,\n      children: token.children.map(convertTagTokenToStyledToken),\n    };\n\n    // If a matching sprite exits in the imgMap...\n    const imgKey = style[IMG_REFERENCE_PROPERTY] ?? \"\";\n    if (imgKey) {\n      if (spriteTemplates === undefined) {\n        throw new Error(\n          `An image tag with ${IMG_REFERENCE_PROPERTY}=\"${imgKey}\" was encountered, but no imgMap was provided. Please include a valid Sprite in the imgMap property in the options in your TaggedText constructor.`\n        );\n      }\n      const sprite: SpriteToken | undefined = spriteTemplates[imgKey];\n      if (sprite === undefined) {\n        throw new Error(\n          `An image tag with ${IMG_REFERENCE_PROPERTY}=\"${imgKey}\" was encountered, but there was no matching sprite in the sprite map. Please include a valid Sprite in the imgMap property in the options in your TaggedText constructor.`\n        );\n      }\n      if (sprite instanceof Sprite === false) {\n        throw new Error(\n          `The image reference you provided for \"${imgKey}\" is not a Sprite. The imgMap can only accept PIXI.Sprite instances.`\n        );\n      }\n\n      // insert sprite as first token.\n      const cloneOfSprite = cloneSprite(sprite);\n      styledToken.children = [cloneOfSprite, ...styledToken.children];\n    }\n\n    // Remove the last tag from the stack\n    tagStack.pop();\n\n    return styledToken;\n  };\n\n  return convertTagTokenToStyledToken(tokens) as StyledTokens;\n};\n\nexport const convertDecorationToLineProps = (\n  style: TextStyleExtended\n): TextStyleExtended => {\n  const { textDecoration } = style;\n\n  if (textDecoration === undefined || textDecoration === \"normal\") {\n    return style;\n  }\n\n  const { decorationColor, decorationThickness } = style;\n  const defaultColor = decorationColor || style.fill || DEFAULT_STYLE.fill;\n  const defaultThickness = decorationThickness || 1;\n  const defaultOffset = 0;\n\n  function mergeDecoration(\n    decorationLineType: TextDecorationValue,\n    decorationLineTypeCamelCase: string = decorationLineType\n  ): Partial<TextStyleExtended> {\n    if (style.textDecoration?.includes(decorationLineType)) {\n      return {\n        [`${decorationLineTypeCamelCase}Color`]:\n          style[`${decorationLineTypeCamelCase}Color`] ?? defaultColor,\n        [`${decorationLineTypeCamelCase}Thickness`]:\n          style[`${decorationLineTypeCamelCase}Thickness`] ?? defaultThickness,\n        [`${decorationLineTypeCamelCase}Offset`]:\n          style[`${decorationLineTypeCamelCase}Offset`] ?? defaultOffset,\n      };\n    }\n    return {};\n  }\n\n  return {\n    ...style,\n    ...mergeDecoration(\"underline\"),\n    ...mergeDecoration(\"overline\"),\n    ...mergeDecoration(\"line-through\", \"lineThrough\"),\n  };\n};\n\nexport const extractDecorations = (\n  style: TextStyleExtended,\n  textBounds: Bounds,\n  fontProperties: IFontMetrics\n): TextDecorationMetrics[] => {\n  const { ascent, descent } = fontProperties;\n  const baseline = ascent;\n  const ascender = descent;\n  const xHeight = baseline - ascender;\n  const { width } = textBounds;\n  const x = 0;\n\n  function styleToMetrics(key: string): TextDecorationMetrics | undefined {\n    const color = style[`${key}Color`] as Color;\n    const height = style[`${key}Thickness`] as Thickness;\n    const offset = (style[`${key}Offset`] as number) ?? 0;\n\n    if (color === undefined || height === undefined) {\n      return undefined;\n    }\n\n    let y = offset;\n    if (key === \"underline\") {\n      // position underline below baseline\n      y += baseline + descent / 2;\n    } else if (key === \"lineThrough\") {\n      // position lineThrough in center of ascent\n      y += ascender + xHeight / 2;\n    }\n    // else, position overline at top of text\n\n    return {\n      color,\n      bounds: { x, y, width, height },\n    };\n  }\n\n  const keySuffices = [\"underline\", \"overline\", \"lineThrough\"];\n  const metrics = keySuffices\n    .map(styleToMetrics)\n    .filter((x) => x !== undefined) as TextDecorationMetrics[];\n  return metrics;\n};\n","import { Container } from \"@pixi/display\";\nimport { Point as PixiPoint, Rectangle } from \"@pixi/math\";\nimport { Sprite } from \"@pixi/sprite\";\nimport { Text as PixiText } from \"@pixi/text\";\nimport {\n  assoc,\n  first,\n  flatReduce,\n  last,\n  mapProp,\n  Unary,\n} from \"./functionalUtils\";\nimport { getFontPropertiesOfText } from \"./pixiUtils\";\nimport { capitalize } from \"./stringUtil\";\nimport { extractDecorations } from \"./style\";\nimport {\n  Align,\n  Bounds,\n  createEmptyFinalToken,\n  FinalToken,\n  IFontMetrics,\n  IMG_DISPLAY_PROPERTY,\n  isNewlineToken,\n  isNotWhitespaceToken,\n  isSpriteToken,\n  isWhitespaceToken,\n  LineToken,\n  Nested,\n  ParagraphToken,\n  Point,\n  SplitStyle,\n  SpriteToken,\n  StyledToken,\n  StyledTokens,\n  TextStyleExtended,\n  TextToken,\n  VAlign,\n  WordToken,\n} from \"./types\";\n\nconst ICON_SCALE_BASE = 0.8;\n\n/**\n * Translates the current location point to the beginning of the next line.\n *\n * @param offset An offset coordinate. The function will make a clone of this with new coordinates.\n * @param largestLineHeight The largest height in the line of text.\n * @param lineSpacing The amount of extra space to insert between each line.\n */\nexport const updateOffsetForNewLine = (\n  offset: Point,\n  largestLineHeight: number,\n  lineSpacing: number\n): Point => new PixiPoint(0, offset.y + largestLineHeight + lineSpacing);\n\nconst rectFromContainer = (\n  container: Container,\n  offset: Point = { x: 0, y: 0 }\n): Bounds => {\n  const w = container.width;\n  const h = container.height;\n  const x = offset.x + container.x;\n  const y = offset.y + container.y;\n\n  return new Rectangle(x, y, w, h);\n};\n\n/**\n * Move a point by an offset.\n * Point p => p -> p-> -> p\n * @param offset Amount to translate the target.\n * @param point Target to translate.\n */\nexport const translatePoint =\n  <P extends Point>(offset: Point) =>\n  (point: P): P => ({\n    ...point,\n    x: point.x + offset.x,\n    y: point.y + offset.y,\n  });\n\n/**\n * Same as translatePoint but for all the points in an array.\n */\nexport const translateLine =\n  (offset: Point) =>\n  (line: Bounds[]): Bounds[] =>\n    line.map(translatePoint(offset));\n\nexport const translateWordPosition =\n  (offset: Point) =>\n  (word: WordToken): WordToken =>\n    word.map((token) =>\n      mapProp<Bounds, FinalToken>(\"bounds\")(translatePoint(offset))(token)\n    );\n\nexport const translateTokenLine =\n  (offset: Point) =>\n  (line: LineToken): LineToken =>\n    line.map(translateWordPosition(offset));\n\nexport const lineWidth = (wordsInLine: Bounds[]): number => {\n  const firstWord = first(wordsInLine);\n  const lastWord = last(wordsInLine);\n\n  if (firstWord === undefined) {\n    return 0;\n  }\n  if (lastWord === firstWord) {\n    return firstWord.width;\n  }\n  return lastWord.x + lastWord.width - firstWord.x;\n};\n\nexport const center = (x: number, context: number): number => (context - x) / 2;\n\nconst setBoundsX = assoc<Bounds, number>(\"x\");\n\nconst positionWordX =\n  (x: number) =>\n  (word: WordToken): WordToken => {\n    let prevBounds: Bounds;\n    return word.map((token) => {\n      if (prevBounds === undefined) {\n        token.bounds.x = x;\n        prevBounds = token.bounds;\n      } else {\n        token.bounds.x = prevBounds.x + prevBounds.width;\n        prevBounds = token.bounds;\n      }\n      return token;\n    });\n  };\n\nexport const concatBounds = (\n  originalBounds: Bounds = { x: NaN, y: NaN, width: NaN, height: NaN },\n  bounds: Bounds = { x: NaN, y: NaN, width: NaN, height: NaN }\n): Bounds => {\n  if (isNaN(originalBounds.x)) {\n    return bounds;\n  }\n\n  const x = Math.min(originalBounds.x, bounds.x);\n  const y = Math.min(originalBounds.y, bounds.y);\n  const right = Math.max(\n    originalBounds.x + originalBounds.width,\n    bounds.x + bounds.width\n  );\n  const bottom = Math.max(\n    originalBounds.y + originalBounds.height,\n    bounds.y + bounds.height\n  );\n  const width = right - x;\n  const height = bottom - y;\n\n  return { x, y, width, height };\n};\n\nconst getCombinedBounds = (bounds: Bounds[]): Bounds =>\n  bounds.reduce(concatBounds);\n\nexport const getBoundsNested: Unary<Nested<FinalToken>, Bounds> = flatReduce<\n  FinalToken,\n  Bounds\n>((acc: Bounds, t: FinalToken) => concatBounds(acc, t.bounds), {\n  x: NaN,\n  y: NaN,\n  width: NaN,\n  height: NaN,\n});\n\nexport const alignLeft = (line: Bounds[]): Bounds[] =>\n  line.reduce(\n    (newLine: Bounds[], bounds: Bounds, i: number): Bounds[] =>\n      // is first word?\n      i === 0\n        ? [setBoundsX(0)(bounds)]\n        : newLine.concat([\n            setBoundsX(newLine[i - 1].x + newLine[i - 1].width)(bounds),\n          ]),\n    []\n  );\n\nexport const alignRight =\n  (maxWidth: number) =>\n  (line: Bounds[]): Bounds[] =>\n    translateLine({\n      x: maxWidth - lineWidth(line),\n      y: 0,\n    })(alignLeft(line));\n\nexport const alignCenter =\n  (maxWidth: number) =>\n  (line: Bounds[]): Bounds[] =>\n    translateLine({ x: center(lineWidth(line), maxWidth), y: 0 })(\n      alignLeft(line)\n    );\n\nexport const alignJustify =\n  (maxLineWidth: number) =>\n  (line: Bounds[]): Bounds[] => {\n    const count = line.length;\n    if (count === 0) {\n      return [];\n    }\n\n    const nonZeroWidthWords: Bounds[] = line.filter(({ width }) => width > 0);\n    const countNonZeroWidthWords = nonZeroWidthWords.length;\n\n    if (countNonZeroWidthWords === 1) {\n      const [first, ...rest] = line;\n      first.x = 0;\n      return [first, ...rest];\n    }\n\n    const result: Bounds[] = [];\n    const combinedBounds = getCombinedBounds(nonZeroWidthWords);\n    const w = combinedBounds.width;\n    const totalSpace = maxLineWidth - w;\n    const spacerWidth = totalSpace / (countNonZeroWidthWords - 1);\n\n    let previousWord;\n    for (let i = 0; i < line.length; i++) {\n      const bounds = line[i];\n      if (bounds.width === 0) {\n        result[i] = { ...bounds };\n        continue;\n      }\n      let x;\n      if (previousWord === undefined) {\n        x = 0;\n      } else {\n        x = previousWord.x + previousWord.width + spacerWidth;\n      }\n      if (isNaN(x)) {\n        throw new Error(\n          `Something went wrong with the justified layout calculation. x is NaN.`\n        );\n      }\n      const newWord: Bounds = setBoundsX(x)(bounds);\n      previousWord = newWord;\n      result[i] = newWord;\n    }\n    return result;\n  };\n\nexport const alignLines = (\n  align: Align,\n  maxWidth: number,\n  lines: ParagraphToken\n): ParagraphToken => {\n  // do horizontal alignment.\n  let alignFunction: (l: Bounds[]) => Bounds[];\n  switch (align) {\n    case \"left\":\n      alignFunction = alignLeft;\n      break;\n    case \"right\":\n      alignFunction = alignRight(maxWidth);\n      break;\n    case \"center\":\n      alignFunction = alignCenter(maxWidth);\n      break;\n    case \"justify\":\n      alignFunction = alignJustify(maxWidth);\n      break;\n    default:\n      throw new Error(\n        `Unsupported alignment type ${align}! Use one of : \"left\", \"right\", \"center\", \"justify\"`\n      );\n  }\n\n  for (const line of lines) {\n    const wordBoundsForLine: Bounds[] = [];\n    for (const word of line) {\n      const wordBounds = getBoundsNested(word);\n      wordBoundsForLine.push(wordBounds);\n      if (isNaN(wordBounds.x)) {\n        throw new Error(\"wordBounds not correct\");\n      }\n    }\n    const alignedLine = alignFunction(wordBoundsForLine);\n    for (let i = 0; i < line.length; i++) {\n      const bounds = alignedLine[i];\n      const word = line[i];\n      line[i] = positionWordX(bounds.x)(word);\n    }\n  }\n  return lines;\n};\n\nconst getTallestToken = (line: LineToken): FinalToken =>\n  flatReduce<FinalToken, FinalToken>((tallest, current) => {\n    let h = current.bounds.height ?? 0;\n    if (isSpriteToken(current)) {\n      h += current.fontProperties.descent;\n    }\n    if (h > (tallest?.bounds.height ?? 0)) {\n      return current;\n    }\n    return tallest;\n  }, createEmptyFinalToken())(line);\n\n/**\n * @param If you want to override the valign from the styles object, set it here.\n */\nexport const verticalAlignInLines = (\n  lines: ParagraphToken,\n  lineSpacing: number,\n  overrideValign?: VAlign\n): ParagraphToken => {\n  let previousTallestToken: FinalToken = createEmptyFinalToken();\n\n  let previousLineBottom = 0;\n  const newLines: ParagraphToken = [];\n\n  for (const line of lines) {\n    const newLine: LineToken = [];\n    // const nonZeroWidthWords: Bounds[] = line.filter(({ width }) => width > 0);\n\n    let tallestToken: FinalToken = getTallestToken(line);\n    let tallestHeight = tallestToken.bounds?.height ?? 0;\n    let tallestAscent = tallestToken.fontProperties?.ascent ?? 0;\n    if (isSpriteToken(tallestToken)) {\n      tallestHeight += tallestToken.fontProperties.descent;\n      tallestAscent = tallestToken.bounds.height;\n    }\n\n    // const previousTallestHeight = previousTallestToken.bounds.height;\n\n    // if (line.length === 1 && isWhitespaceToken(line[0])) {\n    //   tallestHeight = previousTallestHeight;\n    // }\n\n    if (tallestHeight === 0) {\n      tallestToken = previousTallestToken;\n    } else {\n      previousTallestToken = tallestToken;\n    }\n\n    for (const word of line) {\n      const newWord: WordToken = [];\n      for (const segment of word) {\n        if (isNewlineToken(segment)) {\n          const newToken = {\n            ...segment,\n          };\n          newWord.push(newToken);\n          continue;\n        }\n        const { bounds, fontProperties, style } = segment;\n        const height = bounds.height;\n\n        const newBounds: Bounds = { ...bounds };\n        const valign = overrideValign ?? style.valign;\n\n        let { ascent } = fontProperties;\n        if (isSpriteToken(segment)) {\n          ascent = segment.bounds.height;\n        }\n\n        let newY = 0;\n        switch (valign) {\n          case \"bottom\":\n            newY = previousLineBottom + tallestHeight - height;\n            break;\n          case \"middle\":\n            newY = previousLineBottom + (tallestHeight - height) / 2;\n            break;\n          case \"top\":\n            newY = previousLineBottom;\n            break;\n          case \"baseline\":\n          default:\n            newY = previousLineBottom + tallestAscent - ascent;\n        }\n\n        newBounds.y = newY;\n\n        const newToken = {\n          ...segment,\n          bounds: newBounds,\n        };\n        newWord.push(newToken);\n      }\n      newLine.push(newWord);\n    }\n\n    previousLineBottom += tallestHeight + lineSpacing;\n    newLines.push(newLine);\n  }\n\n  return newLines;\n\n  // ? lines.map(valignTop)\n  //   : valign === \"middle\"\n  //   ? lines.map(valignMiddle)\n  //   : valign === \"bottom\"\n  //   ? lines.map(valignBottom)\n  //   : lines;\n};\n\nexport const collapseWhitespacesOnEndOfLines = (\n  lines: ParagraphToken\n): ParagraphToken => {\n  for (const line of lines) {\n    const l = line.length;\n    let i = l;\n    while (i >= 0) {\n      i -= 1;\n      const word = line[i];\n      if (isNotWhitespaceToken(word)) {\n        break;\n      } else {\n        for (const token of word) {\n          token.bounds.width = 0;\n          token.bounds.height = Math.min(\n            token.bounds.height,\n            token.fontProperties.fontSize\n          );\n        }\n      }\n    }\n  }\n  return lines;\n};\n\nconst layout = (\n  tokens: FinalToken[],\n  maxWidth: number,\n  lineSpacing: number,\n  align: Align\n): ParagraphToken => {\n  const cursor = { x: 0, y: 0 };\n  let wordWidth = 0;\n  let word: WordToken = [];\n  let line: LineToken = [];\n  const allLines: ParagraphToken = [];\n  let tallestHeightInLine = 0;\n\n  function addWordBufferToLineBuffer() {\n    if (word !== undefined && word.length > 0) {\n      // add word to line\n      line.push(word);\n    }\n\n    // reset word buffer\n    word = [];\n    wordWidth = 0;\n  }\n\n  function addLineToListOfLines() {\n    allLines.push(line);\n    line = [];\n  }\n\n  function addLineToListOfLinesAndMoveCursorToNextLine(token: FinalToken) {\n    // finalize Line\n    addLineToListOfLines();\n\n    // move cursor to next line\n    cursor.x = 0;\n    cursor.y = cursor.y + tallestHeightInLine;\n\n    // reset tallestHeight\n    tallestHeightInLine = 0;\n    setTallestHeight(token);\n  }\n\n  function setTallestHeight(token?: FinalToken): void {\n    const fontSize = token?.fontProperties?.fontSize ?? 0;\n    const height = token?.bounds?.height ?? 0;\n\n    tallestHeightInLine = Math.max(tallestHeightInLine, fontSize, lineSpacing);\n    // Don't try to measure the height of newline tokens\n    if (isNewlineToken(token) === false) {\n      tallestHeightInLine = Math.max(tallestHeightInLine, height);\n    }\n  }\n\n  function positionTokenAtCursorAndAdvanceCursor(token: FinalToken): void {\n    // position token at cursor\n    setTallestHeight(token);\n    token.bounds.x = cursor.x;\n    token.bounds.y = cursor.y;\n    // advance cursor\n    cursor.x += token.bounds.width;\n  }\n\n  function positionWordBufferAtCursorAndAdvanceCursor(): void {\n    word.forEach(positionTokenAtCursorAndAdvanceCursor);\n  }\n\n  function wordInBufferExceedsLineLength(): boolean {\n    return cursor.x + wordWidth > maxWidth;\n  }\n\n  function isBlockImage(token: FinalToken): boolean {\n    return token.style[IMG_DISPLAY_PROPERTY] === \"block\";\n  }\n\n  function addTokenToWordAndUpdateWordWidth(token: FinalToken): void {\n    // add the token to the current word buffer.\n    word.push(token);\n    wordWidth += token.bounds.width;\n  }\n\n  let token;\n  for (let i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n    const isWhitespace = isWhitespaceToken(token);\n    const isNewline = isNewlineToken(token);\n    const isImage = isSpriteToken(token);\n    const isWordEndingToken = isWhitespace || isImage;\n\n    if (isWordEndingToken) {\n      positionWordBufferAtCursorAndAdvanceCursor();\n      addWordBufferToLineBuffer();\n    }\n\n    addTokenToWordAndUpdateWordWidth(token);\n    setTallestHeight(token);\n\n    // always immediately add whitespace to the line.\n    if (isWhitespace) {\n      positionWordBufferAtCursorAndAdvanceCursor();\n      addWordBufferToLineBuffer();\n    }\n\n    // If the token is a newline character,\n    // move the cursor to next line immediately\n    if (isNewline || isBlockImage(token)) {\n      addLineToListOfLinesAndMoveCursorToNextLine(token);\n    } else if (wordInBufferExceedsLineLength()) {\n      // don't wrap if it's the first word in the line.\n      if (line.length > 0) {\n        addLineToListOfLinesAndMoveCursorToNextLine(token);\n      }\n    }\n  }\n\n  // After we reach the last token, add it to the word and finalize both buffers.\n  if (word.length > 0) {\n    positionWordBufferAtCursorAndAdvanceCursor();\n    addWordBufferToLineBuffer();\n  }\n  if (line.length > 0) {\n    addLineToListOfLines();\n  }\n\n  const collapsedWhitespace = collapseWhitespacesOnEndOfLines(allLines);\n  const alignedLines = alignLines(align, maxWidth, collapsedWhitespace);\n  const valignedLines = verticalAlignInLines(alignedLines, lineSpacing);\n\n  return valignedLines;\n};\n\nconst notEmptyString = (s: string) => s !== \"\";\n\nconst SPLIT_MARKER = `_🔪_`;\nexport const splitAroundWhitespace = (s: string): string[] =>\n  s\n    .replace(/\\s/g, `${SPLIT_MARKER}$&${SPLIT_MARKER}`)\n    .split(SPLIT_MARKER)\n    .filter((s) => s !== \"\");\n\nexport const splitText = (s: string, splitStyle: SplitStyle): string[] => {\n  if (splitStyle === \"words\") {\n    return [s].flatMap(splitAroundWhitespace).filter(notEmptyString);\n  } else if (splitStyle === \"characters\") {\n    return s.split(\"\");\n  } else {\n    // unsupported splitStyle.\n    let suggestion = ` Supported styles are \"words\" and \"characters\"`;\n    const badStyle = (splitStyle as string).toLowerCase();\n    if (badStyle.indexOf(\"char\") === 0) {\n      suggestion = `Did you mean \"characters\"?`;\n    } else if (badStyle.indexOf(\"wor\") === 0) {\n      suggestion = `Did you mean \"words\"?`;\n    }\n    throw new Error(`Unsupported split style \"${splitStyle}\". ${suggestion}`);\n  }\n};\n\nexport const calculateFinalTokens = (\n  styledTokens: StyledTokens,\n  splitStyle: SplitStyle = \"words\"\n): ParagraphToken => {\n  // Create a text field to use for measurements.\n  const sizer = new PixiText(\"\");\n  const defaultStyle = styledTokens.style;\n\n  let fontProperties: IFontMetrics;\n\n  const generateFinalTokenFromStyledToken =\n    (style: TextStyleExtended, tags: string) =>\n    (token: StyledToken | TextToken | SpriteToken): FinalToken[] => {\n      let output: FinalToken[] = [];\n\n      sizer.style = {\n        ...style,\n        // Override some styles for the purposes of sizing text.\n        wordWrap: false,\n        dropShadowBlur: 0,\n        dropShadowDistance: 0,\n        dropShadowAngle: 0,\n        dropShadow: false,\n      };\n\n      if (typeof token === \"string\") {\n        // split into pieces and convert into tokens.\n\n        const textSegments = splitText(token, splitStyle);\n\n        const textTokens = textSegments.map((str): FinalToken => {\n          switch (style.textTransform) {\n            case \"uppercase\":\n              sizer.text = str.toUpperCase();\n              break;\n            case \"lowercase\":\n              sizer.text = str.toLowerCase();\n              break;\n            case \"capitalize\":\n              sizer.text = capitalize(str);\n              break;\n            default:\n              sizer.text = str;\n          }\n\n          const sw = style.fontScaleWidth ?? 1.0;\n          const sh = style.fontScaleHeight ?? 1.0;\n          // clamp negative or NaN fontScales to 0\n          const scaleWidth = isNaN(sw) || sw < 0 ? 0.0 : sw;\n          const scaleHeight = isNaN(sh) || sh < 0 ? 0.0 : sh;\n\n          sizer.scale.set(scaleWidth, scaleHeight);\n\n          fontProperties = { ...getFontPropertiesOfText(sizer, true) };\n          fontProperties.ascent *= scaleHeight;\n          fontProperties.descent *= scaleHeight;\n          fontProperties.fontSize *= scaleHeight;\n\n          const bounds = rectFromContainer(sizer);\n\n          // Incorporate the size of the stroke into the size of the text.\n          const stroke = sizer.style.strokeThickness ?? 0;\n          if (stroke > 0) {\n            fontProperties.descent += stroke / 2;\n            fontProperties.ascent += stroke / 2;\n            fontProperties.fontSize =\n              fontProperties.ascent + fontProperties.descent;\n          }\n\n          const textDecorations = extractDecorations(\n            style,\n            bounds,\n            fontProperties\n          );\n\n          return {\n            content: str,\n            style,\n            tags,\n            bounds,\n            fontProperties,\n            textDecorations,\n          };\n        });\n\n        output = output.concat(textTokens);\n      } else if (token instanceof Sprite) {\n        const sprite = token;\n        const imgDisplay = style[IMG_DISPLAY_PROPERTY];\n        // const isBlockImage = imgDisplay === \"block\";\n        const isIcon = imgDisplay === \"icon\";\n        fontProperties = { ...getFontPropertiesOfText(sizer, true) };\n\n        if (isIcon) {\n          // Set to minimum of 1 to avoid devide by zero.\n          // if it's height is zero or one it probably hasn't loaded yet.\n          // It will get refreshed after it loads.\n          const h = Math.max(sprite.height, 1);\n\n          if (h > 1 && sprite.scale.y === 1) {\n            const ratio = (fontProperties.ascent / h) * ICON_SCALE_BASE;\n            sprite.scale.set(ratio);\n          }\n        }\n\n        // handle images\n        const bounds = rectFromContainer(sprite);\n        output.push({\n          content: sprite,\n          style,\n          tags,\n          bounds,\n          fontProperties,\n          textDecorations: undefined,\n        });\n      } else {\n        // token is a composite\n        const styledToken = token as StyledToken;\n        const { children } = styledToken;\n        // set tags and styles for children of this composite token.\n        const newStyle = styledToken.style;\n        const newTags = styledToken.tags;\n\n        if (newStyle === undefined) {\n          throw new Error(\n            `Expected to find a 'style' property on ${styledToken}`\n          );\n        }\n\n        output = output.concat(\n          children.flatMap(generateFinalTokenFromStyledToken(newStyle, newTags))\n        );\n      }\n      return output;\n    };\n\n  // when starting out, use the default style\n  const tags = \"\";\n  const style: TextStyleExtended = defaultStyle;\n\n  const finalTokens = styledTokens.children.flatMap(\n    generateFinalTokenFromStyledToken(style, tags)\n  );\n\n  const { wordWrap: ww, wordWrapWidth: www } = defaultStyle;\n  const hasWordWrapWidth =\n    www !== undefined && !isNaN(www as number) && (www as number) > 0;\n  const maxWidth =\n    ww && hasWordWrapWidth ? (www as number) : Number.POSITIVE_INFINITY;\n\n  const lineSpacing = defaultStyle.lineSpacing ?? 0;\n  const align = defaultStyle.align ?? \"left\";\n\n  return layout(finalTokens, maxWidth, lineSpacing, align);\n};\n","import { BaseTexture, Texture } from \"@pixi/core\";\nimport { Sprite } from \"@pixi/sprite\";\nimport { Text } from \"@pixi/text\";\nimport { Container, DisplayObject } from \"@pixi/display\";\nimport { Graphics } from \"@pixi/graphics\";\nimport \"@pixi/events\";\n\nimport { parseTagsNew, removeTags, EMOJI_TAG } from \"./tags\";\nimport {\n  TaggedTextOptions,\n  TextStyleSet,\n  TextStyleExtended,\n  TagWithAttributes,\n  AttributesList,\n  ImageMap,\n  ImageSourceMap,\n  IMG_REFERENCE_PROPERTY,\n  FinalToken,\n  isSpriteToken,\n  TextFinalToken,\n  isTextToken,\n  isNotWhitespaceToken,\n  isNewlineToken,\n  isWhitespaceToken,\n  Point,\n  ParagraphToken,\n  TextDecorationMetrics,\n  isSpriteSource,\n  isTextureSource,\n} from \"./types\";\nimport { capitalize } from \"./stringUtil\";\nimport { calculateFinalTokens, getBoundsNested } from \"./layout\";\nimport {\n  combineAllStyles,\n  DEFAULT_STYLE,\n  getStyleForTag as getStyleForTagExt,\n  mapTagsToStyles,\n} from \"./style\";\nimport { fontSizeStringToNumber } from \"./pixiUtils\";\n\nexport const DEFAULT_OPTIONS: TaggedTextOptions = {\n  debug: false,\n  debugConsole: false,\n  splitStyle: \"words\",\n  imgMap: {},\n  skipUpdates: false,\n  skipDraw: false,\n  drawWhitespace: false,\n  wrapEmoji: true,\n};\n\n// TODO: make customizable\nconst DEBUG = {\n  WORD_STROKE_COLOR: 0xffcccc, // #FCC\n  WORD_FILL_COLOR: 0xeeeeee, // #EEE\n  TEXT_FIELD_STROKE_COLOR: 0xff00ff, // #F0F\n  WHITESPACE_COLOR: 0xcccccc, // #CCC\n  WHITESPACE_STROKE_COLOR: 0xaaaaaa, // #AAA\n  BASELINE_COLOR: 0xffff99, // #FF9\n  LINE_COLOR: 0xffff00, // #FF0\n  OUTLINE_COLOR: 0xffcccc, // #FCC\n  OUTLINE_SHADOW_COLOR: 0x000000, // #000\n  TEXT_STYLE: {\n    fontFamily: \"courier\",\n    fontSize: 10,\n    fill: 0xffffff, // #FFF\n    dropShadow: true,\n  },\n};\nconst DEFAULT_STYLE_SET = { default: DEFAULT_STYLE };\n\nObject.freeze(DEFAULT_STYLE_SET);\nObject.freeze(DEFAULT_STYLE);\nexport default class TaggedText extends Sprite {\n  public static get defaultStyles(): TextStyleSet {\n    return DEFAULT_STYLE_SET;\n  }\n  public static get defaultOptions(): TaggedTextOptions {\n    return DEFAULT_OPTIONS;\n  }\n\n  // todo: allow setting options after the constructor is called. Make sure to call update()\n  /** Settings for the TaggedText component. */\n  private _options: TaggedTextOptions;\n  public get options(): TaggedTextOptions {\n    return this._options;\n  }\n\n  private _needsUpdate = true;\n  public get needsUpdate(): boolean {\n    return this._needsUpdate;\n  }\n  private _needsDraw = true;\n  public get needsDraw(): boolean {\n    return this._needsDraw;\n  }\n\n  private _tokens: ParagraphToken = [];\n  public get tokensFlat(): FinalToken[] {\n    return this._tokens.flat(3);\n  }\n  /**\n   * Tokens representing parsed out and styled tagged text. This is generated by update.\n   * They contain all the information needed to render the text fields and other children in your component.\n   */\n  public get tokens(): ParagraphToken {\n    return this._tokens;\n  }\n\n  private _text = \"\";\n  public get text(): string {\n    return this._text;\n  }\n\n  /**\n   * Alternative implicit setter for text. Always uses default for skipUpdate.\n   */\n  public set text(text: string) {\n    this.setText(text);\n  }\n\n  /**\n   * Setter for text that allows you to override the default for skipping the update.\n   * @param text Text to add to component with (optional) tags.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the text.\n   * When true, setText() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public setText(text: string, skipUpdate?: boolean): void {\n    if (text === this._text && this._needsUpdate === false) {\n      return;\n    }\n    this._text = text;\n    this._needsUpdate = true;\n    this.updateIfShould(skipUpdate);\n  }\n\n  /**\n   * Returns the text content with all tags stripped out.\n   */\n  public get untaggedText(): string {\n    return removeTags(this.text);\n  }\n\n  private _tagStyles: TextStyleSet = {};\n  public get tagStyles(): TextStyleSet {\n    return this._tagStyles;\n  }\n\n  /**\n   * Alternative implicit setter for tagStyles. Always uses default for skipUpdate.\n   */\n  public set tagStyles(styles: TextStyleSet) {\n    this.setTagStyles(styles);\n  }\n\n  /**\n   * Setter for tagStyles.\n   * @param styles Object with strings for keys representing tag names, mapped to style objects.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\n   * When true, setTagStyles() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public setTagStyles(styles: TextStyleSet, skipUpdate?: boolean): void {\n    Object.entries(styles).forEach(([tag, style]) =>\n      this.setStyleForTag(tag, style, true)\n    );\n    // TODO: add a way to test for identical styles to prevent unnecessary updates.\n    this._needsUpdate = true;\n    this.updateIfShould(skipUpdate);\n  }\n\n  public getStyleForTag(\n    tag: string,\n    attributes: AttributesList = {}\n  ): TextStyleExtended | undefined {\n    return getStyleForTagExt(tag, this.tagStyles, attributes);\n  }\n\n  public getStyleForTags(tags: TagWithAttributes[]): TextStyleExtended {\n    const styles = tags.map(({ tagName, attributes }) =>\n      this.getStyleForTag(tagName, attributes)\n    );\n    return combineAllStyles(styles);\n  }\n\n  /**\n   * Set a style to be used by a single tag.\n   * @param tag Name of the tag to set style for\n   * @param styles Style object to assign to the tag.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\n   * When true, setStyleForTag() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public setStyleForTag(\n    tag: string,\n    styles: TextStyleExtended,\n    skipUpdate?: boolean\n  ): boolean {\n    this.tagStyles[tag] = styles;\n\n    // TODO: warn user when trying to set styles on a tag that doesn't support it...\n    // e.g. wordWrapWidth on a styel other than default.\n\n    // Override some settings on default styles.\n    if (tag === \"default\" && this.defaultStyle[IMG_REFERENCE_PROPERTY]) {\n      // prevents accidentally setting all text to images.\n      console.error(\n        `Style \"${IMG_REFERENCE_PROPERTY}\" can not be set on the \"default\" style because it will add images to EVERY tag!`\n      );\n      this.defaultStyle[IMG_REFERENCE_PROPERTY] = undefined;\n    }\n    // TODO: add a way to test for identical styles to prevent unnecessary updates.\n    this._needsUpdate = true;\n    this.updateIfShould(skipUpdate);\n\n    return true;\n  }\n  /**\n   * Removes a style associated with a tag. Note, inline attributes are not affected.\n   * @param tag Name of the tag to delete the style of.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\n   * When true, removeStylesForTag() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public removeStylesForTag(tag: string, skipUpdate?: boolean): boolean {\n    if (tag in this.tagStyles) {\n      delete this.tagStyles[tag];\n\n      this._needsUpdate = true;\n      this.updateIfShould(skipUpdate);\n\n      return true;\n    }\n    return false;\n  }\n\n  public get defaultStyle(): TextStyleExtended {\n    return this.tagStyles?.default;\n  }\n  /**\n   * Alternative implicit setter for defaultStyle. Always uses default for skipUpdate.\n   */\n  public set defaultStyle(defaultStyles: TextStyleExtended) {\n    this.setDefaultStyle(defaultStyles);\n  }\n  /**\n   * Setter for default styles. A shortcut to this.setStyleForTag(\"default\",...)\n   * @param styles A style object to use as the default styles for all text in the component.\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\n   * When true, setDefaultStyle() never updates even if default is false, and vice versa.\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public setDefaultStyle(\n    defaultStyles: TextStyleExtended,\n    skipUpdate?: boolean\n  ): void {\n    this.setStyleForTag(\"default\", defaultStyles, skipUpdate);\n  }\n\n  // References to internal elements.\n  private _textFields: Text[] = [];\n  public get textFields(): Text[] {\n    return this._textFields;\n  }\n  private _sprites: Sprite[] = [];\n  public get sprites(): Sprite[] {\n    return this._sprites;\n  }\n  private _decorations: Graphics[] = [];\n  public get decorations(): Graphics[] {\n    return this._decorations;\n  }\n  private _spriteTemplates: ImageMap = {};\n  public get spriteTemplates(): ImageMap {\n    return this._spriteTemplates;\n  }\n  private _debugGraphics: Graphics | null = null;\n\n  // Containers for children\n  private _textContainer: Container;\n  public get textContainer(): Container {\n    return this._textContainer;\n  }\n\n  private _decorationContainer: Container;\n  public get decorationContainer(): Container {\n    return this._decorationContainer;\n  }\n\n  private _spriteContainer: Container;\n  public get spriteContainer(): Container {\n    return this._spriteContainer;\n  }\n  private _debugContainer: Container;\n  public get debugContainer(): Container {\n    return this._debugContainer;\n  }\n\n  constructor(\n    text = \"\",\n    tagStyles: TextStyleSet = {},\n    options: TaggedTextOptions = {},\n    texture?: Texture\n  ) {\n    super(texture);\n\n    this._textContainer = new Container();\n    this._spriteContainer = new Container();\n    this._decorationContainer = new Container();\n    this._debugContainer = new Container();\n\n    this.addChild(this._textContainer);\n    this.addChild(this._spriteContainer);\n    this.addChild(this._decorationContainer);\n    this.addChild(this._debugContainer);\n\n    this.resetChildren();\n\n    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n    this._options = mergedOptions;\n\n    tagStyles = { default: {}, ...tagStyles };\n\n    if (this.options.wrapEmoji) {\n      tagStyles[EMOJI_TAG] = { fontFamily: \"sans-serif\" };\n    }\n    const mergedDefaultStyles = { ...DEFAULT_STYLE, ...tagStyles.default };\n    tagStyles.default = mergedDefaultStyles;\n    this.tagStyles = tagStyles;\n\n    if (this.options.imgMap) {\n      this.createSpriteTemplatesFromSourceMap(this.options.imgMap);\n    }\n\n    this.text = text;\n  }\n\n  /**\n   * Removes all PIXI children from this component's containers.\n   * Deletes references to sprites and text fields.\n   */\n  private resetChildren() {\n    this._debugContainer.removeChildren();\n    this._textContainer.removeChildren();\n    this._spriteContainer.removeChildren();\n    this._decorationContainer.removeChildren();\n\n    this._textFields = [];\n    this._sprites = [];\n    this._decorations = [];\n  }\n\n  /**\n   * Creates associations between string-based keys like \"img\" and\n   * image Sprite objects which are included in the text.\n   * @param imgMap\n   */\n  private createSpriteTemplatesFromSourceMap(imgMap: ImageSourceMap) {\n    this._spriteTemplates = {};\n\n    Object.entries(imgMap).forEach(([key, spriteSource]) => {\n      let sprite: Sprite;\n      if (spriteSource instanceof Sprite) {\n        sprite = spriteSource;\n      } else {\n        // if the entry is not a sprite, attempt to load the sprite as if it is a reference to the sprite source (e.g. an Image element, url, or texture).\n        if (isSpriteSource(spriteSource)) {\n          sprite = Sprite.from(spriteSource);\n        } else if (isTextureSource(spriteSource)) {\n          sprite = Sprite.from(Texture.from(spriteSource));\n        } else {\n          throw new TypeError(\n            `The spriteSource provided for key ${key} was not in a valid format. Please use a Sprite, Texture, BaseTexture, string, HTMLImageElement, HTMLVideoElement, HTMLCanvasElement, or SVGElement`\n          );\n        }\n      }\n      // Listen for changes to sprites (e.g. when they load.)\n      const texture = sprite.texture;\n      if (texture !== undefined) {\n        texture.baseTexture.addListener(\"update\", (baseTexture: BaseTexture) =>\n          this.onImageTextureUpdate(baseTexture)\n        );\n      }\n\n      this.spriteTemplates[key] = sprite;\n\n      // create a style for each of these by default.\n      const existingStyle = this.getStyleForTag(key) ?? {};\n      const style = { [IMG_REFERENCE_PROPERTY]: key, ...existingStyle };\n      this.setStyleForTag(key, style);\n    });\n  }\n\n  private onImageTextureUpdate(baseTexture: BaseTexture): void {\n    baseTexture;\n    this._needsUpdate = true;\n    this._needsDraw = true;\n    // const didUpdate = this.updateIfShould();\n    this.updateIfShould();\n\n    // this.dispactchEvent(new Event(\"imageUpdate\", texture));\n  }\n\n  /**\n   * Determines whether to call update based on the parameter and the options set then calls it or sets needsUpdate to true.\n   * @param forcedSkipUpdate This is the parameter provided to some functions that allow you to skip the update.\n   * It's factored in along with the defaults to figure out what to do.\n   */\n  private updateIfShould(forcedSkipUpdate?: boolean): boolean {\n    if (\n      forcedSkipUpdate === false ||\n      (forcedSkipUpdate === undefined && this.options.skipUpdates === false)\n    ) {\n      this.update();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Calculates styles, positioning, etc. of the text and styles and creates a\n   * set of objects that represent where each portion of text and image should\n   * be drawn.\n   * @param skipDraw *For advanced users* overrides default for redrawing the styles.\n   * When true, update() will skip the call to draw() (even if the default is false).\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\n   * is provided in this.options.\n   */\n  public update(skipDraw?: boolean): ParagraphToken {\n    // Determine default style properties\n    const tagStyles = this.tagStyles;\n    const { splitStyle } = this.options;\n    const spriteTemplates = this.options.imgMap && this.spriteTemplates;\n    // const wordWrapWidth = this.defaultStyle.wordWrap\n    //   ? this.defaultStyle.wordWrapWidth\n    //   : Number.POSITIVE_INFINITY;\n    // const align = this.defaultStyle.align;\n    // const lineSpacing = this.defaultStyle.lineSpacing;\n\n    // Pre-process text.\n    // Parse tags in the text.\n    const tagTokensNew = parseTagsNew(\n      this.text,\n      Object.keys(this.tagStyles),\n      this.options.wrapEmoji\n    );\n    // Assign styles to each segment.\n    const styledTokens = mapTagsToStyles(\n      tagTokensNew,\n      tagStyles,\n      spriteTemplates\n    );\n    styledTokens;\n    // Measure font for each style\n    // Measure each segment\n    // Create the text segments, position and add them. (draw)\n    const newFinalTokens = calculateFinalTokens(styledTokens, splitStyle);\n\n    this._tokens = newFinalTokens;\n    this._needsDraw = true;\n\n    // Wait one frame to draw so that this doesn't happen multiple times in one frame.\n    // if (this.animationRequest) {\n    //   window.cancelAnimationFrame(this.animationRequest);\n    // }\n    // this.animationRequest = window.requestAnimationFrame(\n\n    this.drawIfShould(skipDraw);\n\n    if (this.options.debugConsole) {\n      console.log(this.toDebugString());\n    }\n\n    this._needsUpdate = false;\n\n    return newFinalTokens;\n  }\n\n  /**\n   * Determines whether to call draw() based on the parameter and the options set then calls it or sets needsDraw to true.\n   * @param forcedSkipDraw This is the parameter provided to some functions that allow you to skip the update.\n   * It's factored in along with the defaults to figure out what to do.\n   */\n  private drawIfShould(forcedSkipDraw?: boolean): boolean {\n    if (\n      forcedSkipDraw === false ||\n      (forcedSkipDraw === undefined && this.options.skipDraw === false)\n    ) {\n      this.draw();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Create and position the display objects based on the tokens.\n   */\n  public draw(): void {\n    this.resetChildren();\n    const { drawWhitespace } = this.options;\n    const tokens = drawWhitespace\n      ? this.tokensFlat\n      : // remove any tokens that are purely whitespace unless drawWhitespace is specified\n        this.tokensFlat.filter(isNotWhitespaceToken);\n\n    let drewDecorations = false;\n    let displayObject: DisplayObject;\n\n    tokens.forEach((t) => {\n      if (isTextToken(t)) {\n        displayObject = this.createTextFieldForToken(t as TextFinalToken);\n        this.textContainer.addChild(displayObject);\n        this.textFields.push(displayObject as Text);\n\n        if (t.textDecorations && t.textDecorations.length > 0) {\n          for (const d of t.textDecorations) {\n            const drawing = this.createDrawingForTextDecoration(d);\n            (displayObject as Text).addChild(drawing);\n            this._decorations.push(drawing);\n          }\n          drewDecorations = true;\n        }\n      }\n      if (isSpriteToken(t)) {\n        displayObject = t.content as Sprite;\n        this.sprites.push(displayObject as Sprite);\n        this.spriteContainer.addChild(displayObject);\n      }\n\n      const { bounds } = t;\n      displayObject.x = bounds.x;\n      displayObject.y = bounds.y;\n    });\n\n    if (drawWhitespace === false && drewDecorations) {\n      console.warn(\n        \"Warning: you may want to set the `drawWhitespace` option to `true` when using textDecoration (e.g. underlines) otherwise, spaces will not have text decorations.\"\n      );\n    }\n\n    if (this.options.debug) {\n      this.drawDebug();\n    }\n    this._needsDraw = false;\n  }\n\n  private createDrawingForTextDecoration(\n    textDecoration: TextDecorationMetrics\n  ): Graphics {\n    const { bounds } = textDecoration;\n    let { color } = textDecoration;\n    const drawing = new Graphics();\n\n    if (typeof color === \"string\") {\n      if (color.indexOf(\"#\") === 0) {\n        color = \"0x\" + color.substring(1);\n        color = parseInt(color, 16) as number;\n      } else {\n        throw new Error(\n          \"Sorry, at this point, only hex colors are supported for textDecorations like underlines. Please use either a hex number like 0x66FF33 or a string like '#66FF33'\"\n        );\n      }\n    }\n\n    drawing\n      .beginFill(color as number)\n      .drawRect(bounds.x, bounds.y, bounds.width, bounds.height)\n      .endFill();\n\n    return drawing;\n  }\n\n  private createTextFieldForToken(token: TextFinalToken): Text {\n    const { textTransform = \"\" } = token.style;\n\n    let text = token.content;\n    switch (textTransform.toLowerCase()) {\n      case \"lowercase\":\n        text = text.toLowerCase();\n        break;\n      case \"uppercase\":\n        text = text.toUpperCase();\n        break;\n      case \"capitalize\":\n        text = capitalize(text);\n        break;\n      default:\n    }\n\n    const textField = new Text(text, token.style);\n\n    let { fontScaleWidth = 1.0, fontScaleHeight = 1.0 } = token.style;\n    fontScaleWidth =\n      isNaN(fontScaleWidth) || fontScaleWidth < 0 ? 0 : fontScaleWidth;\n    fontScaleHeight =\n      isNaN(fontScaleHeight) || fontScaleHeight < 0 ? 0 : fontScaleHeight;\n\n    let finalScaleWidth = fontScaleWidth;\n    let finalScaleHeight = fontScaleHeight;\n    const largerScale = Math.max(fontScaleWidth, fontScaleHeight);\n\n    if (largerScale > 1) {\n      if (largerScale === fontScaleHeight) {\n        finalScaleWidth /= largerScale;\n        finalScaleHeight = 1.0;\n      } else {\n        finalScaleHeight /= largerScale;\n        finalScaleWidth = 1.0;\n      }\n\n      const fs = textField.style.fontSize ?? 0;\n      const fontSizePx =\n        (typeof fs === \"string\" ? fontSizeStringToNumber(fs) : fs) *\n        largerScale;\n\n      textField.style.fontSize = fontSizePx;\n    }\n\n    textField.scale.set(finalScaleWidth, finalScaleHeight);\n    return textField;\n  }\n\n  /**\n   * Converts the text properties from this.tokens into a human readable string.\n   * This is automatically logged to the console on update when debug option is set to true.\n   */\n  public toDebugString(): string {\n    const lines = this.tokens;\n    let s = this.untaggedText + \"\\n=====\\n\";\n    const nl = \"\\n    \";\n    if (lines !== undefined) {\n      s += lines.map((line, lineNumber) =>\n        line.map((word, wordNumber) =>\n          word\n            .map((token, tokenNumber) => {\n              let text = \"\";\n              if (isTextToken(token)) {\n                if (isNewlineToken(token)) {\n                  text = `\\\\n`;\n                } else {\n                  text = `\"${token.content}\"`;\n                }\n              } else if (isSpriteToken(token)) {\n                text = `[Image]`;\n              }\n              let s = `\\n${text}: (${lineNumber}/${wordNumber}/${tokenNumber})`;\n              s += `${nl}tags: ${\n                token.tags.length === 0\n                  ? \"<none>\"\n                  : token.tags\n                      .split(\",\")\n                      .map((tag) => `<${tag}>`)\n                      .join(\", \")\n              }`;\n              s += `${nl}style: ${Object.entries(token.style)\n                .map((e) => e.join(\":\"))\n                .join(\"; \")}`;\n              s += `${nl}size: x:${token.bounds.x} y:${token.bounds.y} width:${\n                token.bounds.width\n              } height:${token.bounds.height} bottom:${\n                token.bounds.height + token.bounds.y\n              } right:${token.bounds.x + token.bounds.width}`;\n              s += `${nl}font: fontSize:${token.fontProperties.fontSize} ascent:${token.fontProperties.ascent} descent:${token.fontProperties.descent}`;\n              return s;\n            })\n            .join(\"\\n\")\n        )\n      );\n    }\n    return s;\n  }\n\n  public drawDebug(): void {\n    const paragraph = this.tokens;\n    this._debugGraphics = new Graphics();\n    this.debugContainer.addChild(this._debugGraphics);\n\n    const g = this._debugGraphics;\n    g.clear();\n\n    // const { width, height } = this.getBounds();\n    // // frame shadow\n    // g.lineStyle(2, DEBUG.OUTLINE_SHADOW_COLOR, 0.5);\n    // // g.beginFill();\n    // g.drawRect(1, 1, width, height);\n    // // g.endFill();\n\n    // // frame\n    // g.lineStyle(2, DEBUG.OUTLINE_COLOR, 1);\n    // // g.beginFill();\n    // g.drawRect(0, 0, width - 1, height - 1);\n    // // g.endFill();\n\n    function createInfoText(text: string, position: Point): Text {\n      const info = new Text(text, DEBUG.TEXT_STYLE);\n      info.x = position.x + 1;\n      info.y = position.y + 1;\n      return info;\n    }\n\n    // for (const line of tokens) {\n    for (let lineNumber = 0; lineNumber < paragraph.length; lineNumber++) {\n      const line = paragraph[lineNumber];\n      const lineBounds = getBoundsNested(line);\n\n      if (this.defaultStyle.wordWrap) {\n        const w = this.defaultStyle.wordWrapWidth ?? this.width;\n        g.endFill()\n          .lineStyle(0.5, DEBUG.LINE_COLOR, 0.2)\n          .drawRect(0, lineBounds.y, w, lineBounds.height)\n          .endFill();\n      }\n\n      for (let wordNumber = 0; wordNumber < line.length; wordNumber++) {\n        const word = line[wordNumber];\n        for (const segmentToken of word) {\n          const isSprite = isSpriteToken(segmentToken);\n          const { x, y, width } = segmentToken.bounds;\n          const baseline =\n            y +\n            (isSprite\n              ? segmentToken.bounds.height\n              : segmentToken.fontProperties.ascent);\n\n          let { height } = segmentToken.bounds;\n          if (isSprite) {\n            height += segmentToken.fontProperties.descent;\n          }\n\n          if (\n            isWhitespaceToken(segmentToken) &&\n            this.options.drawWhitespace === false\n          ) {\n            g.lineStyle(1, DEBUG.WHITESPACE_STROKE_COLOR, 1).beginFill(\n              DEBUG.WHITESPACE_COLOR,\n              0.2\n            );\n          } else {\n            g.lineStyle(1, DEBUG.WORD_STROKE_COLOR, 1).beginFill(\n              DEBUG.WORD_FILL_COLOR,\n              0.2\n            );\n          }\n\n          if (isNewlineToken(segmentToken)) {\n            this.debugContainer.addChild(\n              createInfoText(\"↩︎\", { x, y: y + 10 })\n            );\n          } else {\n            g.lineStyle(0.5, DEBUG.LINE_COLOR, 0.2)\n              .drawRect(x, y, width, height)\n              .endFill()\n\n              .lineStyle(1, DEBUG.BASELINE_COLOR, 1)\n              .beginFill()\n              .drawRect(x, baseline, width, 1)\n              .endFill();\n          }\n\n          let info;\n          // info = `${token.bounds.width}⨉${token.bounds.height}`;\n          if (isTextToken(segmentToken)) {\n            // info += ` ${token.tags}`;\n            info = `${segmentToken.tags}`;\n            this.debugContainer.addChild(createInfoText(info, { x, y }));\n          }\n          // this.debugContainer.addChild(createInfoText(info, { x, y }));\n        }\n      }\n    }\n    // }\n\n    // Show the outlines of the actual text fields,\n    // not just where the tokens say they should be\n    // const fields: Text[] = this.textFields;\n    // for (const text of fields) {\n    //   g.lineStyle(1, DEBUG.TEXT_FIELD_STROKE_COLOR, 1);\n    //   g.drawRect(text.x, text.y, text.width, text.height);\n    // }\n  }\n}\n"],"names":["combineRecords","a","b","last","length","isDefined","undefined","flatReduce","f","acc","nested","flat","reduce","flatEvery","p","t","createEmptyFinalToken","content","bounds","PixiRectangle","fontProperties","ascent","descent","fontSize","style","tags","textDecorations","isWhitespace","s","split","every","char","search","isSpriteToken","Sprite","_isTextToken","isTextToken","isWhitespaceToken","_isNewlineToken","isNewlineToken","isNotWhitespaceToken","predicate","input","isEmptyObject","Object","keys","getTagRegex","tagNamesToMatch","matchingTagNames","join","captureGroup","noCaptureGroup","QUOTE","NOT_QUOTE","TAG_NAMES","ATTRIBUTE_VALUE","ATTRIBUTES","WHITESPACE","CHAR","RegExp","TAG_OPEN","parseAttributes","attributesString","trim","obj","attribute","attributePair","name","valueStr","substr","createTagMatchData","match","tag","openTagName","attributes","closeTagName","index","tagName","isOpening","selfClosingTagSearch","group","any","not","TAG_SLASH","tagMatchToTagToken","children","capitalize","str","chars","converted","i","charAt","toUpperCase","measureFont","context","TextMetrics","font","getFontPropertiesOfText","textField","forceUpdate","updateText","props","isNaN","Error","DEFAULT_STYLE","align","valign","imgDisplay","wordWrap","wordWrapWidth","lineSpacing","fill","combineStyles","combineAllStyles","styles","filter","getStyleForTag","tagStyles","convertedAttributes","key","value","parseFloat","convertAttributeValues","injectAttributes","rectFromContainer","container","offset","x","y","Rectangle","width","height","translateLine","line","map","point","translatePoint","lineWidth","wordsInLine","firstWord","lastWord","setBoundsX","object","positionWordX","word","prevBounds","token","concatBounds","originalBounds","NaN","Math","min","max","getBoundsNested","alignLeft","newLine","concat","getTallestToken","tallest","current","h","notEmptyString","splitAroundWhitespace","replace","DEFAULT_OPTIONS","debug","debugConsole","splitStyle","imgMap","skipUpdates","skipDraw","drawWhitespace","wrapEmoji","DEBUG","fontFamily","dropShadow","DEFAULT_STYLE_SET","default","freeze","TaggedText","defaultStyles","defaultOptions","options","_options","needsUpdate","_needsUpdate","needsDraw","_needsDraw","tokensFlat","_tokens","tokens","text","_text","this","setText","skipUpdate","updateIfShould","untaggedText","_tagStyles","setTagStyles","entries","forEach","setStyleForTag","getStyleForTagExt","getStyleForTags","defaultStyle","console","error","removeStylesForTag","_this$tagStyles","setDefaultStyle","textFields","_textFields","sprites","_sprites","decorations","_decorations","spriteTemplates","_spriteTemplates","textContainer","_textContainer","decorationContainer","_decorationContainer","spriteContainer","_spriteContainer","debugContainer","_debugContainer","constructor","texture","super","_debugGraphics","Container","addChild","resetChildren","mergedOptions","mergedDefaultStyles","createSpriteTemplatesFromSourceMap","removeChildren","spriteSource","sprite","Texture","HTMLCanvasElement","HTMLVideoElement","from","HTMLImageElement","BaseTexture","isTextureSource","TypeError","baseTexture","addListener","onImageTextureUpdate","imgSrc","forcedSkipUpdate","update","styledTokens","tagStack","styleCache","convertTagTokenToStyledToken","objects","push","o","tagHash","JSON","stringify","tagWithAttributesToStyle","stylesWithDefault","textDecoration","decorationColor","decorationThickness","defaultColor","defaultThickness","mergeDecoration","decorationLineType","decorationLineTypeCamelCase","_style$textDecoration","includes","convertDecorationToLineProps","styledToken","imgKey","cloneOfSprite","cloneSprite","pop","mapTagsToStyles","shouldWrapEmoji","getEmojiRegex","test","containsEmoji","emojiRegex","source","replaceAll","tagStart","_","output","replaceSelfClosingTags","re","tagMatches","exec","tagMatch","segments","tagMatchData","remaining","startOfTag","endOfTag","segment","extractSegments","rootTokens","tokenStack","poppedToken","warn","createTokensNew","parseTagsNew","newFinalTokens","sizer","PixiText","generateFinalTokenFromStyledToken","dropShadowBlur","dropShadowDistance","dropShadowAngle","textSegments","flatMap","suggestion","badStyle","toLowerCase","indexOf","splitText","textTokens","textTransform","sw","fontScaleWidth","sh","fontScaleHeight","scaleWidth","scaleHeight","scale","set","stroke","strokeThickness","textBounds","baseline","ascender","xHeight","color","extractDecorations","isIcon","newStyle","newTags","finalTokens","ww","www","hasWordWrapWidth","maxWidth","cursor","wordWidth","allLines","tallestHeightInLine","addWordBufferToLineBuffer","addLineToListOfLines","addLineToListOfLinesAndMoveCursorToNextLine","setTallestHeight","_token$fontProperties2","_token$bounds","positionTokenAtCursorAndAdvanceCursor","positionWordBufferAtCursorAndAdvanceCursor","isBlockImage","addTokenToWordAndUpdateWordWidth","isNewline","isImage","collapsedWhitespace","lines","collapseWhitespacesOnEndOfLines","valignedLines","overrideValign","previousTallestToken","previousLineBottom","newLines","tallestToken","tallestHeight","_tallestToken$bounds","tallestAscent","_tallestToken$fontPro2","newWord","newToken","newBounds","newY","verticalAlignInLines","alignFunction","alignRight","alignCenter","maxLineWidth","nonZeroWidthWords","countNonZeroWidthWords","first","rest","result","combinedBounds","spacerWidth","previousWord","wordBoundsForLine","wordBounds","alignedLine","alignLines","layout","Number","POSITIVE_INFINITY","calculateFinalTokens","drawIfShould","log","toDebugString","forcedSkipDraw","draw","displayObject","drewDecorations","createTextFieldForToken","d","drawing","createDrawingForTextDecoration","drawDebug","Graphics","substring","parseInt","beginFill","drawRect","endFill","Text","finalScaleWidth","finalScaleHeight","largerScale","fs","fontSizePx","size","valueString","unit","fontSizeStringToNumber","lineNumber","wordNumber","tokenNumber","e","paragraph","g","createInfoText","position","info","clear","lineBounds","w","lineStyle","segmentToken","isSprite"],"mappings":"iiBAOaA,EAAiB,CAI5BC,EACAC,SAEGD,EACAC,GASQC,EAAWF,GAAcA,EAAEA,EAAEG,OAAS,GAEtCC,EAA6CJ,QAClDK,IAANL,EAoCWM,EACX,CAAOC,EAAwBC,IAC9BC,GACC,CAACA,GAAQC,KAAK,KAAKC,OAAOJ,EAAGC,GAIpBI,EAAgBC,GAC3BP,EAAuB,CAACE,EAAcM,IAASN,GAAOK,EAAEC,IAAI,GCmIjDC,EAAwB,MACnCC,QAAS,GACTC,OAAQ,IAAIC,EACZC,eAAgB,CAAEC,OAAQ,EAAGC,QAAS,EAAGC,SAAU,GACnDC,MAAO,GACPC,KAAM,GACNC,gBAAiB,KAqBNC,EAAgBC,GACrB,KAANA,GACAA,EAAEC,MAAM,IAAIC,MAAOC,GAAgD,IAAtBA,EAAKC,OAAO,OAM9CC,EAAgBpB,EAFEE,GAC7BA,EAAEE,mBAAmBiB,GAGVC,EAAgBpB,GACN,iBAAdA,EAAEE,QACEmB,EAAcvB,EAAUsB,GAIxBE,EAAoBxB,EAFEE,QAC3BT,IAANS,GAAmBoB,EAAapB,IAAMY,EAAaZ,EAAEE,UAG1CqB,EAAmBvB,IAC9BA,YAAMT,IAANS,GAAmBoB,EAAapB,IAfhCY,EADwBC,EAgBwBb,EAAEE,UAfzB,OAANW,EADKA,IAAAA,GAiBbW,EAAkBxB,QACvBT,IAANS,GAA0BF,EAAUyB,EAAVzB,CAA2BE,GAE1CyB,GD3NSC,EC2NyBJ,ED1N5CK,IACED,EAAUC,IAFOD,IAAAA,QC6NTE,EAAoC1C,GAC/CA,aAAa2C,QAAoC,IAA1BA,OAAOC,KAAK5C,GAAGG,OC1O3B0C,EAAc,CAACC,EAA4B,CAAC,WACvD,MAAMC,EAAmBD,EAAgBE,KAAK,KAExCC,EAAgBjD,OAAkBA,KAClCkD,EAAkBlD,SAAoBA,KAOtCmD,EAAQD,UACRE,OAAiBD,KACjBE,EAAYJ,EAAaF,GAEzBO,EAAkBF,EAAY,IAE9BG,EACJN,EACEC,EAVOM,OAYHN,EAPeO,wBASfN,EACAD,EAAeI,GACfH,GACA,KACF,IAMN,WAAWO,WALYL,EAAYE,EAGnBI,cAFON,SAII,MAUhBO,EAAkB,CAACC,EAAmB,KACxB,KAArBA,EACK,GAGUA,EAAiBC,OAAOlC,MAAM,OAE/BjB,OAAO,CAACoD,EAAqBC,KAC7C,MAAMC,EAAgBD,EAAUpC,MAAM,KAChCsC,EAAOD,EAAc,GAAGH,OACxBK,EAAmBF,EAAc,GACpCG,OAAO,EAAGH,EAAc,GAAG9D,OAAS,GACpC2D,OAGH,OADAC,EAAIG,GAAQC,EACLJ,GACN,IAIQM,EAAsBC,IACjC,MACE,EAAGC,EACH,EAAGC,EACH,EAAGC,EACH,EAAGC,EAJCC,MAKJA,GACEL,EAGJ,MAAO,CACLC,IAAAA,EACAK,cAJcJ,EAAAA,EAAeE,EAK7BG,eAJgCxE,IAAhBmE,EAKhBC,WAAYb,EAAgBa,GAC5BE,MAAAA,IA4CEG,EAAuB,MAC3B,MAAMC,EAASpD,OAAkBA,KAC3BqD,EAAOrD,GAAcA,MAS3B,WAAW+B,WAGPqB,cAAmBC,mBAEnBD,EAAMC,OAAIC,UAbyBjC,KAAK,SAMrBkC,YATI,GAyDhBC,EAAsBZ,MAE/BA,IAAKA,EAAIK,QACTQ,SAAU,IAGN1C,EAAc6B,EAAIE,YAAc,GAAK,CAAEA,WAAYF,EAAIE,aC7MlDY,EAAcC,IACzB,MAAMC,EAAQD,EAAI1D,MAAM,KACxB,IAAI4D,KAEJ,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAMpF,OAAQsF,IAChCD,MAAgBD,EAAME,GAAGC,OAAO,GAAGC,gBAAgBJ,EAAME,GAAGrB,OAAO,MAGrE,OAAOoB,EAAU1B,QCAN8B,EAAeC,GAC1BC,EAAYF,YAAYC,EAAQE,MASrBC,EAA0B,CACrCC,EACAC,GAAc,KAEd,GAAIA,EAEF,OADAD,EAAUE,YAAW,GACdP,EAAYK,EAAUJ,SACxB,CACL,MAAMO,EAAQR,EAAYK,EAAUJ,SACpC,GAfM,KAgBJO,EAAMhF,QAfD,IAgBLgF,EAAM/E,WACJ4E,EAAU1E,MAAMD,UAChB2E,EAAU1E,MAAMD,SAjBZ,IAkBJ+E,MAAMJ,EAAU1E,MAAMD,WAExB,UAAUgF,MACR,kLAGJ,OAAOV,EAAYK,EAAUJ,WCbpBU,EAAmC,CAC9CC,MAAO,OACPC,OAAQ,WACRC,WAAwB,SACxBC,UAAU,EACVC,cAAe,IACfC,YAAa,EACbC,KAAM,GAMKC,EAGYhH,EAMZiH,EACXC,GAECA,EAAOC,OAAO9G,GAAmCO,OAAOoG,EAAe,IAqC7DI,EAAiB,CAC5BvC,EACAwC,EACA3C,EAA6B,MAE7B,MAAMlD,EAnBwB,EAC9BkD,EAA6B,GAC7BlD,EAA2B,MAE3B,IAAImB,EAAcnB,KAAUmB,EAAc+B,GAC1C,OAAO1E,EAAewB,EAzBtBkD,CAAAA,IAEA,MAAM4C,EAAsC,GAC5C,IAAK,MAAMC,KAAO7C,EAAY,CAC5B,MAAM8C,EAAQ9C,EAAW6C,GAEvBD,EAAoBC,IADW,IAA7BjB,MAAMmB,WAAWD,IACQC,WAAWD,GAEXA,EAG/B,OAAOF,GAcsBI,CAAuBhD,KActCiD,CAAiBjD,EAAY2C,EAAUxC,IACrD,GAAIrD,GAAS,GACb,OAAOA,GCxCHoG,EAAoB,CACxBC,EACAC,EAAgB,CAAEC,EAAG,EAAGC,EAAG,SAOhBC,EAHDH,EAAOC,EAAIF,EAAUE,EACrBD,EAAOE,EAAIH,EAAUG,EAHrBH,EAAUK,MACVL,EAAUM,QAwBTC,EACVN,GACAO,GACCA,EAAKC,IAbWR,CAAAA,GACjBS,QACIA,GACHR,EAAGQ,EAAMR,EAAID,EAAOC,EACpBC,EAAGO,EAAMP,EAAIF,EAAOE,IASXQ,CAAeV,IAcfW,EAAaC,IACxB,MAAMC,EAAkBD,ENpFe,GMqFjCE,EAAWzI,EAAKuI,GAEtB,YAAkBpI,IAAdqI,IAGAC,IAAaD,EACRA,EAAUT,MAEZU,EAASb,EAAIa,EAASV,MAAQS,EAAUZ,GAK3Cc,ENrEHrB,GACAsB,QACIA,EACA,CAAEf,EAAOP,IMoEVuB,EACHhB,GACAiB,IACC,IAAIC,EACJ,OAAOD,EAAKV,IAAKY,SACI5I,IAAf2I,GACFC,EAAMhI,OAAO6G,EAAIA,EACjBkB,EAAaC,EAAMhI,SAEnBgI,EAAMhI,OAAO6G,EAAIkB,EAAWlB,EAAIkB,EAAWf,MAC3Ce,EAAaC,EAAMhI,QAEdgI,KAIAC,EAAe,CAC1BC,EAAyB,CAAErB,EAAGsB,IAAKrB,EAAGqB,IAAKnB,MAAOmB,IAAKlB,OAAQkB,KAC/DnI,EAAiB,CAAE6G,EAAGsB,IAAKrB,EAAGqB,IAAKnB,MAAOmB,IAAKlB,OAAQkB,QAEvD,GAAI/C,MAAM8C,EAAerB,GACvB,OAAO7G,EAGT,MAAM6G,EAAIuB,KAAKC,IAAIH,EAAerB,EAAG7G,EAAO6G,GACtCC,EAAIsB,KAAKC,IAAIH,EAAepB,EAAG9G,EAAO8G,GAY5C,MAAO,CAAED,EAAAA,EAAGC,EAAAA,EAAGE,MAXDoB,KAAKE,IACjBJ,EAAerB,EAAIqB,EAAelB,MAClChH,EAAO6G,EAAI7G,EAAOgH,OAMEH,EAGAI,OAPPmB,KAAKE,IAClBJ,EAAepB,EAAIoB,EAAejB,OAClCjH,EAAO8G,EAAI9G,EAAOiH,QAGIH,IAQbyB,EAAqDlJ,EAGhE,CAACE,EAAaM,IAAkBoI,EAAa1I,EAAKM,EAAEG,QAAS,CAC7D6G,EAAGsB,IACHrB,EAAGqB,IACHnB,MAAOmB,IACPlB,OAAQkB,MAGGK,EAAarB,GACxBA,EAAKzH,OACH,CAAC+I,EAAmBzI,EAAgBwE,IAE5B,IAANA,EACI,CAACmD,EAAW,EAAXA,CAAc3H,IACfyI,EAAQC,OAAO,CACbf,EAAWc,EAAQjE,EAAI,GAAGqC,EAAI4B,EAAQjE,EAAI,GAAGwC,MAA7CW,CAAoD3H,KAE5D,IA+GE2I,EAAmBxB,GACvB9H,EAAmC,CAACuJ,EAASC,aAC3C,IAAIC,WAAID,EAAQ7I,OAAOiH,UAAU,EAIjC,OAHIlG,EAAc8H,KAChBC,GAAKD,EAAQ3I,eAAeE,SAE1B0I,kBAAKF,SAAAA,EAAS5I,OAAOiH,UAAU,GAC1B4B,EAEFD,GACN9I,IATHT,CAS4B8H,GAgQxB4B,EAAkBrI,GAAoB,KAANA,EAGzBsI,EAAyBtI,GACpCA,EACGuI,QAAQ,oBACRtI,cACAsF,OAAQvF,GAAY,KAANA,GC5gBNwI,EAAqC,CAChDC,OAAO,EACPC,cAAc,EACdC,WAAY,QACZC,OAAQ,GACRC,aAAa,EACbC,UAAU,EACVC,gBAAgB,EAChBC,WAAW,GAIPC,EAUQ,CACVC,WAAY,UACZvJ,SAAU,GACVwF,KAAM,SACNgE,YAAY,GAGVC,EAAoB,CAAEC,QAASzE,GAErC5D,OAAOsI,OAAOF,GACdpI,OAAOsI,OAAO1E,SACO2E,UAAmBjJ,EACpBkJ,2BAChB,OAAOJ,EAESK,4BAChB,OAAOjB,EAMEkB,cACT,YAAYC,SAIHC,kBACT,YAAYC,aAGHC,gBACT,YAAYC,WAIHC,iBACT,YAAYC,QAAQlL,KAAK,GAMhBmL,aACT,YAAYD,QAIHE,WACT,YAAYC,MAMHD,SAAKA,GACdE,KAAKC,QAAQH,GAWRG,QAAQH,EAAcI,GACvBJ,IAASE,KAAKD,QAA+B,IAAtBC,KAAKR,eAGhCQ,KAAKD,MAAQD,EACbE,KAAKR,cAAe,EACpBQ,KAAKG,eAAeD,IAMXE,mBACT,OAAkBJ,KAAKF,KL+CnB5B,QAAQrH,IAAe,IK3ClBuE,gBACT,YAAYiF,WAMHjF,cAAUH,GACnB+E,KAAKM,aAAarF,GAWbqF,aAAarF,EAAsBiF,GACxCvJ,OAAO4J,QAAQtF,GAAQuF,QAAQ,EAAEjI,EAAKhD,KACpCyK,KAAKS,eAAelI,EAAKhD,GAAO,IAGlCyK,KAAKR,cAAe,EACpBQ,KAAKG,eAAeD,GAGf/E,eACL5C,EACAE,EAA6B,IAE7B,OAAOiI,EAAkBnI,EAAKyH,KAAK5E,UAAW3C,GAGzCkI,gBAAgBnL,GACrB,MAAMyF,EAASzF,EAAK6G,IAAI,EAAGzD,QAAAA,EAASH,WAAAA,KAClCuH,KAAK7E,eAAevC,EAASH,IAE/B,OAAOuC,EAAiBC,GAYnBwF,eACLlI,EACA0C,EACAiF,GAmBA,OAjBAF,KAAK5E,UAAU7C,GAAO0C,EAMV,YAAR1C,GAAqByH,KAAKY,aAAL,SAEvBC,QAAQC,uGAGRd,KAAKY,aAAL,YAA4CvM,GAG9C2L,KAAKR,cAAe,EACpBQ,KAAKG,eAAeD,MAYfa,mBAAmBxI,EAAa2H,GACrC,OAAI3H,UAAY6C,wBACFA,UAAU7C,GAEtByH,KAAKR,cAAe,EACpBQ,KAAKG,eAAeD,OAObU,yBACT,gBAAOZ,KAAK5E,kBAAL4F,EAAgBhC,QAKd4B,iBAAazB,GACtBa,KAAKiB,gBAAgB9B,GAUhB8B,gBACL9B,EACAe,GAEAF,KAAKS,eAAe,UAAWtB,EAAee,GAKrCgB,iBACT,YAAYC,YAGHC,cACT,YAAYC,SAGHC,kBACT,YAAYC,aAGHC,sBACT,YAAYC,iBAMHC,oBACT,YAAYC,eAIHC,0BACT,YAAYC,qBAIHC,sBACT,YAAYC,iBAGHC,qBACT,YAAYC,gBAGdC,YACEpC,EAAO,GACP1E,EAA0B,GAC1BiE,EAA6B,GAC7B8C,GAEAC,MAAMD,QAnOA7C,qBAKAE,cAAe,OAIfE,YAAa,OAKbE,QAA0B,QAY1BG,MAAQ,QAoCRM,WAA2B,QAyH3Bc,YAAsB,QAItBE,SAAqB,QAIrBE,aAA2B,QAI3BE,iBAA6B,QAI7BY,eAAkC,UAGlCV,2BAKAE,iCAKAE,6BAIAE,uBAaNjC,KAAK2B,eAAiB,IAAIW,EAC1BtC,KAAK+B,iBAAmB,IAAIO,EAC5BtC,KAAK6B,qBAAuB,IAAIS,EAChCtC,KAAKiC,gBAAkB,IAAIK,EAE3BtC,KAAKuC,SAASvC,KAAK2B,gBACnB3B,KAAKuC,SAASvC,KAAK+B,kBACnB/B,KAAKuC,SAASvC,KAAK6B,sBACnB7B,KAAKuC,SAASvC,KAAKiC,iBAEnBjC,KAAKwC,gBAEL,MAAMC,OAAqBtE,EAAoBkB,GAC/CW,KAAKV,SAAWmD,EAEhBrH,KAAc4D,QAAS,IAAO5D,GAE1B4E,KAAKX,QAAQV,YACfvD,EAAS,UAAc,CAAEyD,WAAY,eAEvC,MAAM6D,OAA2BnI,EAAkBa,EAAU4D,SAC7D5D,EAAU4D,QAAU0D,EACpB1C,KAAK5E,UAAYA,EAEb4E,KAAKX,QAAQd,QACfyB,KAAK2C,mCAAmC3C,KAAKX,QAAQd,QAGvDyB,KAAKF,KAAOA,EAON0C,gBACNxC,KAAKiC,gBAAgBW,iBACrB5C,KAAK2B,eAAeiB,iBACpB5C,KAAK+B,iBAAiBa,iBACtB5C,KAAK6B,qBAAqBe,iBAE1B5C,KAAKmB,YAAc,GACnBnB,KAAKqB,SAAW,GAChBrB,KAAKuB,aAAe,GAQdoB,mCAAmCpE,GACzCyB,KAAKyB,iBAAmB,GAExB9K,OAAO4J,QAAQhC,GAAQiC,QAAQ,EAAElF,EAAKuH,YACpC,IAAIC,EACJ,GAAID,aAAwB5M,EAC1B6M,EAASD,OAGT,GNvUO,iBADgBlN,EMwUJkN,INtUzBlN,aAAaoN,GACbpN,aAAaqN,mBACbrN,aAAasN,iBMqULH,EAAS7M,EAAOiN,KAAKL,YNpUClN,CAAAA,GAC9BA,aAAawN,kBAAoBxN,aAAayN,EMoU7BC,CAAgBR,GAGzB,UAAUS,+CAC6BhI,wJAHvCwH,EAAS7M,EAAOiN,KAAKH,EAAQG,KAAKL,IN3UblN,IAAAA,EMmVzB,MAAMwM,EAAUW,EAAOX,aACP9N,IAAZ8N,GACFA,EAAQoB,YAAYC,YAAY,SAAWD,GACzCvD,KAAKyD,qBAAqBF,IAI9BvD,KAAKwB,gBAAgBlG,GAAOwH,EAG5B,MACMvN,KAAUmO,OAA0BpI,YADpB0E,KAAK7E,eAAeG,MAAQ,IAElD0E,KAAKS,eAAenF,EAAK/F,KAIrBkO,qBAAqBF,GAE3BvD,KAAKR,cAAe,EACpBQ,KAAKN,YAAa,EAElBM,KAAKG,iBAUCA,eAAewD,GACrB,QACuB,IAArBA,QACsBtP,IAArBsP,IAA+D,IAA7B3D,KAAKX,QAAQb,eAEhDwB,KAAK4D,aAeFA,OAAOnF,GAEZ,MAAMrD,EAAY4E,KAAK5E,WACjBkD,WAAEA,GAAe0B,KAAKX,QACtBmC,EAAkBxB,KAAKX,QAAQd,QAAUyB,KAAKwB,gBAe9CqC,EFjUqB,EAC7BhE,EACA5E,EACAuG,WAEA,MAAMZ,WAAkC3F,EAAO+D,WAAW,GACpD8E,EAAgC,GAChCC,EAAa,GAEbC,EACJ/G,UAEA,GAAqB,iBAAVA,EACT,OAAOA,EAGT,MAAM1E,IAAEA,EAAFE,WAAOA,EAAa,IAAOwE,EACjC,IAAI1H,EAA2BqL,EAC3BpL,EAAO,GL5GZyO,IAAAA,EK8GK1L,IAEFuL,EAASI,KAAK,CAAEtL,QAASL,EAAKE,WAAAA,IAE9BjD,GLlHHyO,EKkH2BH,ELjHzBG,EAAsC5H,IAAQ8H,GAAMA,EAAC,UKiHlBnN,KAAK,KAEvCzB,EAzCyB,EAC7BC,EACA4F,EACA2I,KAEA,MAAMK,EAAUC,KAAKC,UAAU9O,GAC/B,QAA4BnB,IAAxB0P,EAAWK,GAAwB,CACrC,MAAMxD,EAAexF,EAAU4D,QACzB/D,EAASzF,EAAK6G,IAAK9D,GAtBW,GACpCK,QAAAA,EAASH,WAAAA,GACX2C,IAEAD,EAAevC,EAASwC,EAAW3C,GAkBA8L,CAAyBhM,EAAK6C,IACzDoJ,EAAoB,CAAC5D,KAAiB3F,GAC5C8I,EAAWK,GAAWpJ,EAAiBwJ,GAEzC,OAAOT,EAAWK,IA6BNzD,CAAgBmD,EAAU7I,EAAQ8I,GAC1CxO,EA4CJA,CAAAA,IAEA,MAAMkP,eAAEA,GAAmBlP,EAE3B,QAAuBlB,IAAnBoQ,GAAmD,WAAnBA,EAClC,OAAOlP,EAGT,MAAMmP,gBAAEA,EAAFC,oBAAmBA,GAAwBpP,EAC3CqP,EAAeF,GAAmBnP,EAAMuF,MAAQP,EAAcO,KAC9D+J,EAAmBF,GAAuB,EAGhD,SAASG,EACPC,EACAC,EAAsCD,eAEtC,gBAAIxP,EAAMkP,iBAANQ,EAAsBC,SAASH,GAC1B,CACL,IAAIC,mBACFzP,KAASyP,aAAuCJ,EAClD,IAAII,uBACFzP,KAASyP,iBAA2CH,EACtD,IAAIG,oBACFzP,KAASyP,cAbK,GAgBb,GAGT,YACKzP,EACAuP,EAAgB,aAChBA,EAAgB,YAChBA,EAAgB,eAAgB,iBA9EzBK,CAA6B5P,IAGvC,MAAM6P,EAA2B,CAC/B7P,MAAAA,EACAC,KAAAA,EACA4D,SAAU6D,EAAM7D,SAASiD,IAAI2H,IAIzBqB,WAAS9P,EAAK,UAA4B,GAChD,GAAI8P,EAAQ,CACV,QAAwBhR,IAApBmN,EACF,UAAUlH,mCACwC+K,uJAGpD,MAAMvC,EAAkCtB,EAAgB6D,GACxD,QAAehR,IAAXyO,EACF,UAAUxI,mCACwC+K,+KAGpD,GAAIvC,aAAkB7M,GAAW,EAC/B,UAAUqE,+CACiC+K,yEAK7C,MAAMC,EDhIgBxC,CAAAA,GAC1B,IAAI7M,EAAO6M,EAAOX,SC+HQoD,CAAYzC,GAClCsC,EAAYhM,SAAW,CAACkM,KAAkBF,EAAYhM,UAMxD,OAFA0K,EAAS0B,MAEFJ,GAGT,OAAOpB,EAA6BnE,IE8Pb4F,CL9LG,EAC1BhP,EACAK,EACA4O,KKwLI1F,KAAKX,QAAQV,WLpMWlI,CAAAA,GAC5BkP,IAAgBC,KAAKnP,GAeEoP,CAAcpP,KACnCA,EA1GsBA,CAAAA,IACxB,MAAMqP,EAAa,IAAIpO,yBACHiO,IAAgBI,WAClC,QAGF,OAAOtP,EAAMuP,WAAWF,EAAY,CAACxN,EAAO2N,WACtCA,SAAAA,EAAU9R,QAAS,EAEdmE,gBAEeA,kBA+FhBqG,CAAUlI,IAGpBA,EA9FqCA,CAAAA,GACrCA,EAAMyH,QAAQpF,EAAsB,CAACoN,EAAG3N,EAAKE,EAAa,MACxD,IAAI0N,MAAa5N,IAAME,OAAgBF,KAGvC,OAFA4N,EAASA,EAAOjI,QAAQ,OAAQ,KAChCiI,EAASA,EAAOjI,QAAQ,OAAQ,KACzBiI,IAyFDC,CAAuB3P,GAC/B,MAAM4P,EAAKxP,EAAYC,GAEjBwP,EAA6B,GACnC,IAAIhO,EACJ,KAAQA,EAAQ+N,EAAGE,KAAK9P,IAAS,CAG/B,MAAM+P,EAAWnO,EAAmBC,GACpCgO,EAAWpC,KAAKsC,GAGlB,MAAMC,EA1KuB,EAC7BhQ,EACAiQ,KAEA,MAAMD,EAAqB,GAE3B,IAEID,EAFAG,EAAYlQ,EACZoF,EAAS,EAEb,IAAK2K,KAAYE,EACf,QAAkBrS,IAAdsS,EAAyB,CAC3B,MAAMpO,IAAEA,EAAFI,MAAOA,GAAU6N,EACjBI,EAAajO,EAAQkD,EACrBgL,EAAWD,EAAarO,EAAIpE,OAClC0H,GAAUgL,EAEV,MAAMC,EAAUH,EAAUvO,OAAO,EAAGwO,GACpCH,EAASvC,KAAK4C,GAEdH,EAAYA,EAAUvO,OAAOyO,GAKjC,OAFAJ,EAASvC,KAAKyC,GAEPF,GAkJUM,CAAgBtQ,EAAO6P,GAElCzG,EA9EuB,EAC7B4G,EACAjR,KAEA,MAAMwR,EAAmD,CAAE5N,SAAU,IACjD,KAAhBqN,EAAS,IACXO,EAAW5N,SAAS8K,KAAKuC,EAAS,IAGpC,MAAMQ,EAAyB,CAACD,GAEhC,IAAK,IAAIvN,EAAI,EAAGA,EAAIjE,EAAKrB,OAAQsF,IAAK,OACpC,MAAMlB,EAAM/C,EAAKiE,GACXqN,WAAUL,EAAShN,EAAI,MAAM,GACnC,GAAIlB,EAAIM,UAAW,CACjB,MAAMoE,EAAQ9D,EAAmBZ,GACjB,KAAZuO,GACF7J,EAAM7D,SAAS8K,KAAK4C,GAEtB5S,EAAK+S,GAAY7N,SAAS8K,KAAKjH,GAC/BgK,EAAW/C,KAAKjH,OACX,CACL,MAAMiK,EAAcD,EAAWzB,MAC/B,QAAoBnR,IAAhB6S,GAA6BA,EAAY3O,MAAQA,EAAIK,QACvD,UAAU0B,sDACwC/B,EAAIK,8DAAwDsO,SAAAA,EAAa3O,QAG7G,KAAZuO,GACF5S,EAAK+S,GAAY7N,SAAS8K,KAAK4C,IAYrC,OARIG,EAAW9S,OAAS,GACtB0M,QAAQsG,cACGF,EAAW9S,OAAS,uBAAuB8S,EACjD5K,IAAKY,GAAUA,EAAM1E,KACrBvB,KAAK,QAILgQ,EAAW5N,UAqCHgO,CAAgBX,EAAUH,GAEzC,MAAO,CAAElN,SAAUyG,IK6JIwH,CACnBrH,KAAKF,KACLnJ,OAAOC,KAAKoJ,KAAK5E,YAMjBA,EACAoG,GAMI8F,ED0H0B,EAClCzD,EACAvF,EAAyB,mBAGzB,MAAMiJ,EAAQ,IAAIC,EAAS,IACrB5G,EAAeiD,EAAatO,MAElC,IAAIJ,EAEJ,MAAMsS,EACJ,CAAClS,EAA0BC,IAC1ByH,IACC,IAAIkJ,EAAuB,GAY3B,GAVAoB,EAAMhS,WACDA,GAEHoF,UAAU,EACV+M,eAAgB,EAChBC,mBAAoB,EACpBC,gBAAiB,EACjB9I,YAAY,IAGO,iBAAV7B,EAAoB,CAG7B,MAAM4K,EA9CW,EAAClS,EAAW2I,KACnC,GAAmB,UAAfA,EACF,MAAO,CAAC3I,GAAGmS,QAAQ7J,GAAuB/C,OAAO8C,MACzB,eAAfM,EACT,OAAO3I,EAAEC,MAAM,IACV,CAEL,IAAImS,mDACJ,MAAMC,EAAY1J,EAAsB2J,cAMxC,MALiC,IAA7BD,EAASE,QAAQ,QACnBH,+BACqC,IAA5BC,EAASE,QAAQ,SAC1BH,+BAEQzN,kCAAkCgE,OAAgByJ,OAgCnCI,CAAUlL,EAAOqB,GAEhC8J,EAAaP,EAAaxL,IAAK/C,cACnC,OAAQ/D,EAAM8S,eACZ,IAAK,YACHd,EAAMzH,KAAOxG,EAAIK,cACjB,MACF,IAAK,YACH4N,EAAMzH,KAAOxG,EAAI2O,cACjB,MACF,IAAK,aACHV,EAAMzH,KAAOzG,EAAWC,GACxB,MACF,QACEiO,EAAMzH,KAAOxG,EAGjB,MAAMgP,WAAK/S,EAAMgT,kBAAkB,EAC7BC,WAAKjT,EAAMkT,mBAAmB,EAE9BC,EAAarO,MAAMiO,IAAOA,EAAK,EAAI,EAAMA,EACzCK,EAActO,MAAMmO,IAAOA,EAAK,EAAI,EAAMA,EAEhDjB,EAAMqB,MAAMC,IAAIH,EAAYC,GAE5BxT,OAAsB6E,EAAwBuN,GAAO,IACrDpS,EAAeC,QAAUuT,EACzBxT,EAAeE,SAAWsT,EAC1BxT,EAAeG,UAAYqT,EAE3B,MAAM1T,EAAS0G,EAAkB4L,GAG3BuB,WAASvB,EAAMhS,MAAMwT,mBAAmB,EAC1CD,EAAS,IACX3T,EAAeE,SAAWyT,EAAS,EACnC3T,EAAeC,QAAU0T,EAAS,EAClC3T,EAAeG,SACbH,EAAeC,OAASD,EAAeE,SAG3C,MAAMI,ED5ZkB,EAChCF,EACAyT,EACA7T,KAEA,MAAMC,OAAEA,EAAFC,QAAUA,GAAYF,EACtB8T,EAAW7T,EACX8T,EAAW7T,EACX8T,EAAUF,EAAWC,GACrBjN,MAAEA,GAAU+M,EAgClB,MAJoB,CAAC,YAAa,WAAY,eAE3C3M,IA3BH,SAAwBf,SACtB,MAAM8N,EAAQ7T,KAAS+F,UACjBY,EAAS3G,KAAS+F,cAClBO,WAAUtG,KAAS+F,cAA2B,EAEpD,QAAcjH,IAAV+U,QAAkC/U,IAAX6H,EACzB,OAGF,IAAIH,EAAIF,EAUR,MATY,cAARP,EAEFS,GAAKkN,EAAW5T,EAAU,EACT,gBAARiG,IAETS,GAAKmN,EAAWC,EAAU,GAIrB,CACLC,MAAAA,EACAnU,OAAQ,CAAE6G,EAvBJ,EAuBOC,EAAAA,EAAGE,MAAAA,EAAOC,OAAAA,MAOxBhB,OAAQY,QAAYzH,IAANyH,ICoXeuN,CACtB9T,EACAN,EACAE,GAGF,MAAO,CACLH,QAASsE,EACT/D,MAAAA,EACAC,KAAAA,EACAP,OAAAA,EACAE,eAAAA,EACAM,gBAAAA,KAIJ0Q,EAASA,EAAOxI,OAAOyK,WACdnL,aAAiBhH,EAAQ,CAClC,MAAM6M,EAAS7F,EAGTqM,EAAwB,SAFX/T,EAAK,WAKxB,GAFAJ,OAAsB6E,EAAwBuN,GAAO,IAEjD+B,EAAQ,CAIV,MAAMvL,EAAIV,KAAKE,IAAIuF,EAAO5G,OAAQ,GAE9B6B,EAAI,GAAwB,IAAnB+E,EAAO8F,MAAM7M,GAExB+G,EAAO8F,MAAMC,IADE1T,EAAeC,OAAS2I,EApoB3B,IA0oBhB,MAAM9I,EAAS0G,EAAkBmH,GACjCqD,EAAOjC,KAAK,CACVlP,QAAS8N,EACTvN,MAAAA,EACAC,KAAAA,EACAP,OAAAA,EACAE,eAAAA,EACAM,qBAAiBpB,QAEd,CAEL,MAAM+Q,EAAcnI,GACd7D,SAAEA,GAAagM,EAEfmE,EAAWnE,EAAY7P,MACvBiU,EAAUpE,EAAY5P,KAE5B,QAAiBnB,IAAbkV,EACF,UAAUjP,gDACkC8K,KAI9Ce,EAASA,EAAOxI,OACdvE,EAAS0O,QAAQL,EAAkC8B,EAAUC,KAGjE,OAAOrD,GAOLsD,EAAc5F,EAAazK,SAAS0O,QACxCL,EAH+B7G,EADpB,MAOLjG,SAAU+O,EAAI9O,cAAe+O,GAAQ/I,EACvCgJ,OACIvV,IAARsV,IAAsBtP,MAAMsP,IAAmBA,EAAiB,EAI5D9O,WAAc+F,EAAa/F,eAAe,EAC1CL,WAAQoG,EAAapG,SAAS,OAEpC,MAtTa,EACbqF,EACAgK,EACAhP,EACAL,KAEA,MAAMsP,EAAS,CAAEhO,EAAG,EAAGC,EAAG,GAC1B,IAAIgO,EAAY,EACZhN,EAAkB,GAClBX,EAAkB,GACtB,MAAM4N,EAA2B,GACjC,IAqEI/M,EArEAgN,EAAsB,EAE1B,SAASC,SACM7V,IAAT0I,GAAsBA,EAAK5I,OAAS,GAEtCiI,EAAK8H,KAAKnH,GAIZA,EAAO,GACPgN,EAAY,EAGd,SAASI,IACPH,EAAS9F,KAAK9H,GACdA,EAAO,GAGT,SAASgO,EAA4CnN,GAEnDkN,IAGAL,EAAOhO,EAAI,EACXgO,EAAO/N,EAAI+N,EAAO/N,EAAIkO,EAGtBA,EAAsB,EACtBI,EAAiBpN,GAGnB,SAASoN,EAAiBpN,eACxB,MAAM3H,iBAAW2H,YAAAA,EAAO9H,uBAAPmV,EAAuBhV,YAAY,EAC9C4G,iBAASe,YAAAA,EAAOhI,eAAPsV,EAAerO,UAAU,EAExC+N,EAAsB5M,KAAKE,IAAI0M,EAAqB3U,EAAUuF,IAEhC,IAA1BvE,EAAe2G,KACjBgN,EAAsB5M,KAAKE,IAAI0M,EAAqB/N,IAIxD,SAASsO,EAAsCvN,GAE7CoN,EAAiBpN,GACjBA,EAAMhI,OAAO6G,EAAIgO,EAAOhO,EACxBmB,EAAMhI,OAAO8G,EAAI+N,EAAO/N,EAExB+N,EAAOhO,GAAKmB,EAAMhI,OAAOgH,MAG3B,SAASwO,IACP1N,EAAKyD,QAAQgK,GAOf,SAASE,EAAazN,GACpB,MAA6C,UAAtCA,EAAM1H,MAAN,WAGT,SAASoV,EAAiC1N,GAExCF,EAAKmH,KAAKjH,GACV8M,GAAa9M,EAAMhI,OAAOgH,MAI5B,IAAK,IAAIxC,EAAI,EAAGA,EAAIoG,EAAO1L,OAAQsF,IAAK,CACtCwD,EAAQ4C,EAAOpG,GACf,MAAM/D,EAAeU,EAAkB6G,GACjC2N,EAAYtU,EAAe2G,GAC3B4N,EAAU7U,EAAciH,IACJvH,GAAgBmV,KAGxCJ,IACAP,KAGFS,EAAiC1N,GACjCoN,EAAiBpN,GAGbvH,IACF+U,IACAP,MAKEU,GAAaF,EAAazN,IArCvB6M,EAAOhO,EAAIiO,EAAYF,GAyCxBzN,EAAKjI,OAAS,IAHlBiW,EAA4CnN,GAU5CF,EAAK5I,OAAS,IAChBsW,IACAP,KAEE9N,EAAKjI,OAAS,GAChBgW,IAGF,MAAMW,EAnJNC,CAAAA,IAEA,IAAK,MAAM3O,KAAQ2O,EAAO,CAExB,IAAItR,EADM2C,EAAKjI,OAEf,KAAOsF,GAAK,GAAG,CACbA,GAAK,EACL,MAAMsD,EAAOX,EAAK3C,GAClB,GAAIlD,EAAqBwG,GACvB,MAEA,IAAK,MAAME,KAASF,EAClBE,EAAMhI,OAAOgH,MAAQ,EACrBgB,EAAMhI,OAAOiH,OAASmB,KAAKC,IACzBL,EAAMhI,OAAOiH,OACbe,EAAM9H,eAAeG,WAM/B,OAAOyV,GA8HqBC,CAAgChB,GAEtDiB,EAtP4B,EAClCF,EACAlQ,EACAqQ,KAEA,IAAIC,EAAmCpW,IAEnCqW,EAAqB,EACzB,MAAMC,EAA2B,GAEjC,IAAK,MAAMjP,KAAQ2O,EAAO,aACxB,MAAMrN,EAAqB,GAG3B,IAAI4N,EAA2B1N,EAAgBxB,GAC3CmP,oBAAgBD,EAAarW,eAAbuW,EAAqBtP,UAAU,EAC/CuP,oBAAgBH,EAAanW,uBAAbuW,EAA6BtW,UAAU,EACvDY,EAAcsV,KAChBC,GAAiBD,EAAanW,eAAeE,QAC7CoW,EAAgBH,EAAarW,OAAOiH,QAShB,IAAlBqP,EACFD,EAAeH,EAEfA,EAAuBG,EAGzB,IAAK,MAAMvO,KAAQX,EAAM,CACvB,MAAMuP,EAAqB,GAC3B,IAAK,MAAM7E,KAAW/J,EAAM,CAC1B,GAAIzG,EAAewQ,GAAU,CAC3B,MAAM8E,OACD9E,GAEL6E,EAAQzH,KAAK0H,GACb,SAEF,MAAM3W,OAAEA,EAAFE,eAAUA,EAAVI,MAA0BA,GAAUuR,EACpC5K,EAASjH,EAAOiH,OAEhB2P,OAAyB5W,GACzBwF,EAA2BlF,EAAMkF,OAEvC,IAAIrF,OAAEA,GAAWD,EACba,EAAc8Q,KAChB1R,EAAS0R,EAAQ7R,OAAOiH,QAG1B,IAAI4P,EAAO,EACX,OAAQrR,GACN,IAAK,SACHqR,EAAOV,EAAqBG,EAAgBrP,EAC5C,MACF,IAAK,SACH4P,EAAOV,GAAsBG,EAAgBrP,GAAU,EACvD,MACF,IAAK,MACH4P,EAAOV,EACP,MAEF,QACEU,EAAOV,EAAqBK,EAAgBrW,EAGhDyW,EAAU9P,EAAI+P,EAEd,MAAMF,OACD9E,GACH7R,OAAQ4W,IAEVF,EAAQzH,KAAK0H,GAEflO,EAAQwG,KAAKyH,GAGfP,GAAsBG,EAAgB1Q,EACtCwQ,EAASnH,KAAKxG,GAGhB,OAAO2N,GAgKeU,CAlTE,EACxBvR,EACAqP,EACAkB,KAGA,IAAIiB,EACJ,OAAQxR,GACN,IAAK,OACHwR,EAAgBvO,EAChB,MACF,IAAK,QACHuO,EA1EHnC,CAAAA,GACAzN,GACCD,EAAc,CACZL,EAAG+N,EAAWrN,EAAUJ,GACxBL,EAAG,GAFLI,CAGGsB,EAAUrB,IAqEK6P,CAAWpC,GAC3B,MACF,IAAK,SACHmC,EArEHnC,CAAAA,GACAzN,IACCD,OAAAA,EAAc,CAAEL,GAhFGA,EAgFOU,EAAUJ,GAhFNvC,EAgFagQ,GAhFgBhQ,EAAUiC,GAAK,GAgFpBC,EAAG,GAAzDI,CACEsB,EAAUrB,IAjFM,IAACN,EAAWjC,GAmJZqS,CAAYrC,GAC5B,MACF,IAAK,UAhENsC,EAiEgCtC,EAA7BmC,EAhEH5P,IAEC,GAAc,IADAA,EAAKjI,OAEjB,MAAO,GAGT,MAAMiY,EAA8BhQ,EAAKlB,OAAO,EAAGe,MAAAA,KAAYA,EAAQ,GACjEoQ,EAAyBD,EAAkBjY,OAEjD,GAA+B,IAA3BkY,EAA8B,CAChC,MAAOC,KAAUC,GAAQnQ,EAEzB,OADAkQ,EAAMxQ,EAAI,EACH,CAACwQ,KAAUC,GAGpB,MAAMC,EAAmB,GACnBC,EAAmCL,EAzDpCzX,OAAOuI,GA4DNwP,GADaP,EADTM,EAAexQ,QAESoQ,EAAyB,GAE3D,IAAIM,EACJ,IAAK,IAAIlT,EAAI,EAAGA,EAAI2C,EAAKjI,OAAQsF,IAAK,CACpC,MAAMxE,EAASmH,EAAK3C,GACpB,GAAqB,IAAjBxE,EAAOgH,MAAa,CACtBuQ,EAAO/S,QAAUxE,GACjB,SAEF,IAAI6G,EAMJ,GAJEA,OADmBzH,IAAjBsY,EACE,EAEAA,EAAa7Q,EAAI6Q,EAAa1Q,MAAQyQ,EAExCrS,MAAMyB,GACR,UAAUxB,+EAIZ,MAAMqR,EAAkB/O,EAAWd,EAAXc,CAAc3H,GACtC0X,EAAehB,EACfa,EAAO/S,GAAKkS,EAEd,OAAOa,GAsBL,MACF,QACE,UAAUlS,oCACsBE,wDArEnC2R,IAAAA,EAyED,IAAK,MAAM/P,KAAQ2O,EAAO,CACxB,MAAM6B,EAA8B,GACpC,IAAK,MAAM7P,KAAQX,EAAM,CACvB,MAAMyQ,EAAarP,EAAgBT,GAEnC,GADA6P,EAAkB1I,KAAK2I,GACnBxS,MAAMwS,EAAW/Q,GACnB,UAAUxB,MAAM,0BAGpB,MAAMwS,EAAcd,EAAcY,GAClC,IAAK,IAAInT,EAAI,EAAGA,EAAI2C,EAAKjI,OAAQsF,IAAK,CACpC,MACMsD,EAAOX,EAAK3C,GAClB2C,EAAK3C,GAAKqD,EAFKgQ,EAAYrT,GAEIqC,EAArBgB,CAAwBC,IAGtC,OAAOgO,GAuQcgC,CAAWvS,EAAOqP,EAAUiB,GACQjQ,GAEzD,OAAOoQ,GAuLA+B,CAAOvD,EALZC,GAAME,EAAoBD,EAAiBsD,OAAOC,kBAKfrS,EAAaL,ICnRzB2S,CAAqBtJ,EAAcvF,GAmB1D,OAjBA0B,KAAKJ,QAAU0H,EACftH,KAAKN,YAAa,EAQlBM,KAAKoN,aAAa3O,GAEduB,KAAKX,QAAQhB,cACfwC,QAAQwM,IAAIrN,KAAKsN,iBAGnBtN,KAAKR,cAAe,EAEb8H,EAQD8F,aAAaG,GACnB,QACqB,IAAnBA,QACoBlZ,IAAnBkZ,IAA0D,IAA1BvN,KAAKX,QAAQZ,YAE9CuB,KAAKwN,WAUFA,OACLxN,KAAKwC,gBACL,MAAM9D,eAAEA,GAAmBsB,KAAKX,QAC1BQ,EAASnB,EACXsB,KAAKL,WAELK,KAAKL,WAAWzE,OAAO3E,GAE3B,IACIkX,EADAC,GAAkB,EAGtB7N,EAAOW,QAAS1L,IACd,GAAIqB,EAAYrB,KACd2Y,EAAgBzN,KAAK2N,wBAAwB7Y,GAC7CkL,KAAK0B,cAAca,SAASkL,GAC5BzN,KAAKkB,WAAWgD,KAAKuJ,GAEjB3Y,EAAEW,iBAAmBX,EAAEW,gBAAgBtB,OAAS,GAAG,CACrD,IAAK,MAAMyZ,KAAK9Y,EAAEW,gBAAiB,CACjC,MAAMoY,EAAU7N,KAAK8N,+BAA+BF,GACnDH,EAAuBlL,SAASsL,GACjC7N,KAAKuB,aAAa2C,KAAK2J,GAEzBH,GAAkB,EAGlB1X,EAAclB,KAChB2Y,EAAgB3Y,EAAEE,QAClBgL,KAAKoB,QAAQ8C,KAAKuJ,GAClBzN,KAAK8B,gBAAgBS,SAASkL,IAGhC,MAAMxY,OAAEA,GAAWH,EACnB2Y,EAAc3R,EAAI7G,EAAO6G,EACzB2R,EAAc1R,EAAI9G,EAAO8G,KAGJ,IAAnB2C,GAA4BgP,GAC9B7M,QAAQsG,KACN,oKAIAnH,KAAKX,QAAQjB,OACf4B,KAAK+N,YAEP/N,KAAKN,YAAa,EAGZoO,+BACNrJ,GAEA,MAAMxP,OAAEA,GAAWwP,EACnB,IAAI2E,MAAEA,GAAU3E,EAChB,MAAMoJ,EAAU,IAAIG,EAEpB,GAAqB,iBAAV5E,EAAoB,CAC7B,GAA2B,IAAvBA,EAAMlB,QAAQ,KAIhB,UAAU5N,MACR,oKAJF8O,EAAQ,KAAOA,EAAM6E,UAAU,GAC/B7E,EAAQ8E,SAAS9E,EAAO,IAa5B,OALAyE,EACGM,UAAU/E,GACVgF,SAASnZ,EAAO6G,EAAG7G,EAAO8G,EAAG9G,EAAOgH,MAAOhH,EAAOiH,QAClDmS,UAEIR,EAGDF,wBAAwB1Q,GAC9B,MAAMoL,cAAEA,EAAgB,IAAOpL,EAAM1H,MAErC,IAAIuK,EAAO7C,EAAMjI,QACjB,OAAQqT,EAAcJ,eACpB,IAAK,YACHnI,EAAOA,EAAKmI,cACZ,MACF,IAAK,YACHnI,EAAOA,EAAKnG,cACZ,MACF,IAAK,aACHmG,EAAOzG,EAAWyG,GAKtB,MAAM7F,EAAY,IAAIqU,EAAKxO,EAAM7C,EAAM1H,OAEvC,IAAIgT,eAAEA,EAAiB,EAAnBE,gBAAwBA,EAAkB,GAAQxL,EAAM1H,MAC5DgT,EACElO,MAAMkO,IAAmBA,EAAiB,EAAI,EAAIA,EACpDE,EACEpO,MAAMoO,IAAoBA,EAAkB,EAAI,EAAIA,EAEtD,IAAI8F,EAAkBhG,EAClBiG,EAAmB/F,EACvB,MAAMgG,EAAcpR,KAAKE,IAAIgL,EAAgBE,GAE7C,GAAIgG,EAAc,EAAG,OACfA,IAAgBhG,GAClB8F,GAAmBE,EACnBD,EAAmB,IAEnBA,GAAoBC,EACpBF,EAAkB,GAGpB,MAAMG,WAAKzU,EAAU1E,MAAMD,YAAY,EACjCqZ,GACW,iBAAPD,EH3iBuBE,CAAAA,IACrC,MAAOC,EAAaC,GAAQF,EAAKhZ,MAAM,kBACjC2F,EAAQC,WAAWqT,GAMzB,OAAQC,GACN,IAAK,IACH,MApEiB,IAoEVvT,EACT,IAAK,KACL,IAAK,MACH,OAxEY,GAwELA,EACT,IAAK,KACH,OAxEY,gBAwELA,EAET,QAEE,OAAOA,IGwhBqBwT,CAAuBL,GAAMA,GACvDD,EAEFxU,EAAU1E,MAAMD,SAAWqZ,EAI7B,OADA1U,EAAU2O,MAAMC,IAAI0F,EAAiBC,GAC9BvU,EAOFqT,gBACL,MAAMvC,EAAQ/K,KAAKH,OACnB,IAAIlK,EAAIqK,KAAKI,aAAe,YAyC5B,YAvCc/L,IAAV0W,IACFpV,GAAKoV,EAAM1O,IAAI,CAACD,EAAM4S,IACpB5S,EAAKC,IAAI,CAACU,EAAMkS,IACdlS,EACGV,IAAI,CAACY,EAAOiS,KACX,IAAIpP,EAAO,GACP3J,EAAY8G,GAEZ6C,EADExJ,EAAe2G,aAGNA,EAAMjI,WAEVgB,EAAciH,KACvB6C,aAEF,IAAInK,OAASmK,OAAUkP,KAAcC,KAAcC,KAkBnD,OAjBAvZ,kBACwB,IAAtBsH,EAAMzH,KAAKrB,OACP,SACA8I,EAAMzH,KACHI,MAAM,KACNyG,IAAK9D,OAAYA,MACjBvB,KAAK,QAEdrB,mBAAoBgB,OAAO4J,QAAQtD,EAAM1H,OACtC8G,IAAK8S,GAAMA,EAAEnY,KAAK,MAClBA,KAAK,QACRrB,oBAAqBsH,EAAMhI,OAAO6G,OAAOmB,EAAMhI,OAAO8G,WACpDkB,EAAMhI,OAAOgH,gBACJgB,EAAMhI,OAAOiH,iBACtBe,EAAMhI,OAAOiH,OAASe,EAAMhI,OAAO8G,WAC3BkB,EAAMhI,OAAO6G,EAAImB,EAAMhI,OAAOgH,QACxCtG,2BAA4BsH,EAAM9H,eAAeG,mBAAmB2H,EAAM9H,eAAeC,kBAAkB6H,EAAM9H,eAAeE,UACzHM,IAERqB,KAAK,SAIPrB,EAGFoY,YACL,MAAMqB,EAAYpP,KAAKH,OACvBG,KAAKqC,eAAiB,IAAI2L,EAC1BhO,KAAKgC,eAAeO,SAASvC,KAAKqC,gBAElC,MAAMgN,EAAIrP,KAAKqC,eAgBf,SAASiN,EAAexP,EAAcyP,GACpC,MAAMC,EAAO,IAAIlB,EAAKxO,EAAMlB,GAG5B,OAFA4Q,EAAK1T,EAAIyT,EAASzT,EAAI,EACtB0T,EAAKzT,EAAIwT,EAASxT,EAAI,EACfyT,EAnBTH,EAAEI,QAuBF,IAAK,IAAIT,EAAa,EAAGA,EAAaI,EAAUjb,OAAQ6a,IAAc,CACpE,MAAM5S,EAAOgT,EAAUJ,GACjBU,EAAalS,EAAgBpB,GAEnC,GAAI4D,KAAKY,aAAajG,SAAU,OAC9B,MAAMgV,WAAI3P,KAAKY,aAAahG,iBAAiBoF,KAAK/D,MAClDoT,EAAEhB,UACCuB,UAAU,GAhpBP,SAgpB8B,IACjCxB,SAAS,EAAGsB,EAAW3T,EAAG4T,EAAGD,EAAWxT,QACxCmS,UAGL,IAAK,IAAIY,EAAa,EAAGA,EAAa7S,EAAKjI,OAAQ8a,IAAc,CAC/D,MAAMlS,EAAOX,EAAK6S,GAClB,IAAK,MAAMY,KAAgB9S,EAAM,CAC/B,MAAM+S,EAAW9Z,EAAc6Z,IACzB/T,EAAEA,EAAFC,EAAKA,EAALE,MAAQA,GAAU4T,EAAa5a,OAC/BgU,EACJlN,GACC+T,EACGD,EAAa5a,OAAOiH,OACpB2T,EAAa1a,eAAeC,QAElC,IAmCIoa,GAnCAtT,OAAEA,GAAW2T,EAAa5a,OAC1B6a,IACF5T,GAAU2T,EAAa1a,eAAeE,SAItCe,EAAkByZ,KACc,IAAhC7P,KAAKX,QAAQX,eAEb2Q,EAAEO,UAAU,EA3qBG,SA2qB+B,GAAGzB,UA5qBzC,SA8qBN,IAGFkB,EAAEO,UAAU,EAprBH,SAorB+B,GAAGzB,UAnrBpC,SAqrBL,IAIA7X,EAAeuZ,GACjB7P,KAAKgC,eAAeO,SAClB+M,EAAe,KAAM,CAAExT,EAAAA,EAAGC,EAAGA,EAAI,MAGnCsT,EAAEO,UAAU,GAzrBV,SAyrBiC,IAChCxB,SAAStS,EAAGC,EAAGE,EAAOC,GACtBmS,UAEAuB,UAAU,EA9rBP,SA8rBgC,GACnCzB,YACAC,SAAStS,EAAGmN,EAAUhN,EAAO,GAC7BoS,UAKDlY,EAAY0Z,KAEdL,KAAUK,EAAara,OACvBwK,KAAKgC,eAAeO,SAAS+M,EAAeE,EAAM,CAAE1T,EAAAA,EAAGC,EAAAA"}