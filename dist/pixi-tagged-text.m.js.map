{"version":3,"file":"pixi-tagged-text.m.js","sources":["../src/functionalUtils.ts","../src/tags.ts","../src/style.ts","../src/types.ts","../src/stringUtil.ts","../src/pixiUtils.ts","../src/layout.ts","../src/TaggedText.ts"],"sourcesContent":["import { Nested } from \"./types\";\r\n\r\n/**\r\n * a -> boolean\r\n */\r\ntype Predicate<T> = (t: T) => boolean;\r\n\r\nexport const combineRecords = <\r\n  A extends Record<string, unknown>,\r\n  B extends Record<string, unknown> = A\r\n>(\r\n  a: A,\r\n  b: B\r\n): A & B => ({\r\n  ...a,\r\n  ...b,\r\n});\r\n\r\n/**\r\n * Returns the first item in a list. AKA head\r\n * List a -> a\r\n */\r\nexport const first = <T>(a: T[]): T => a[0];\r\n\r\n/**\r\n * Return the last item in a list. Aka tail\r\n * List f => f a -> a\r\n */\r\nexport const last = <T>(a: T[]): T => a[a.length - 1];\r\n\r\nexport const isDefined: Predicate<unknown | undefined> = (a): boolean =>\r\n  a !== undefined;\r\n\r\n/**\r\n * Predicate p => p -> p\r\n */\r\nexport const complement =\r\n  <T>(predicate: Predicate<T>) =>\r\n    (input: T): boolean =>\r\n      !predicate(input);\r\n\r\n/**\r\n * List f => string -> f {string: a} -> f a\r\n */\r\nexport const pluck =\r\n  <T, U>(key: keyof U) =>\r\n    (objects: U[]): T[] =>\r\n      (objects as (U & Record<string, T>)[]).map<T>((o) => o[key]);\r\n\r\nexport const assoc =\r\n  <T extends Record<string, U>, U>(key: keyof T) =>\r\n    (value: U) =>\r\n      (object: T): T => ({\r\n        ...object,\r\n        ...{ [key]: value },\r\n      });\r\n\r\n/**\r\n * Takes a key (k), a function (f) and an object (o) and applies f to the property k\r\n * of the object and stores the result in o[k].\r\n * Key k, Record r => k -> (a -> a) -> r k a -> r k a\r\n */\r\nexport const mapProp =\r\n  <T, U>(k: keyof U) =>\r\n    (f: (t: T) => T) =>\r\n      (o: U): U => ({\r\n        ...o,\r\n        [k]: f((o as U & Record<string, T>)[k]),\r\n      });\r\n\r\nexport const flatReduce =\r\n  <T, U>(f: (acc: U, t: T) => U, acc: U) =>\r\n    (nested: Nested<T>): U =>\r\n      // @ts-ignore-next-line\r\n      [nested].flat(255).reduce(f, acc);\r\n\r\ntype FlatReduceRetrun<T, U> = (nested: Nested<T>) => U;\r\n\r\nexport const flatEvery = <T>(p: Predicate<T>): FlatReduceRetrun<T, boolean> =>\r\n  flatReduce<T, boolean>((acc: boolean, t: T) => acc && p(t), true);\r\n\r\nexport const nestedMap =\r\n  <T, U>(f: (t: T) => U) =>\r\n    (nested: Nested<T>): Nested<U> =>\r\n      nested instanceof Array ? nested.map(nestedMap(f)) : f(nested);\r\n\r\n/**\r\n * Takes a list and a predicate and returns a number that represents the number of\r\n * true statements when applied to the elements in the list.\r\n * In other words, the number of elements that pass the test.\r\n * (a -> boolean) -> a[] -> number\r\n */\r\nexport const countIf =\r\n  <T>(p: Predicate<T>) =>\r\n    (a: Array<T>): number =>\r\n      a.reduce((count, item) => (p(item) ? count + 1 : count), 0);\r\n\r\nexport type Unary<Param, Return> = (p: Param) => Return;\r\n","import getEmojiRegex from \"emoji-regex\";\r\n\r\nimport { last } from \"./functionalUtils\";\r\nimport {\r\n  TagMatchData,\r\n  AttributesList,\r\n  TagWithAttributes,\r\n  CompositeToken,\r\n  TagToken,\r\n  TextToken,\r\n  isEmptyObject,\r\n} from \"./types\";\r\n\r\n// TODO: this can probably be just a static value without all the options and parameters.\r\n// Seems doing one pass will be enough to gather all relevant info.\r\n// TODO: support self closing tags?\r\n\r\n/**\r\n * Generates a regular expression object for identifying tags and attributes.\r\n * @param tagNamesToMatch List of tag-names that will be matched by the RegExp\r\n */\r\nexport const getTagRegex = (tagNamesToMatch: string[] = [\"\\\\w+\"]): RegExp => {\r\n  const matchingTagNames = tagNamesToMatch.join(\"|\");\r\n\r\n  const captureGroup = (a: string) => `(${a})`;\r\n  const noCaptureGroup = (a: string) => `(?:${a})`;\r\n\r\n  const OR = \"|\";\r\n  const WHITESPACE = `\\\\s`;\r\n  const S = WHITESPACE + \"*\";\r\n  const SS = WHITESPACE + \"+\";\r\n  const CHAR = \"[A-Za-z0-9_\\\\-]\";\r\n  const QUOTE = noCaptureGroup(`\"|'`);\r\n  const NOT_QUOTE = `[^${QUOTE}]`;\r\n  const TAG_NAMES = captureGroup(matchingTagNames);\r\n  const ATTRIBUTE_NAME = CHAR + \"+\";\r\n  const ATTRIBUTE_VALUE = NOT_QUOTE + \"+\";\r\n\r\n  const ATTRIBUTES =\r\n    captureGroup(\r\n      noCaptureGroup(\r\n        SS +\r\n          noCaptureGroup(ATTRIBUTE_NAME) +\r\n          `=` +\r\n          QUOTE +\r\n          noCaptureGroup(ATTRIBUTE_VALUE) +\r\n          QUOTE\r\n      ) + \"*\"\r\n    ) + \"+\";\r\n  const TAG_OPEN = `<` + TAG_NAMES + ATTRIBUTES + S + `>`;\r\n  const TAG_CLOSE = `</${TAG_NAMES}${S}>`;\r\n\r\n  const pattern = TAG_OPEN + OR + TAG_CLOSE;\r\n\r\n  return new RegExp(pattern, \"g\");\r\n};\r\n\r\nexport const EMOJI_TAG = \"__EMOJI__\";\r\n\r\n/**\r\n * Takes a string of attributes and returns an object with key value pairs for each attribute.\r\n * Converts \"true\" | \"false\" into booleans and number-like strings into numbers.\r\n * @param attributesString  XML style attributes like \"src='/image.png' alt='foo'\"\r\n */\r\nexport const parseAttributes = (attributesString = \"\"): AttributesList => {\r\n  if (attributesString === \"\") {\r\n    return {};\r\n  }\r\n\r\n  const attributes = attributesString.trim().split(/\\s+/);\r\n\r\n  return attributes.reduce((obj: AttributesList, attribute: string) => {\r\n    const attributePair = attribute.split(\"=\");\r\n    const name = attributePair[0].trim();\r\n    const valueStr: string = attributePair[1]\r\n      .substr(1, attributePair[1].length - 2)\r\n      .trim();\r\n\r\n    obj[name] = valueStr;\r\n    return obj;\r\n  }, {});\r\n};\r\n\r\n/** Converts from RegExpExecArray to TagMatchData */\r\nexport const createTagMatchData = (match: RegExpExecArray): TagMatchData => {\r\n  const {\r\n    0: tag,\r\n    1: openTagName,\r\n    2: attributes,\r\n    3: closeTagName,\r\n    index,\r\n  } = match;\r\n  const tagName = openTagName ?? closeTagName;\r\n  const isOpening = openTagName !== undefined;\r\n  return {\r\n    tag,\r\n    tagName,\r\n    isOpening,\r\n    attributes: parseAttributes(attributes),\r\n    index,\r\n  };\r\n};\r\n\r\n/** Converts TagMatchData to TagWithAttributes */\r\nexport const tagMatchDataToTagWithAttributes = (\r\n  tag: TagMatchData\r\n): TagWithAttributes => ({\r\n  tagName: tag.tagName,\r\n  attributes: tag.attributes,\r\n});\r\n\r\n/**\r\n * Splits original text into an untagged list of string segments.\r\n * @param input Original text input\r\n * @param tagMatchData Results of regexp exect converted to tag matches.\r\n */\r\nexport const extractSegments = (\r\n  input: string,\r\n  tagMatchData: TagMatchData[]\r\n): string[] => {\r\n  const segments: string[] = [];\r\n\r\n  let remaining = input;\r\n  let offset = 0;\r\n  let tagMatch: TagMatchData;\r\n  for (tagMatch of tagMatchData) {\r\n    if (remaining !== undefined) {\r\n      const { tag, index } = tagMatch;\r\n      const startOfTag = index - offset;\r\n      const endOfTag = startOfTag + tag.length;\r\n      offset += endOfTag;\r\n\r\n      const segment = remaining.substr(0, startOfTag);\r\n      segments.push(segment);\r\n\r\n      remaining = remaining.substr(endOfTag);\r\n    }\r\n  }\r\n  segments.push(remaining);\r\n\r\n  return segments;\r\n};\r\n\r\nconst selfClosingTagSearch = (() => {\r\n  const group = (s: string) => `(${s})`;\r\n  const any = (s: string) => s + `*`;\r\n  const not = (...s: string[]) => `[^${s.join(\"\")}]`;\r\n  const WORD_START = `[A-Za-z_]`;\r\n  const WORD = `[A-Za-z0-9_]`;\r\n  const TAG_OPEN = `<`;\r\n  const TAG_SLASH = `/`;\r\n  const TAG_CLOSE = `>`;\r\n  const TAG_SELF_CLOSE = TAG_SLASH + TAG_CLOSE;\r\n\r\n  return new RegExp(\r\n    TAG_OPEN +\r\n      // tag group\r\n      group(WORD_START + any(WORD)) +\r\n      // attribute group\r\n      group(any(not(TAG_SLASH, TAG_CLOSE))) +\r\n      TAG_SELF_CLOSE,\r\n    `gs`\r\n  );\r\n})();\r\n\r\nexport const wrapEmoji = (input: string): string => {\r\n  const emojiRegex = new RegExp(\r\n    `((<|</)[^>]*)?(${getEmojiRegex().source})+`,\r\n    \"gums\"\r\n  );\r\n\r\n  return input.replaceAll(emojiRegex, (match, tagStart) => {\r\n    if (tagStart?.length > 0) {\r\n      // if the emoji is inside a tag, ignore it.\r\n      return match;\r\n    }\r\n    return `<${EMOJI_TAG}>${match}</${EMOJI_TAG}>`;\r\n  });\r\n};\r\n\r\nexport const replaceSelfClosingTags = (input: string): string =>\r\n  input.replace(selfClosingTagSearch, (_, tag, attributes = \"\") => {\r\n    let output = `<${tag}${attributes}></${tag}>`;\r\n    output = output.replace(/\\s+/g, \" \");\r\n    output = output.replace(/\\s>/g, \">\");\r\n    return output;\r\n  });\r\n\r\nexport const removeTags = (input: string): string =>\r\n  input.replace(getTagRegex(), \"\");\r\n\r\n// export const isTextToken = (token: Token): boolean => typeof token === \"string\";\r\n// export const isNewlineToken = (token: Token): boolean =>\r\n//   isWhitespaceToken(token) && token === \"\\n\";\r\n// export const isCompositeToken = (token: Token): boolean =>\r\n//   isTextToken(token) === false && \"children\" in (token as CompositeToken);\r\n\r\n// export const makeSpacesSeparateWords = (segment: string): string[] =>\r\n//   segment.replace(\" \", \"__SPACE__ __SPACE__\").split(\"__SPACE__\");\r\n\r\nexport const tagMatchToTagToken = (tag: TagMatchData): TagToken => {\r\n  return {\r\n    tag: tag.tagName,\r\n    children: [],\r\n\r\n    // Add attributes unless undefined\r\n    ...(isEmptyObject(tag.attributes) ? {} : { attributes: tag.attributes }),\r\n  };\r\n};\r\n\r\nexport const createTokensNew = (\r\n  segments: string[],\r\n  tags: TagMatchData[]\r\n): (TagToken | TextToken)[] => {\r\n  const rootTokens: CompositeToken<TagToken | TextToken> = { children: [] };\r\n  if (segments[0] !== \"\") {\r\n    rootTokens.children.push(segments[0]);\r\n  }\r\n  // Track which tags are opened and closed and add them to the list.\r\n  const tokenStack: TagToken[] = [rootTokens];\r\n\r\n  for (let i = 0; i < tags.length; i++) {\r\n    const tag = tags[i];\r\n    const segment = segments[i + 1] ?? \"\";\r\n    if (tag.isOpening) {\r\n      const token = tagMatchToTagToken(tag);\r\n      if (segment !== \"\") {\r\n        token.children.push(segment);\r\n      }\r\n      last(tokenStack).children.push(token);\r\n      tokenStack.push(token as CompositeToken<TagToken | TextToken>);\r\n    } else {\r\n      const poppedToken = tokenStack.pop();\r\n      if (poppedToken === undefined || poppedToken.tag !== tag.tagName) {\r\n        throw new Error(\r\n          `Unexpected tag nesting. Found a closing tag \"${tag.tagName}\" that doesn't match the previously open tag \"${poppedToken?.tag}\"`\r\n        );\r\n      }\r\n      if (segment !== \"\") {\r\n        last(tokenStack).children.push(segment);\r\n      }\r\n    }\r\n  }\r\n  if (tokenStack.length > 1) {\r\n    console.warn(\r\n      `Found ${tokenStack.length - 1} unclosed tags in\\n${tokenStack\r\n        .map((token) => token.tag)\r\n        .join(\"-\")}`\r\n    );\r\n  }\r\n\r\n  return rootTokens.children;\r\n};\r\n\r\nexport const containsEmoji = (input: string): boolean =>\r\n  getEmojiRegex().test(input);\r\n\r\n/**\r\n * Converts a string into a list of tokens that match segments of text with styles.\r\n *\r\n * @param input Input string with XML-style tags.\r\n * @param tagNamesToMatch Used to only tokenize tags that have styles defined for them.\r\n */\r\nexport const parseTagsNew = (\r\n  input: string,\r\n  tagNamesToMatch?: string[],\r\n  shouldWrapEmoji?: boolean\r\n): CompositeToken<TagToken | TextToken> => {\r\n  // TODO: Warn the user if tags were found that are not defined in the tagStyles.\r\n\r\n  if (shouldWrapEmoji && containsEmoji(input)) {\r\n    input = wrapEmoji(input);\r\n  }\r\n\r\n  input = replaceSelfClosingTags(input);\r\n  const re = getTagRegex(tagNamesToMatch);\r\n  const matchesRaw: RegExpExecArray[] = [];\r\n  const tagMatches: TagMatchData[] = [];\r\n  let match;\r\n  while ((match = re.exec(input))) {\r\n    matchesRaw.push(match);\r\n\r\n    const tagMatch = createTagMatchData(match);\r\n    tagMatches.push(tagMatch);\r\n  }\r\n\r\n  const segments = extractSegments(input, tagMatches);\r\n\r\n  const tokens = createTokensNew(segments, tagMatches);\r\n\r\n  return { children: tokens };\r\n};\r\n","import { Sprite } from \"@pixi/sprite\";\r\nimport { combineRecords, isDefined, pluck } from \"./functionalUtils\";\r\nimport {\r\n  AttributesList,\r\n  TagWithAttributes,\r\n  TextStyleExtended,\r\n  TextStyleSet,\r\n  IMG_REFERENCE_PROPERTY,\r\n  IMG_DISPLAY_PROPERTY,\r\n  ImageMap,\r\n  TextToken,\r\n  TagToken,\r\n  TagTokens,\r\n  StyledTokens,\r\n  StyledToken,\r\n  SpriteToken,\r\n  isEmptyObject,\r\n  TextDecorationValue,\r\n  Bounds,\r\n  TextDecorationMetrics,\r\n  Thickness,\r\n  Color,\r\n  IFontMetrics,\r\n} from \"./types\";\r\nimport { cloneSprite } from \"./pixiUtils\";\r\n\r\nexport const DEFAULT_STYLE: TextStyleExtended = {\r\n  align: \"left\",\r\n  valign: \"baseline\",\r\n  [IMG_DISPLAY_PROPERTY]: \"inline\",\r\n  wordWrap: true,\r\n  wordWrapWidth: 500,\r\n  lineSpacing: 0,\r\n  fill: 0x000000,\r\n};\r\n\r\n/**\r\n * Combine 2 styles into one.\r\n */\r\nexport const combineStyles: (\r\n  a: TextStyleExtended,\r\n  b: TextStyleExtended\r\n) => TextStyleExtended = combineRecords;\r\n\r\n/**\r\n * Combines multiple styles into one.\r\n * @param styles List of styles to combine.\r\n */\r\nexport const combineAllStyles = (\r\n  styles: (TextStyleExtended | undefined)[]\r\n): TextStyleExtended =>\r\n  (styles.filter(isDefined) as TextStyleExtended[]).reduce(combineStyles, {});\r\n\r\nexport const convertAttributeValues = (\r\n  attributes: AttributesList\r\n): AttributesList => {\r\n  const convertedAttributes: AttributesList = {};\r\n  for (const key in attributes) {\r\n    const value = attributes[key] as string;\r\n    if (isNaN(parseFloat(value)) === false) {\r\n      convertedAttributes[key] = parseFloat(value);\r\n    } else {\r\n      convertedAttributes[key] = value;\r\n    }\r\n  }\r\n  return convertedAttributes;\r\n};\r\n\r\n/**\r\n * Replaces properties of a TextStyle object with new values.\r\n * (Since AttributeLists are basically partially defined styles, this is the same as combineStyles)\r\n * @param attributes List of attributes to overwrite in the target style.\r\n * @param style The style to modify.\r\n */\r\nexport const injectAttributes = (\r\n  attributes: AttributesList = {},\r\n  style: TextStyleExtended = {}\r\n): TextStyleExtended | undefined => {\r\n  if (isEmptyObject(style) && isEmptyObject(attributes)) return undefined;\r\n  return combineRecords(style, convertAttributeValues(attributes));\r\n};\r\n\r\n/**\r\n * Looks up a tag in a list of tag styles (with optional attributes) and returns it.\r\n * @param tagName Tag name to check.\r\n * @param tagStyles Set of tag styles to search.\r\n * @param attributes Attributes to inject into the style (optional).\r\n */\r\nexport const getStyleForTag = (\r\n  tagName: string,\r\n  tagStyles: TextStyleSet,\r\n  attributes: AttributesList = {}\r\n): TextStyleExtended | undefined => {\r\n  const style = injectAttributes(attributes, tagStyles[tagName]) ?? {};\r\n  if (Object.values(style).length === 0) return undefined;\r\n  return style;\r\n};\r\n\r\n/**\r\n * Converts TagWithAttributes into a style object.\r\n * @param param0 A TagWithAttributes object that has a tag name matched with any optional attributes.\r\n * @param tagStyles Set of tag styles to search.\r\n */\r\nexport const tagWithAttributesToStyle = (\r\n  { tagName, attributes }: TagWithAttributes,\r\n  tagStyles: TextStyleSet\r\n): TextStyleExtended =>\r\n  getStyleForTag(tagName, tagStyles, attributes) as TextStyleExtended;\r\n\r\n/**\r\n * Gets styles for several tags and returns a single combined style object.\r\n * Results are cached for future requests.\r\n * @param tags Tags (with attribues) to look up.\r\n * @param tagStyles Set of tag styles to search.\r\n * @param styleCache An object that holds the cached values for the combined styles.\r\n * @returns\r\n */\r\nexport const getStyleForTags = (\r\n  tags: TagWithAttributes[],\r\n  tagStyles: TextStyleSet,\r\n  styleCache: TextStyleSet\r\n): TextStyleExtended => {\r\n  const tagHash = JSON.stringify(tags);\r\n  if (styleCache[tagHash] === undefined) {\r\n    const defaultStyle = tagStyles.default;\r\n    const styles = tags.map((tag) => tagWithAttributesToStyle(tag, tagStyles));\r\n    const stylesWithDefault = [defaultStyle, ...styles];\r\n    styleCache[tagHash] = combineAllStyles(stylesWithDefault);\r\n  }\r\n  return styleCache[tagHash];\r\n};\r\n\r\nexport const mapTagsToStyles = (\r\n  tokens: TagTokens,\r\n  styles: TextStyleSet,\r\n  spriteTemplates?: ImageMap\r\n): StyledTokens => {\r\n  const defaultStyle: TextStyleExtended = styles.default ?? {};\r\n  const tagStack: TagWithAttributes[] = [];\r\n  const styleCache = {};\r\n\r\n  const convertTagTokenToStyledToken = (\r\n    token: TagToken | TextToken\r\n  ): StyledToken | TextToken => {\r\n    if (typeof token === \"string\") {\r\n      return token as TextToken;\r\n    }\r\n\r\n    const { tag, attributes = {} } = token;\r\n    let style: TextStyleExtended = defaultStyle;\r\n    let tags = \"\";\r\n\r\n    if (tag) {\r\n      // Put the current tag on the stack.\r\n      tagStack.push({ tagName: tag, attributes });\r\n      // Get tag names as comma separates string\r\n      tags = pluck(\"tagName\")(tagStack).join(\",\");\r\n      // Merge all tags into a style object.\r\n      style = getStyleForTags(tagStack, styles, styleCache);\r\n      style = convertDecorationToLineProps(style);\r\n    }\r\n\r\n    const styledToken: StyledToken = {\r\n      style,\r\n      tags,\r\n      children: token.children.map(convertTagTokenToStyledToken),\r\n    };\r\n\r\n    // If a matching sprite exits in the imgMap...\r\n    const imgKey = style[IMG_REFERENCE_PROPERTY] ?? \"\";\r\n    if (imgKey) {\r\n      if (spriteTemplates === undefined) {\r\n        throw new Error(\r\n          `An image tag with ${IMG_REFERENCE_PROPERTY}=\"${imgKey}\" was encountered, but no imgMap was provided. Please include a valid Sprite in the imgMap property in the options in your TaggedText constructor.`\r\n        );\r\n      }\r\n      const sprite: SpriteToken | undefined = spriteTemplates[imgKey];\r\n      if (sprite === undefined) {\r\n        throw new Error(\r\n          `An image tag with ${IMG_REFERENCE_PROPERTY}=\"${imgKey}\" was encountered, but there was no matching sprite in the sprite map. Please include a valid Sprite in the imgMap property in the options in your TaggedText constructor.`\r\n        );\r\n      }\r\n      if (sprite instanceof Sprite === false) {\r\n        throw new Error(\r\n          `The image reference you provided for \"${imgKey}\" is not a Sprite. The imgMap can only accept PIXI.Sprite instances.`\r\n        );\r\n      }\r\n\r\n      // insert sprite as first token.\r\n      const cloneOfSprite = cloneSprite(sprite);\r\n      styledToken.children = [cloneOfSprite, ...styledToken.children];\r\n    }\r\n\r\n    // Remove the last tag from the stack\r\n    tagStack.pop();\r\n\r\n    return styledToken;\r\n  };\r\n\r\n  return convertTagTokenToStyledToken(tokens) as StyledTokens;\r\n};\r\n\r\nexport const convertDecorationToLineProps = (\r\n  style: TextStyleExtended\r\n): TextStyleExtended => {\r\n  const { textDecoration } = style;\r\n\r\n  if (textDecoration === undefined || textDecoration === \"normal\") {\r\n    return style;\r\n  }\r\n\r\n  const { decorationColor, decorationThickness } = style;\r\n  const defaultColor = decorationColor || style.fill || DEFAULT_STYLE.fill;\r\n  const defaultThickness = decorationThickness || 1;\r\n  const defaultOffset = 0;\r\n\r\n  function mergeDecoration(\r\n    decorationLineType: TextDecorationValue,\r\n    decorationLineTypeCamelCase: string = decorationLineType\r\n  ): Partial<TextStyleExtended> {\r\n    if (style.textDecoration?.includes(decorationLineType)) {\r\n      return {\r\n        [`${decorationLineTypeCamelCase}Color`]:\r\n          style[`${decorationLineTypeCamelCase}Color`] ?? defaultColor,\r\n        [`${decorationLineTypeCamelCase}Thickness`]:\r\n          style[`${decorationLineTypeCamelCase}Thickness`] ?? defaultThickness,\r\n        [`${decorationLineTypeCamelCase}Offset`]:\r\n          style[`${decorationLineTypeCamelCase}Offset`] ?? defaultOffset,\r\n      };\r\n    }\r\n    return {};\r\n  }\r\n\r\n  return {\r\n    ...style,\r\n    ...mergeDecoration(\"underline\"),\r\n    ...mergeDecoration(\"overline\"),\r\n    ...mergeDecoration(\"line-through\", \"lineThrough\"),\r\n  };\r\n};\r\n\r\nexport const extractDecorations = (\r\n  style: TextStyleExtended,\r\n  textBounds: Bounds,\r\n  fontProperties: IFontMetrics\r\n): TextDecorationMetrics[] => {\r\n  const { ascent, descent } = fontProperties;\r\n  const baseline = ascent;\r\n  const ascender = descent;\r\n  const xHeight = baseline - ascender;\r\n  const { width } = textBounds;\r\n  const x = 0;\r\n\r\n  function styleToMetrics(key: string): TextDecorationMetrics | undefined {\r\n    const color = style[`${key}Color`] as Color;\r\n    const height = style[`${key}Thickness`] as Thickness;\r\n    const offset = (style[`${key}Offset`] as number) ?? 0;\r\n\r\n    if (color === undefined || height === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    let y = offset;\r\n    if (key === \"underline\") {\r\n      // position underline below baseline\r\n      y += baseline + descent / 2;\r\n    } else if (key === \"lineThrough\") {\r\n      // position lineThrough in center of ascent\r\n      y += ascender + xHeight / 2;\r\n    }\r\n    // else, position overline at top of text\r\n\r\n    return {\r\n      color,\r\n      bounds: { x, y, width, height },\r\n    };\r\n  }\r\n\r\n  const keySuffices = [\"underline\", \"overline\", \"lineThrough\"];\r\n  const metrics = keySuffices\r\n    .map(styleToMetrics)\r\n    .filter((x) => x !== undefined) as TextDecorationMetrics[];\r\n  return metrics;\r\n};\r\n","import { BaseTexture, Texture } from \"@pixi/core\";\r\nimport { Rectangle as PixiRectangle } from \"@pixi/math\";\r\nimport { Sprite } from \"@pixi/sprite\";\r\nimport { TextStyle as PixiTextStyle } from \"@pixi/text\";\r\nimport { complement, flatEvery } from \"./functionalUtils\";\r\n\r\n///// GENERAL PURPOSE\r\n\r\nexport type Point = {\r\n  x: number;\r\n  y: number;\r\n};\r\nexport type Rectangle = Point & {\r\n  width: number;\r\n  height: number;\r\n};\r\n\r\nexport interface IFontMetrics {\r\n  ascent: number;\r\n  descent: number;\r\n  fontSize: number;\r\n}\r\n\r\nexport type Bounds = Rectangle;\r\n\r\nexport type Nested<T> = T | Array<Nested<T>>;\r\n\r\n///// OPTIONS\r\n\r\nexport type SpriteSource =\r\n  | string\r\n  | Texture\r\n  | HTMLCanvasElement\r\n  | HTMLVideoElement;\r\n\r\nexport type TextureSource =\r\n  | string\r\n  | HTMLImageElement\r\n  | HTMLCanvasElement\r\n  | HTMLVideoElement\r\n  | BaseTexture;\r\n\r\nexport type ImageSource = Sprite | SpriteSource | TextureSource;\r\n\r\nexport const isSpriteSource = (s: ImageSource): s is SpriteSource =>\r\n  typeof s === \"string\" ||\r\n  s instanceof Texture ||\r\n  s instanceof HTMLCanvasElement ||\r\n  s instanceof HTMLVideoElement;\r\nexport const isTextureSource = (s: ImageSource): s is TextureSource =>\r\n  s instanceof HTMLImageElement || s instanceof BaseTexture;\r\n\r\nexport type ImageSourceMap = Record<string, ImageSource>;\r\nexport type ImageMap = Record<string, Sprite>;\r\n\r\nexport type SplitStyle = \"words\" | \"characters\";\r\nexport interface TaggedTextOptions {\r\n  debug?: boolean;\r\n  debugConsole?: boolean;\r\n  splitStyle?: SplitStyle;\r\n  imgMap?: ImageSourceMap;\r\n  skipUpdates?: boolean;\r\n  skipDraw?: boolean;\r\n  drawWhitespace?: boolean;\r\n  wrapEmoji?: boolean;\r\n}\r\n\r\n///// STYLE PROPERTIES\r\n\r\n// PROPERTY NAMES\r\nexport const IMG_REFERENCE_PROPERTY = \"imgSrc\";\r\nexport const IMG_DISPLAY_PROPERTY = \"imgDisplay\";\r\n\r\n// todo: add text-transform: uppercase\r\nexport type Thickness = number;\r\nexport type Color = string | number;\r\nexport type Fill = Color | string[] | number[] | CanvasGradient | CanvasPattern;\r\nexport type VAlign = \"top\" | \"middle\" | \"bottom\" | \"baseline\" | number;\r\nexport type Align = \"left\" | \"right\" | \"center\" | \"justify\";\r\nexport type ImageDisplayMode = \"icon\" | \"block\" | \"inline\";\r\nexport type ImageReference = string;\r\nexport type ImageDimensionPercentage = string;\r\nexport type ImageDimension = number | string | ImageDimensionPercentage;\r\nexport type TextTransform = \"normal\" | \"capitalize\" | \"uppercase\" | \"lowercase\";\r\nexport type FontStyle = \"normal\" | \"italic\" | \"oblique\";\r\nexport type TextDecorationValue = \"underline\" | \"overline\" | \"line-through\";\r\nexport type TextDecoration =\r\n  | \"normal\"\r\n  | TextDecorationValue\r\n  | `${TextDecorationValue} ${TextDecorationValue}`\r\n  | `${TextDecorationValue} ${TextDecorationValue} ${TextDecorationValue}`;\r\n\r\nexport interface TextStyle\r\n  extends Record<string, unknown>,\r\n    Partial<PixiTextStyle> {\r\n  align?: Align;\r\n  fontStyle?: FontStyle;\r\n}\r\n\r\nexport interface ImageStyles {\r\n  [IMG_REFERENCE_PROPERTY]?: ImageReference;\r\n  [IMG_DISPLAY_PROPERTY]?: ImageDisplayMode;\r\n  imgScale?: ImageDimensionPercentage;\r\n  imgScaleX?: ImageDimensionPercentage;\r\n  imgScaleY?: ImageDimensionPercentage;\r\n  imgWidth?: ImageDimension;\r\n  imgHeight?: ImageDimension;\r\n}\r\n\r\nexport interface UnderlineStyle {\r\n  underlineColor?: Color;\r\n  underlineThickness?: Thickness;\r\n  underlineOffset?: number;\r\n}\r\nexport interface OverlineStyle {\r\n  overlineColor?: Color;\r\n  overlineThickness?: Thickness;\r\n  overlineOffset?: number;\r\n}\r\nexport interface LineThroughStyle {\r\n  lineThroughColor?: Color;\r\n  lineThroughThickness?: Thickness;\r\n  lineThroughOffset?: number;\r\n}\r\n\r\nexport interface TextDecorationStyles\r\n  extends UnderlineStyle,\r\n    OverlineStyle,\r\n    LineThroughStyle {}\r\nexport interface TextStyleExtended\r\n  extends TextStyle,\r\n    ImageStyles,\r\n    TextDecorationStyles {\r\n  lineSpacing?: number;\r\n  valign?: VAlign;\r\n  textTransform?: TextTransform;\r\n  textDecoration?: TextDecoration;\r\n  fontScaleWidth?: number;\r\n  fontScaleHeight?: number;\r\n}\r\n\r\nexport interface TextDecorationMetrics {\r\n  color: Color;\r\n  bounds: Bounds;\r\n}\r\n\r\nexport type TextStyleSet = Record<string, TextStyleExtended>;\r\n\r\n///// TAG PARSING\r\n\r\ntype TagName = string;\r\ntype AttributeName = string;\r\ntype AttributeValue = string | number;\r\nexport type AttributesList = Record<AttributeName, AttributeValue>;\r\nexport interface TagWithAttributes {\r\n  tagName: string;\r\n  attributes: AttributesList;\r\n}\r\n\r\nexport interface TagMatchData extends TagWithAttributes {\r\n  tag: string;\r\n  isOpening: boolean;\r\n  index: number;\r\n}\r\nexport type TagStack = TagMatchData[];\r\n\r\n///// PARSED TOKENS\r\n\r\nexport type NewlineToken = \"\\n\";\r\nexport type WhitespaceToken = \" \" | \"\\t\" | NewlineToken;\r\nexport type TextToken = string;\r\nexport type SpriteToken = Sprite;\r\n\r\nexport interface CompositeToken<T extends Token = Token> {\r\n  children: T[];\r\n}\r\n\r\nexport type Token = TextToken | CompositeToken | SpriteToken;\r\nexport type Tokens = CompositeToken;\r\n\r\nexport interface TagToken extends CompositeToken<TagToken | TextToken> {\r\n  tag?: TagName;\r\n  attributes?: AttributesList;\r\n}\r\nexport type TagTokens = TagToken;\r\n\r\nexport interface StyledToken\r\n  extends CompositeToken<StyledToken | TextToken | SpriteToken> {\r\n  style: TextStyleExtended;\r\n  tags: string;\r\n}\r\n\r\nexport type StyledTokens = StyledToken;\r\nexport interface FinalToken {\r\n  content: TextToken | SpriteToken;\r\n  bounds: Rectangle;\r\n  fontProperties: IFontMetrics;\r\n  style: TextStyleExtended;\r\n  tags: string;\r\n  textDecorations?: TextDecorationMetrics[];\r\n}\r\n\r\nexport const createEmptyFinalToken = (): FinalToken => ({\r\n  content: \"\",\r\n  bounds: new PixiRectangle(),\r\n  fontProperties: { ascent: 0, descent: 0, fontSize: 0 },\r\n  style: {},\r\n  tags: \"\",\r\n  textDecorations: [],\r\n});\r\n\r\nexport type WordToken = FinalToken[];\r\nexport type LineToken = WordToken[];\r\nexport type ParagraphToken = LineToken[];\r\n\r\nexport interface SpriteFinalToken extends FinalToken {\r\n  content: SpriteToken;\r\n}\r\nexport interface TextFinalToken extends FinalToken {\r\n  content: TextToken;\r\n}\r\n\r\nexport interface WhitespaceFinalToken extends TextFinalToken {\r\n  content: WhitespaceToken;\r\n}\r\nexport interface NewlineFinalToken extends TextFinalToken {\r\n  content: NewlineToken;\r\n}\r\n\r\nexport const isWhitespace = (s: string): s is WhitespaceToken =>\r\n  s !== \"\" &&\r\n  s.split(\"\").every((char: string): boolean => char.search(/\\s/) === 0);\r\nexport const isNewline = (s: string): s is NewlineToken =>\r\n  isWhitespace(s) && s === \"\\n\";\r\n\r\nexport const _isSpriteToken = (t: FinalToken): t is SpriteFinalToken =>\r\n  t.content instanceof Sprite;\r\nexport const isSpriteToken = flatEvery(_isSpriteToken);\r\n\r\nexport const _isTextToken = (t: FinalToken): t is TextFinalToken =>\r\n  typeof t.content === \"string\";\r\nexport const isTextToken = flatEvery(_isTextToken);\r\n\r\nexport const _isWhitespaceToken = (t: FinalToken): t is WhitespaceFinalToken =>\r\n  t !== undefined && _isTextToken(t) && isWhitespace(t.content);\r\nexport const isWhitespaceToken = flatEvery(_isWhitespaceToken);\r\n\r\nexport const _isNewlineToken = (t: FinalToken): t is NewlineFinalToken =>\r\n  t !== undefined && _isTextToken(t) && isNewline(t.content);\r\nexport const isNewlineToken = (t?: Nested<FinalToken>): boolean =>\r\n  t === undefined ? false : flatEvery(_isNewlineToken)(t);\r\n\r\nexport const isNotWhitespaceToken = complement(isWhitespaceToken);\r\n\r\nexport const isEmptyObject = <T extends unknown>(a: T): boolean =>\r\n  a instanceof Object && Object.keys(a).length === 0;\r\n","// modified from: https://github.com/h26k2/capitalize-text/blob/master/index.js\r\nexport const capitalize = (str: string): string => {\r\n  const chars = str.split(\" \");\r\n  let converted = ``;\r\n\r\n  for (let i = 0; i < chars.length; i++) {\r\n    converted += `${chars[i].charAt(0).toUpperCase()}${chars[i].substr(1)} `;\r\n  }\r\n\r\n  return converted.trim();\r\n};\r\n","import { Container, DisplayObject } from \"@pixi/display\";\r\nimport { ICanvasRenderingContext2D } from '@pixi/settings';\r\nimport { Sprite } from \"@pixi/sprite\";\r\nimport { Text, TextMetrics } from \"@pixi/text\";\r\nimport { IFontMetrics } from \"./types\";\r\n\r\nconst PX_PER_EM = 16;\r\nconst PX_PER_PERCENT = 16 / 100;\r\nconst PX_PER_PT = 1.3281472327365;\r\n\r\nexport const measureFont = (context: ICanvasRenderingContext2D): IFontMetrics =>\r\n  TextMetrics.measureFont(context.font);\r\n\r\nexport const INITIAL_FONT_PROPS: IFontMetrics = {\r\n  ascent: 10,\r\n  descent: 2,\r\n  fontSize: 12,\r\n};\r\n\r\n// TODO: Memoize\r\nexport const getFontPropertiesOfText = (\r\n  textField: Text,\r\n  forceUpdate = false\r\n): IFontMetrics => {\r\n  if (forceUpdate) {\r\n    textField.updateText(false);\r\n    return measureFont(textField.context);\r\n  } else {\r\n    const props = measureFont(textField.context);\r\n    const fs = textField.style.fontSize ?? NaN;\r\n    if (\r\n      props.ascent === INITIAL_FONT_PROPS.ascent &&\r\n      props.descent === INITIAL_FONT_PROPS.descent &&\r\n      (isNaN(Number(fs)) || fs as number > INITIAL_FONT_PROPS.fontSize)\r\n    ) {\r\n      throw new Error(\r\n        \"getFontPropertiesOfText() returned metrics associated with a Text field that has not been updated yet. Please try using the forceUpdate parameter when you call this function.\"\r\n      );\r\n    }\r\n    return measureFont(textField.context);\r\n  }\r\n};\r\n\r\nexport const checkPixiVersion = (\r\n  version: string,\r\n  expectedMajorVersion: number\r\n): number => {\r\n  const majorVersion = parseInt(version.split(\".\")[0], 10);\r\n  if (majorVersion !== expectedMajorVersion) {\r\n    throw new Error(\r\n      `Detected Pixi.js version ${version}. pixi-multistyle-text supports Pixi.js version ${expectedMajorVersion}. (Please use v0.8.0 of this package for Pixi 4 support.)`\r\n    );\r\n  }\r\n  return 0;\r\n};\r\n\r\nexport const addChildrenToContainer = (\r\n  children: DisplayObject[],\r\n  container: Container\r\n): void => children.forEach((child) => container.addChild(child));\r\n\r\nexport const cloneSprite = (sprite: Sprite): Sprite =>\r\n  new Sprite(sprite.texture);\r\n\r\nexport const fontSizeStringToNumber = (size: string): number => {\r\n  const [valueString, unit] = size.split(/(%|pt|px|r?em)/);\r\n  const value = parseFloat(valueString);\r\n\r\n  if (isNaN(value)) {\r\n    NaN;\r\n  }\r\n\r\n  switch (unit) {\r\n    case \"%\":\r\n      return value * PX_PER_PERCENT;\r\n    case \"em\":\r\n    case \"rem\":\r\n      return value * PX_PER_EM;\r\n    case \"pt\":\r\n      return value * PX_PER_PT;\r\n    case \"px\":\r\n    default:\r\n      // keep as is.\r\n      return value;\r\n  }\r\n};\r\n","import { Container } from \"@pixi/display\";\r\nimport { Point as PixiPoint, Rectangle } from \"@pixi/math\";\r\nimport { Sprite } from \"@pixi/sprite\";\r\nimport { Text as PixiText } from \"@pixi/text\";\r\nimport {\r\n  assoc,\r\n  first,\r\n  flatReduce,\r\n  last,\r\n  mapProp,\r\n  Unary,\r\n} from \"./functionalUtils\";\r\nimport { getFontPropertiesOfText } from \"./pixiUtils\";\r\nimport { capitalize } from \"./stringUtil\";\r\nimport { extractDecorations } from \"./style\";\r\nimport {\r\n  Align,\r\n  Bounds,\r\n  createEmptyFinalToken,\r\n  FinalToken,\r\n  IFontMetrics,\r\n  IMG_DISPLAY_PROPERTY,\r\n  isNewlineToken,\r\n  isNotWhitespaceToken,\r\n  isSpriteToken,\r\n  isWhitespaceToken,\r\n  LineToken,\r\n  Nested,\r\n  ParagraphToken,\r\n  Point,\r\n  SplitStyle,\r\n  SpriteToken,\r\n  StyledToken,\r\n  StyledTokens,\r\n  TextStyleExtended,\r\n  TextToken,\r\n  VAlign,\r\n  WordToken,\r\n} from \"./types\";\r\n\r\nconst ICON_SCALE_BASE = 0.8;\r\n\r\n/**\r\n * Translates the current location point to the beginning of the next line.\r\n *\r\n * @param offset An offset coordinate. The function will make a clone of this with new coordinates.\r\n * @param largestLineHeight The largest height in the line of text.\r\n * @param lineSpacing The amount of extra space to insert between each line.\r\n */\r\nexport const updateOffsetForNewLine = (\r\n  offset: Point,\r\n  largestLineHeight: number,\r\n  lineSpacing: number\r\n): Point => new PixiPoint(0, offset.y + largestLineHeight + lineSpacing);\r\n\r\nconst rectFromContainer = (\r\n  container: Container,\r\n  offset: Point = { x: 0, y: 0 }\r\n): Bounds => {\r\n  const w = container.width;\r\n  const h = container.height;\r\n  const x = offset.x + container.x;\r\n  const y = offset.y + container.y;\r\n\r\n  return new Rectangle(x, y, w, h);\r\n};\r\n\r\n/**\r\n * Move a point by an offset.\r\n * Point p => p -> p-> -> p\r\n * @param offset Amount to translate the target.\r\n * @param point Target to translate.\r\n */\r\nexport const translatePoint =\r\n  <P extends Point>(offset: Point) =>\r\n  (point: P): P => ({\r\n    ...point,\r\n    x: point.x + offset.x,\r\n    y: point.y + offset.y,\r\n  });\r\n\r\n/**\r\n * Same as translatePoint but for all the points in an array.\r\n */\r\nexport const translateLine =\r\n  (offset: Point) =>\r\n  (line: Bounds[]): Bounds[] =>\r\n    line.map(translatePoint(offset));\r\n\r\nexport const translateWordPosition =\r\n  (offset: Point) =>\r\n  (word: WordToken): WordToken =>\r\n    word.map((token) =>\r\n      mapProp<Bounds, FinalToken>(\"bounds\")(translatePoint(offset))(token)\r\n    );\r\n\r\nexport const translateTokenLine =\r\n  (offset: Point) =>\r\n  (line: LineToken): LineToken =>\r\n    line.map(translateWordPosition(offset));\r\n\r\nexport const lineWidth = (wordsInLine: Bounds[]): number => {\r\n  const firstWord = first(wordsInLine);\r\n  const lastWord = last(wordsInLine);\r\n\r\n  if (firstWord === undefined) {\r\n    return 0;\r\n  }\r\n  if (lastWord === firstWord) {\r\n    return firstWord.width;\r\n  }\r\n  return lastWord.x + lastWord.width - firstWord.x;\r\n};\r\n\r\nexport const center = (x: number, context: number): number => (context - x) / 2;\r\n\r\nconst setBoundsX = assoc<Bounds, number>(\"x\");\r\n\r\nconst positionWordX =\r\n  (x: number) =>\r\n  (word: WordToken): WordToken => {\r\n    let prevBounds: Bounds;\r\n    return word.map((token) => {\r\n      if (prevBounds === undefined) {\r\n        token.bounds.x = x;\r\n        prevBounds = token.bounds;\r\n      } else {\r\n        token.bounds.x = prevBounds.x + prevBounds.width;\r\n        prevBounds = token.bounds;\r\n      }\r\n      return token;\r\n    });\r\n  };\r\n\r\nexport const concatBounds = (\r\n  originalBounds: Bounds = { x: NaN, y: NaN, width: NaN, height: NaN },\r\n  bounds: Bounds = { x: NaN, y: NaN, width: NaN, height: NaN }\r\n): Bounds => {\r\n  if (isNaN(originalBounds.x)) {\r\n    return bounds;\r\n  }\r\n\r\n  const x = Math.min(originalBounds.x, bounds.x);\r\n  const y = Math.min(originalBounds.y, bounds.y);\r\n  const right = Math.max(\r\n    originalBounds.x + originalBounds.width,\r\n    bounds.x + bounds.width\r\n  );\r\n  const bottom = Math.max(\r\n    originalBounds.y + originalBounds.height,\r\n    bounds.y + bounds.height\r\n  );\r\n  const width = right - x;\r\n  const height = bottom - y;\r\n\r\n  return { x, y, width, height };\r\n};\r\n\r\nconst getCombinedBounds = (bounds: Bounds[]): Bounds =>\r\n  bounds.reduce(concatBounds);\r\n\r\nexport const getBoundsNested: Unary<Nested<FinalToken>, Bounds> = flatReduce<\r\n  FinalToken,\r\n  Bounds\r\n>((acc: Bounds, t: FinalToken) => concatBounds(acc, t.bounds), {\r\n  x: NaN,\r\n  y: NaN,\r\n  width: NaN,\r\n  height: NaN,\r\n});\r\n\r\nexport const alignLeft = (line: Bounds[]): Bounds[] =>\r\n  line.reduce(\r\n    (newLine: Bounds[], bounds: Bounds, i: number): Bounds[] =>\r\n      // is first word?\r\n      i === 0\r\n        ? [setBoundsX(0)(bounds)]\r\n        : newLine.concat([\r\n            setBoundsX(newLine[i - 1].x + newLine[i - 1].width)(bounds),\r\n          ]),\r\n    []\r\n  );\r\n\r\nexport const alignRight =\r\n  (maxWidth: number) =>\r\n  (line: Bounds[]): Bounds[] =>\r\n    translateLine({\r\n      x: maxWidth - lineWidth(line),\r\n      y: 0,\r\n    })(alignLeft(line));\r\n\r\nexport const alignCenter =\r\n  (maxWidth: number) =>\r\n  (line: Bounds[]): Bounds[] =>\r\n    translateLine({ x: center(lineWidth(line), maxWidth), y: 0 })(\r\n      alignLeft(line)\r\n    );\r\n\r\nexport const alignJustify =\r\n  (maxLineWidth: number) =>\r\n  (line: Bounds[]): Bounds[] => {\r\n    const count = line.length;\r\n    if (count === 0) {\r\n      return [];\r\n    }\r\n\r\n    const nonZeroWidthWords: Bounds[] = line.filter(({ width }) => width > 0);\r\n    const countNonZeroWidthWords = nonZeroWidthWords.length;\r\n\r\n    if (countNonZeroWidthWords === 1) {\r\n      const [first, ...rest] = line;\r\n      first.x = 0;\r\n      return [first, ...rest];\r\n    }\r\n\r\n    const result: Bounds[] = [];\r\n    const combinedBounds = getCombinedBounds(nonZeroWidthWords);\r\n    const w = combinedBounds.width;\r\n    const totalSpace = maxLineWidth - w;\r\n    const spacerWidth = totalSpace / (countNonZeroWidthWords - 1);\r\n\r\n    let previousWord;\r\n    for (let i = 0; i < line.length; i++) {\r\n      const bounds = line[i];\r\n      if (bounds.width === 0) {\r\n        result[i] = { ...bounds };\r\n        continue;\r\n      }\r\n      let x;\r\n      if (previousWord === undefined) {\r\n        x = 0;\r\n      } else {\r\n        x = previousWord.x + previousWord.width + spacerWidth;\r\n      }\r\n      if (isNaN(x)) {\r\n        throw new Error(\r\n          `Something went wrong with the justified layout calculation. x is NaN.`\r\n        );\r\n      }\r\n      const newWord: Bounds = setBoundsX(x)(bounds);\r\n      previousWord = newWord;\r\n      result[i] = newWord;\r\n    }\r\n    return result;\r\n  };\r\n\r\nexport const alignLines = (\r\n  align: Align,\r\n  maxWidth: number,\r\n  lines: ParagraphToken\r\n): ParagraphToken => {\r\n  // do horizontal alignment.\r\n  let alignFunction: (l: Bounds[]) => Bounds[];\r\n  switch (align) {\r\n    case \"left\":\r\n      alignFunction = alignLeft;\r\n      break;\r\n    case \"right\":\r\n      alignFunction = alignRight(maxWidth);\r\n      break;\r\n    case \"center\":\r\n      alignFunction = alignCenter(maxWidth);\r\n      break;\r\n    case \"justify\":\r\n      alignFunction = alignJustify(maxWidth);\r\n      break;\r\n    default:\r\n      throw new Error(\r\n        `Unsupported alignment type ${align}! Use one of : \"left\", \"right\", \"center\", \"justify\"`\r\n      );\r\n  }\r\n\r\n  for (const line of lines) {\r\n    const wordBoundsForLine: Bounds[] = [];\r\n    for (const word of line) {\r\n      const wordBounds = getBoundsNested(word);\r\n      wordBoundsForLine.push(wordBounds);\r\n      if (isNaN(wordBounds.x)) {\r\n        throw new Error(\"wordBounds not correct\");\r\n      }\r\n    }\r\n    const alignedLine = alignFunction(wordBoundsForLine);\r\n    for (let i = 0; i < line.length; i++) {\r\n      const bounds = alignedLine[i];\r\n      const word = line[i];\r\n      line[i] = positionWordX(bounds.x)(word);\r\n    }\r\n  }\r\n  return lines;\r\n};\r\n\r\nconst getTallestToken = (line: LineToken): FinalToken =>\r\n  flatReduce<FinalToken, FinalToken>((tallest, current) => {\r\n    let h = current.bounds.height ?? 0;\r\n    if (isSpriteToken(current)) {\r\n      h += current.fontProperties.descent;\r\n    }\r\n    if (h > (tallest?.bounds.height ?? 0)) {\r\n      return current;\r\n    }\r\n    return tallest;\r\n  }, createEmptyFinalToken())(line);\r\n\r\n/**\r\n * @param If you want to override the valign from the styles object, set it here.\r\n */\r\nexport const verticalAlignInLines = (\r\n  lines: ParagraphToken,\r\n  lineSpacing: number,\r\n  overrideValign?: VAlign\r\n): ParagraphToken => {\r\n  let previousTallestToken: FinalToken = createEmptyFinalToken();\r\n\r\n  let previousLineBottom = 0;\r\n  const newLines: ParagraphToken = [];\r\n\r\n  for (const line of lines) {\r\n    const newLine: LineToken = [];\r\n    // const nonZeroWidthWords: Bounds[] = line.filter(({ width }) => width > 0);\r\n\r\n    let tallestToken: FinalToken = getTallestToken(line);\r\n    let tallestHeight = tallestToken.bounds?.height ?? 0;\r\n    let tallestAscent = tallestToken.fontProperties?.ascent ?? 0;\r\n    if (isSpriteToken(tallestToken)) {\r\n      tallestHeight += tallestToken.fontProperties.descent;\r\n      tallestAscent = tallestToken.bounds.height;\r\n    }\r\n\r\n    // const previousTallestHeight = previousTallestToken.bounds.height;\r\n\r\n    // if (line.length === 1 && isWhitespaceToken(line[0])) {\r\n    //   tallestHeight = previousTallestHeight;\r\n    // }\r\n\r\n    if (tallestHeight === 0) {\r\n      tallestToken = previousTallestToken;\r\n    } else {\r\n      previousTallestToken = tallestToken;\r\n    }\r\n\r\n    for (const word of line) {\r\n      const newWord: WordToken = [];\r\n      for (const segment of word) {\r\n        if (isNewlineToken(segment)) {\r\n          const newToken = {\r\n            ...segment,\r\n          };\r\n          newWord.push(newToken);\r\n          continue;\r\n        }\r\n        const { bounds, fontProperties, style } = segment;\r\n        const height = bounds.height;\r\n\r\n        const newBounds: Bounds = { ...bounds };\r\n        const valign = overrideValign ?? style.valign;\r\n\r\n        let { ascent } = fontProperties;\r\n        if (isSpriteToken(segment)) {\r\n          ascent = segment.bounds.height;\r\n        }\r\n\r\n        let newY = 0;\r\n        switch (valign) {\r\n          case \"bottom\":\r\n            newY = previousLineBottom + tallestHeight - height;\r\n            break;\r\n          case \"middle\":\r\n            newY = previousLineBottom + (tallestHeight - height) / 2;\r\n            break;\r\n          case \"top\":\r\n            newY = previousLineBottom;\r\n            break;\r\n          case \"baseline\":\r\n          default:\r\n            newY = previousLineBottom + tallestAscent - ascent;\r\n        }\r\n\r\n        newBounds.y = newY;\r\n\r\n        const newToken = {\r\n          ...segment,\r\n          bounds: newBounds,\r\n        };\r\n        newWord.push(newToken);\r\n      }\r\n      newLine.push(newWord);\r\n    }\r\n\r\n    previousLineBottom += tallestHeight + lineSpacing;\r\n    newLines.push(newLine);\r\n  }\r\n\r\n  return newLines;\r\n\r\n  // ? lines.map(valignTop)\r\n  //   : valign === \"middle\"\r\n  //   ? lines.map(valignMiddle)\r\n  //   : valign === \"bottom\"\r\n  //   ? lines.map(valignBottom)\r\n  //   : lines;\r\n};\r\n\r\nexport const collapseWhitespacesOnEndOfLines = (\r\n  lines: ParagraphToken\r\n): ParagraphToken => {\r\n  for (const line of lines) {\r\n    const l = line.length;\r\n    let i = l;\r\n    while (i >= 0) {\r\n      i -= 1;\r\n      const word = line[i];\r\n      if (isNotWhitespaceToken(word)) {\r\n        break;\r\n      } else {\r\n        for (const token of word) {\r\n          token.bounds.width = 0;\r\n          token.bounds.height = Math.min(\r\n            token.bounds.height,\r\n            token.fontProperties.fontSize\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return lines;\r\n};\r\n\r\nconst layout = (\r\n  tokens: FinalToken[],\r\n  maxWidth: number,\r\n  lineSpacing: number,\r\n  align: Align\r\n): ParagraphToken => {\r\n  const cursor = { x: 0, y: 0 };\r\n  let wordWidth = 0;\r\n  let word: WordToken = [];\r\n  let line: LineToken = [];\r\n  const allLines: ParagraphToken = [];\r\n  let tallestHeightInLine = 0;\r\n\r\n  function addWordBufferToLineBuffer() {\r\n    if (word !== undefined && word.length > 0) {\r\n      // add word to line\r\n      line.push(word);\r\n    }\r\n\r\n    // reset word buffer\r\n    word = [];\r\n    wordWidth = 0;\r\n  }\r\n\r\n  function addLineToListOfLines() {\r\n    allLines.push(line);\r\n    line = [];\r\n  }\r\n\r\n  function addLineToListOfLinesAndMoveCursorToNextLine(token: FinalToken) {\r\n    // finalize Line\r\n    addLineToListOfLines();\r\n\r\n    // move cursor to next line\r\n    cursor.x = 0;\r\n    cursor.y = cursor.y + tallestHeightInLine;\r\n\r\n    // reset tallestHeight\r\n    tallestHeightInLine = 0;\r\n    setTallestHeight(token);\r\n  }\r\n\r\n  function setTallestHeight(token?: FinalToken): void {\r\n    const fontSize = token?.fontProperties?.fontSize ?? 0;\r\n    const height = token?.bounds?.height ?? 0;\r\n\r\n    tallestHeightInLine = Math.max(tallestHeightInLine, fontSize, lineSpacing);\r\n    // Don't try to measure the height of newline tokens\r\n    if (isNewlineToken(token) === false) {\r\n      tallestHeightInLine = Math.max(tallestHeightInLine, height);\r\n    }\r\n  }\r\n\r\n  function positionTokenAtCursorAndAdvanceCursor(token: FinalToken): void {\r\n    // position token at cursor\r\n    setTallestHeight(token);\r\n    token.bounds.x = cursor.x;\r\n    token.bounds.y = cursor.y;\r\n    // advance cursor\r\n    cursor.x += token.bounds.width;\r\n  }\r\n\r\n  function positionWordBufferAtCursorAndAdvanceCursor(): void {\r\n    word.forEach(positionTokenAtCursorAndAdvanceCursor);\r\n  }\r\n\r\n  function wordInBufferExceedsLineLength(): boolean {\r\n    return cursor.x + wordWidth > maxWidth;\r\n  }\r\n\r\n  function isBlockImage(token: FinalToken): boolean {\r\n    return token.style[IMG_DISPLAY_PROPERTY] === \"block\";\r\n  }\r\n\r\n  function addTokenToWordAndUpdateWordWidth(token: FinalToken): void {\r\n    // add the token to the current word buffer.\r\n    word.push(token);\r\n    wordWidth += token.bounds.width;\r\n  }\r\n\r\n  let token;\r\n  for (let i = 0; i < tokens.length; i++) {\r\n    token = tokens[i];\r\n    const isWhitespace = isWhitespaceToken(token);\r\n    const isNewline = isNewlineToken(token);\r\n    const isImage = isSpriteToken(token);\r\n    const isWordEndingToken = isWhitespace || isImage;\r\n\r\n    if (isWordEndingToken) {\r\n      positionWordBufferAtCursorAndAdvanceCursor();\r\n      addWordBufferToLineBuffer();\r\n    }\r\n\r\n    addTokenToWordAndUpdateWordWidth(token);\r\n    setTallestHeight(token);\r\n\r\n    // always immediately add whitespace to the line.\r\n    if (isWhitespace) {\r\n      positionWordBufferAtCursorAndAdvanceCursor();\r\n      addWordBufferToLineBuffer();\r\n    }\r\n\r\n    // If the token is a newline character,\r\n    // move the cursor to next line immediately\r\n    if (isNewline || isBlockImage(token)) {\r\n      addLineToListOfLinesAndMoveCursorToNextLine(token);\r\n    } else if (wordInBufferExceedsLineLength()) {\r\n      // don't wrap if it's the first word in the line.\r\n      if (line.length > 0) {\r\n        addLineToListOfLinesAndMoveCursorToNextLine(token);\r\n      }\r\n    }\r\n  }\r\n\r\n  // After we reach the last token, add it to the word and finalize both buffers.\r\n  if (word.length > 0) {\r\n    positionWordBufferAtCursorAndAdvanceCursor();\r\n    addWordBufferToLineBuffer();\r\n  }\r\n  if (line.length > 0) {\r\n    addLineToListOfLines();\r\n  }\r\n\r\n  const collapsedWhitespace = collapseWhitespacesOnEndOfLines(allLines);\r\n  const alignedLines = alignLines(align, maxWidth, collapsedWhitespace);\r\n  const valignedLines = verticalAlignInLines(alignedLines, lineSpacing);\r\n\r\n  return valignedLines;\r\n};\r\n\r\nconst notEmptyString = (s: string) => s !== \"\";\r\n\r\nconst SPLIT_MARKER = `__`;\r\nexport const splitAroundWhitespace = (s: string): string[] =>\r\n  s\r\n    .replace(/\\s/g, `${SPLIT_MARKER}$&${SPLIT_MARKER}`)\r\n    .split(SPLIT_MARKER)\r\n    .filter((s) => s !== \"\");\r\n\r\nexport const splitText = (s: string, splitStyle: SplitStyle): string[] => {\r\n  if (splitStyle === \"words\") {\r\n    return [s].flatMap(splitAroundWhitespace).filter(notEmptyString);\r\n  } else if (splitStyle === \"characters\") {\r\n    return s.split(\"\");\r\n  } else {\r\n    // unsupported splitStyle.\r\n    let suggestion = ` Supported styles are \"words\" and \"characters\"`;\r\n    const badStyle = (splitStyle as string).toLowerCase();\r\n    if (badStyle.indexOf(\"char\") === 0) {\r\n      suggestion = `Did you mean \"characters\"?`;\r\n    } else if (badStyle.indexOf(\"wor\") === 0) {\r\n      suggestion = `Did you mean \"words\"?`;\r\n    }\r\n    throw new Error(`Unsupported split style \"${splitStyle}\". ${suggestion}`);\r\n  }\r\n};\r\n\r\nexport const calculateFinalTokens = (\r\n  styledTokens: StyledTokens,\r\n  splitStyle: SplitStyle = \"words\"\r\n): ParagraphToken => {\r\n  // Create a text field to use for measurements.\r\n  const sizer = new PixiText(\"\");\r\n  const defaultStyle = styledTokens.style;\r\n\r\n  let fontProperties: IFontMetrics;\r\n\r\n  const generateFinalTokenFromStyledToken =\r\n    (style: TextStyleExtended, tags: string) =>\r\n    (token: StyledToken | TextToken | SpriteToken): FinalToken[] => {\r\n      let output: FinalToken[] = [];\r\n\r\n      sizer.style = {\r\n        ...style,\r\n        // Override some styles for the purposes of sizing text.\r\n        wordWrap: false,\r\n        dropShadowBlur: 0,\r\n        dropShadowDistance: 0,\r\n        dropShadowAngle: 0,\r\n        dropShadow: false,\r\n      };\r\n\r\n      if (typeof token === \"string\") {\r\n        // split into pieces and convert into tokens.\r\n\r\n        const textSegments = splitText(token, splitStyle);\r\n\r\n        const textTokens = textSegments.map((str): FinalToken => {\r\n          switch (style.textTransform) {\r\n            case \"uppercase\":\r\n              sizer.text = str.toUpperCase();\r\n              break;\r\n            case \"lowercase\":\r\n              sizer.text = str.toLowerCase();\r\n              break;\r\n            case \"capitalize\":\r\n              sizer.text = capitalize(str);\r\n              break;\r\n            default:\r\n              sizer.text = str;\r\n          }\r\n\r\n          const sw = style.fontScaleWidth ?? 1.0;\r\n          const sh = style.fontScaleHeight ?? 1.0;\r\n          // clamp negative or NaN fontScales to 0\r\n          const scaleWidth = isNaN(sw) || sw < 0 ? 0.0 : sw;\r\n          const scaleHeight = isNaN(sh) || sh < 0 ? 0.0 : sh;\r\n\r\n          sizer.scale.set(scaleWidth, scaleHeight);\r\n\r\n          fontProperties = { ...getFontPropertiesOfText(sizer, true) };\r\n          fontProperties.ascent *= scaleHeight;\r\n          fontProperties.descent *= scaleHeight;\r\n          fontProperties.fontSize *= scaleHeight;\r\n\r\n          const bounds = rectFromContainer(sizer);\r\n\r\n          // Incorporate the size of the stroke into the size of the text.\r\n          const stroke = sizer.style.strokeThickness ?? 0;\r\n          if (stroke > 0) {\r\n            fontProperties.descent += stroke / 2;\r\n            fontProperties.ascent += stroke / 2;\r\n            fontProperties.fontSize =\r\n              fontProperties.ascent + fontProperties.descent;\r\n          }\r\n\r\n          const textDecorations = extractDecorations(\r\n            style,\r\n            bounds,\r\n            fontProperties\r\n          );\r\n\r\n          return {\r\n            content: str,\r\n            style,\r\n            tags,\r\n            bounds,\r\n            fontProperties,\r\n            textDecorations,\r\n          };\r\n        });\r\n\r\n        output = output.concat(textTokens);\r\n      } else if (token instanceof Sprite) {\r\n        const sprite = token;\r\n        const imgDisplay = style[IMG_DISPLAY_PROPERTY];\r\n        // const isBlockImage = imgDisplay === \"block\";\r\n        const isIcon = imgDisplay === \"icon\";\r\n        fontProperties = { ...getFontPropertiesOfText(sizer, true) };\r\n\r\n        if (isIcon) {\r\n          // Set to minimum of 1 to avoid devide by zero.\r\n          // if it's height is zero or one it probably hasn't loaded yet.\r\n          // It will get refreshed after it loads.\r\n          const h = Math.max(sprite.height, 1);\r\n\r\n          if (h > 1 && sprite.scale.y === 1) {\r\n            const ratio = (fontProperties.ascent / h) * ICON_SCALE_BASE;\r\n            sprite.scale.set(ratio);\r\n          }\r\n        }\r\n\r\n        // handle images\r\n        const bounds = rectFromContainer(sprite);\r\n        output.push({\r\n          content: sprite,\r\n          style,\r\n          tags,\r\n          bounds,\r\n          fontProperties,\r\n          textDecorations: undefined,\r\n        });\r\n      } else {\r\n        // token is a composite\r\n        const styledToken = token as StyledToken;\r\n        const { children } = styledToken;\r\n        // set tags and styles for children of this composite token.\r\n        const newStyle = styledToken.style;\r\n        const newTags = styledToken.tags;\r\n\r\n        if (newStyle === undefined) {\r\n          throw new Error(\r\n            `Expected to find a 'style' property on ${styledToken}`\r\n          );\r\n        }\r\n\r\n        output = output.concat(\r\n          children.flatMap(generateFinalTokenFromStyledToken(newStyle, newTags))\r\n        );\r\n      }\r\n      return output;\r\n    };\r\n\r\n  // when starting out, use the default style\r\n  const tags = \"\";\r\n  const style: TextStyleExtended = defaultStyle;\r\n\r\n  const finalTokens = styledTokens.children.flatMap(\r\n    generateFinalTokenFromStyledToken(style, tags)\r\n  );\r\n\r\n  const { wordWrap: ww, wordWrapWidth: www } = defaultStyle;\r\n  const hasWordWrapWidth =\r\n    www !== undefined && !isNaN(www as number) && (www as number) > 0;\r\n  const maxWidth =\r\n    ww && hasWordWrapWidth ? (www as number) : Number.POSITIVE_INFINITY;\r\n\r\n  const lineSpacing = defaultStyle.lineSpacing ?? 0;\r\n  const align = defaultStyle.align ?? \"left\";\r\n\r\n  return layout(finalTokens, maxWidth, lineSpacing, align);\r\n};\r\n","import { BaseTexture, Texture } from \"@pixi/core\";\r\nimport { Sprite } from \"@pixi/sprite\";\r\nimport { Text } from \"@pixi/text\";\r\nimport { Container, DisplayObject } from \"@pixi/display\";\r\nimport { Graphics } from \"@pixi/graphics\";\r\nimport \"@pixi/events\";\r\n\r\nimport { parseTagsNew, removeTags, EMOJI_TAG } from \"./tags\";\r\nimport {\r\n  TaggedTextOptions,\r\n  TextStyleSet,\r\n  TextStyleExtended,\r\n  TagWithAttributes,\r\n  AttributesList,\r\n  ImageMap,\r\n  ImageSourceMap,\r\n  IMG_REFERENCE_PROPERTY,\r\n  FinalToken,\r\n  isSpriteToken,\r\n  TextFinalToken,\r\n  isTextToken,\r\n  isNotWhitespaceToken,\r\n  isNewlineToken,\r\n  isWhitespaceToken,\r\n  Point,\r\n  ParagraphToken,\r\n  TextDecorationMetrics,\r\n  isSpriteSource,\r\n  isTextureSource,\r\n} from \"./types\";\r\nimport { capitalize } from \"./stringUtil\";\r\nimport { calculateFinalTokens, getBoundsNested } from \"./layout\";\r\nimport {\r\n  combineAllStyles,\r\n  DEFAULT_STYLE,\r\n  getStyleForTag as getStyleForTagExt,\r\n  mapTagsToStyles,\r\n} from \"./style\";\r\nimport { fontSizeStringToNumber } from \"./pixiUtils\";\r\n\r\nexport const DEFAULT_OPTIONS: TaggedTextOptions = {\r\n  debug: false,\r\n  debugConsole: false,\r\n  splitStyle: \"words\",\r\n  imgMap: {},\r\n  skipUpdates: false,\r\n  skipDraw: false,\r\n  drawWhitespace: false,\r\n  wrapEmoji: true,\r\n};\r\n\r\n// TODO: make customizable\r\nconst DEBUG = {\r\n  WORD_STROKE_COLOR: 0xffcccc, // #FCC\r\n  WORD_FILL_COLOR: 0xeeeeee, // #EEE\r\n  TEXT_FIELD_STROKE_COLOR: 0xff00ff, // #F0F\r\n  WHITESPACE_COLOR: 0xcccccc, // #CCC\r\n  WHITESPACE_STROKE_COLOR: 0xaaaaaa, // #AAA\r\n  BASELINE_COLOR: 0xffff99, // #FF9\r\n  LINE_COLOR: 0xffff00, // #FF0\r\n  OUTLINE_COLOR: 0xffcccc, // #FCC\r\n  OUTLINE_SHADOW_COLOR: 0x000000, // #000\r\n  TEXT_STYLE: {\r\n    fontFamily: \"courier\",\r\n    fontSize: 10,\r\n    fill: 0xffffff, // #FFF\r\n    dropShadow: true,\r\n  },\r\n};\r\nconst DEFAULT_STYLE_SET = { default: DEFAULT_STYLE };\r\n\r\nObject.freeze(DEFAULT_STYLE_SET);\r\nObject.freeze(DEFAULT_STYLE);\r\nexport default class TaggedText extends Sprite {\r\n  public static get defaultStyles(): TextStyleSet {\r\n    return DEFAULT_STYLE_SET;\r\n  }\r\n  public static get defaultOptions(): TaggedTextOptions {\r\n    return DEFAULT_OPTIONS;\r\n  }\r\n\r\n  // todo: allow setting options after the constructor is called. Make sure to call update()\r\n  /** Settings for the TaggedText component. */\r\n  private _options: TaggedTextOptions;\r\n  public get options(): TaggedTextOptions {\r\n    return this._options;\r\n  }\r\n\r\n  private _needsUpdate = true;\r\n  public get needsUpdate(): boolean {\r\n    return this._needsUpdate;\r\n  }\r\n  private _needsDraw = true;\r\n  public get needsDraw(): boolean {\r\n    return this._needsDraw;\r\n  }\r\n\r\n  private _tokens: ParagraphToken = [];\r\n  public get tokensFlat(): FinalToken[] {\r\n    return this._tokens.flat(3);\r\n  }\r\n  /**\r\n   * Tokens representing parsed out and styled tagged text. This is generated by update.\r\n   * They contain all the information needed to render the text fields and other children in your component.\r\n   */\r\n  public get tokens(): ParagraphToken {\r\n    return this._tokens;\r\n  }\r\n\r\n  private _text = \"\";\r\n  public get text(): string {\r\n    return this._text;\r\n  }\r\n\r\n  /**\r\n   * Alternative implicit setter for text. Always uses default for skipUpdate.\r\n   */\r\n  public set text(text: string) {\r\n    this.setText(text);\r\n  }\r\n\r\n  /**\r\n   * Setter for text that allows you to override the default for skipping the update.\r\n   * @param text Text to add to component with (optional) tags.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the text.\r\n   * When true, setText() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public setText(text: string, skipUpdate?: boolean): void {\r\n    if (text === this._text && this._needsUpdate === false) {\r\n      return;\r\n    }\r\n    this._text = text;\r\n    this._needsUpdate = true;\r\n    this.updateIfShould(skipUpdate);\r\n  }\r\n\r\n  /**\r\n   * Returns the text content with all tags stripped out.\r\n   */\r\n  public get untaggedText(): string {\r\n    return removeTags(this.text);\r\n  }\r\n\r\n  private _tagStyles: TextStyleSet = {};\r\n  public get tagStyles(): TextStyleSet {\r\n    return this._tagStyles;\r\n  }\r\n\r\n  /**\r\n   * Alternative implicit setter for tagStyles. Always uses default for skipUpdate.\r\n   */\r\n  public set tagStyles(styles: TextStyleSet) {\r\n    this.setTagStyles(styles);\r\n  }\r\n\r\n  /**\r\n   * Setter for tagStyles.\r\n   * @param styles Object with strings for keys representing tag names, mapped to style objects.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\r\n   * When true, setTagStyles() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public setTagStyles(styles: TextStyleSet, skipUpdate?: boolean): void {\r\n    Object.entries(styles).forEach(([tag, style]) =>\r\n      this.setStyleForTag(tag, style, true)\r\n    );\r\n    // TODO: add a way to test for identical styles to prevent unnecessary updates.\r\n    this._needsUpdate = true;\r\n    this.updateIfShould(skipUpdate);\r\n  }\r\n\r\n  public getStyleForTag(\r\n    tag: string,\r\n    attributes: AttributesList = {}\r\n  ): TextStyleExtended | undefined {\r\n    return getStyleForTagExt(tag, this.tagStyles, attributes);\r\n  }\r\n\r\n  public getStyleForTags(tags: TagWithAttributes[]): TextStyleExtended {\r\n    const styles = tags.map(({ tagName, attributes }) =>\r\n      this.getStyleForTag(tagName, attributes)\r\n    );\r\n    return combineAllStyles(styles);\r\n  }\r\n\r\n  /**\r\n   * Set a style to be used by a single tag.\r\n   * @param tag Name of the tag to set style for\r\n   * @param styles Style object to assign to the tag.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\r\n   * When true, setStyleForTag() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public setStyleForTag(\r\n    tag: string,\r\n    styles: TextStyleExtended,\r\n    skipUpdate?: boolean\r\n  ): boolean {\r\n    this.tagStyles[tag] = styles;\r\n\r\n    // TODO: warn user when trying to set styles on a tag that doesn't support it...\r\n    // e.g. wordWrapWidth on a styel other than default.\r\n\r\n    // Override some settings on default styles.\r\n    if (tag === \"default\" && this.defaultStyle[IMG_REFERENCE_PROPERTY]) {\r\n      // prevents accidentally setting all text to images.\r\n      console.error(\r\n        `Style \"${IMG_REFERENCE_PROPERTY}\" can not be set on the \"default\" style because it will add images to EVERY tag!`\r\n      );\r\n      this.defaultStyle[IMG_REFERENCE_PROPERTY] = undefined;\r\n    }\r\n    // TODO: add a way to test for identical styles to prevent unnecessary updates.\r\n    this._needsUpdate = true;\r\n    this.updateIfShould(skipUpdate);\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * Removes a style associated with a tag. Note, inline attributes are not affected.\r\n   * @param tag Name of the tag to delete the style of.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\r\n   * When true, removeStylesForTag() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public removeStylesForTag(tag: string, skipUpdate?: boolean): boolean {\r\n    if (tag in this.tagStyles) {\r\n      delete this.tagStyles[tag];\r\n\r\n      this._needsUpdate = true;\r\n      this.updateIfShould(skipUpdate);\r\n\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public get defaultStyle(): TextStyleExtended {\r\n    return this.tagStyles?.default;\r\n  }\r\n  /**\r\n   * Alternative implicit setter for defaultStyle. Always uses default for skipUpdate.\r\n   */\r\n  public set defaultStyle(defaultStyles: TextStyleExtended) {\r\n    this.setDefaultStyle(defaultStyles);\r\n  }\r\n  /**\r\n   * Setter for default styles. A shortcut to this.setStyleForTag(\"default\",...)\r\n   * @param styles A style object to use as the default styles for all text in the component.\r\n   * @param skipUpdate *For advanced users* overrides default for upating / redrawing after changing the styles.\r\n   * When true, setDefaultStyle() never updates even if default is false, and vice versa.\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public setDefaultStyle(\r\n    defaultStyles: TextStyleExtended,\r\n    skipUpdate?: boolean\r\n  ): void {\r\n    this.setStyleForTag(\"default\", defaultStyles, skipUpdate);\r\n  }\r\n\r\n  // References to internal elements.\r\n  private _textFields: Text[] = [];\r\n  public get textFields(): Text[] {\r\n    return this._textFields;\r\n  }\r\n  private _sprites: Sprite[] = [];\r\n  public get sprites(): Sprite[] {\r\n    return this._sprites;\r\n  }\r\n  private _decorations: Graphics[] = [];\r\n  public get decorations(): Graphics[] {\r\n    return this._decorations;\r\n  }\r\n  private _spriteTemplates: ImageMap = {};\r\n  public get spriteTemplates(): ImageMap {\r\n    return this._spriteTemplates;\r\n  }\r\n  private _debugGraphics: Graphics | null = null;\r\n\r\n  // Containers for children\r\n  private _textContainer: Container;\r\n  public get textContainer(): Container {\r\n    return this._textContainer;\r\n  }\r\n\r\n  private _decorationContainer: Container;\r\n  public get decorationContainer(): Container {\r\n    return this._decorationContainer;\r\n  }\r\n\r\n  private _spriteContainer: Container;\r\n  public get spriteContainer(): Container {\r\n    return this._spriteContainer;\r\n  }\r\n  private _debugContainer: Container;\r\n  public get debugContainer(): Container {\r\n    return this._debugContainer;\r\n  }\r\n\r\n  constructor(\r\n    text = \"\",\r\n    tagStyles: TextStyleSet = {},\r\n    options: TaggedTextOptions = {},\r\n    texture?: Texture\r\n  ) {\r\n    super(texture);\r\n\r\n    this._textContainer = new Container();\r\n    this._spriteContainer = new Container();\r\n    this._decorationContainer = new Container();\r\n    this._debugContainer = new Container();\r\n\r\n    this.addChild(this._textContainer);\r\n    this.addChild(this._spriteContainer);\r\n    this.addChild(this._decorationContainer);\r\n    this.addChild(this._debugContainer);\r\n\r\n    this.resetChildren();\r\n\r\n    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\r\n    this._options = mergedOptions;\r\n\r\n    tagStyles = { default: {}, ...tagStyles };\r\n\r\n    if (this.options.wrapEmoji) {\r\n      tagStyles[EMOJI_TAG] = { fontFamily: \"sans-serif\" };\r\n    }\r\n    const mergedDefaultStyles = { ...DEFAULT_STYLE, ...tagStyles.default };\r\n    tagStyles.default = mergedDefaultStyles;\r\n    this.tagStyles = tagStyles;\r\n\r\n    if (this.options.imgMap) {\r\n      this.createSpriteTemplatesFromSourceMap(this.options.imgMap);\r\n    }\r\n\r\n    this.text = text;\r\n  }\r\n\r\n  /**\r\n   * Removes all PIXI children from this component's containers.\r\n   * Deletes references to sprites and text fields.\r\n   */\r\n  private resetChildren() {\r\n    this._debugContainer.removeChildren();\r\n    this._textContainer.removeChildren();\r\n    this._spriteContainer.removeChildren();\r\n    this._decorationContainer.removeChildren();\r\n\r\n    this._textFields = [];\r\n    this._sprites = [];\r\n    this._decorations = [];\r\n  }\r\n\r\n  /**\r\n   * Creates associations between string-based keys like \"img\" and\r\n   * image Sprite objects which are included in the text.\r\n   * @param imgMap\r\n   */\r\n  private createSpriteTemplatesFromSourceMap(imgMap: ImageSourceMap) {\r\n    this._spriteTemplates = {};\r\n\r\n    Object.entries(imgMap).forEach(([key, spriteSource]) => {\r\n      let sprite: Sprite;\r\n      if (spriteSource instanceof Sprite) {\r\n        sprite = spriteSource;\r\n      } else {\r\n        // if the entry is not a sprite, attempt to load the sprite as if it is a reference to the sprite source (e.g. an Image element, url, or texture).\r\n        if (isSpriteSource(spriteSource)) {\r\n          sprite = Sprite.from(spriteSource);\r\n        } else if (isTextureSource(spriteSource)) {\r\n          sprite = Sprite.from(Texture.from(spriteSource));\r\n        } else {\r\n          throw new TypeError(\r\n            `The spriteSource provided for key ${key} was not in a valid format. Please use a Sprite, Texture, BaseTexture, string, HTMLImageElement, HTMLVideoElement, HTMLCanvasElement, or SVGElement`\r\n          );\r\n        }\r\n      }\r\n      // Listen for changes to sprites (e.g. when they load.)\r\n      const texture = sprite.texture;\r\n      if (texture !== undefined) {\r\n        texture.baseTexture.addListener(\"update\", (baseTexture: BaseTexture) =>\r\n          this.onImageTextureUpdate(baseTexture)\r\n        );\r\n      }\r\n\r\n      this.spriteTemplates[key] = sprite;\r\n\r\n      // create a style for each of these by default.\r\n      const existingStyle = this.getStyleForTag(key) ?? {};\r\n      const style = { [IMG_REFERENCE_PROPERTY]: key, ...existingStyle };\r\n      this.setStyleForTag(key, style);\r\n    });\r\n  }\r\n\r\n  private onImageTextureUpdate(baseTexture: BaseTexture): void {\r\n    baseTexture;\r\n    this._needsUpdate = true;\r\n    this._needsDraw = true;\r\n    // const didUpdate = this.updateIfShould();\r\n    this.updateIfShould();\r\n\r\n    // this.dispactchEvent(new Event(\"imageUpdate\", texture));\r\n  }\r\n\r\n  /**\r\n   * Determines whether to call update based on the parameter and the options set then calls it or sets needsUpdate to true.\r\n   * @param forcedSkipUpdate This is the parameter provided to some functions that allow you to skip the update.\r\n   * It's factored in along with the defaults to figure out what to do.\r\n   */\r\n  private updateIfShould(forcedSkipUpdate?: boolean): boolean {\r\n    if (\r\n      forcedSkipUpdate === false ||\r\n      (forcedSkipUpdate === undefined && this.options.skipUpdates === false)\r\n    ) {\r\n      this.update();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Calculates styles, positioning, etc. of the text and styles and creates a\r\n   * set of objects that represent where each portion of text and image should\r\n   * be drawn.\r\n   * @param skipDraw *For advanced users* overrides default for redrawing the styles.\r\n   * When true, update() will skip the call to draw() (even if the default is false).\r\n   * Options are true, false, or undefined. Undefined is the default and means it uses whatever setting\r\n   * is provided in this.options.\r\n   */\r\n  public update(skipDraw?: boolean): ParagraphToken {\r\n    // Determine default style properties\r\n    const tagStyles = this.tagStyles;\r\n    const { splitStyle } = this.options;\r\n    const spriteTemplates = this.options.imgMap && this.spriteTemplates;\r\n    // const wordWrapWidth = this.defaultStyle.wordWrap\r\n    //   ? this.defaultStyle.wordWrapWidth\r\n    //   : Number.POSITIVE_INFINITY;\r\n    // const align = this.defaultStyle.align;\r\n    // const lineSpacing = this.defaultStyle.lineSpacing;\r\n\r\n    // Pre-process text.\r\n    // Parse tags in the text.\r\n    const tagTokensNew = parseTagsNew(\r\n      this.text,\r\n      Object.keys(this.tagStyles),\r\n      this.options.wrapEmoji\r\n    );\r\n    // Assign styles to each segment.\r\n    const styledTokens = mapTagsToStyles(\r\n      tagTokensNew,\r\n      tagStyles,\r\n      spriteTemplates\r\n    );\r\n    styledTokens;\r\n    // Measure font for each style\r\n    // Measure each segment\r\n    // Create the text segments, position and add them. (draw)\r\n    const newFinalTokens = calculateFinalTokens(styledTokens, splitStyle);\r\n\r\n    this._tokens = newFinalTokens;\r\n    this._needsDraw = true;\r\n\r\n    // Wait one frame to draw so that this doesn't happen multiple times in one frame.\r\n    // if (this.animationRequest) {\r\n    //   window.cancelAnimationFrame(this.animationRequest);\r\n    // }\r\n    // this.animationRequest = window.requestAnimationFrame(\r\n\r\n    this.drawIfShould(skipDraw);\r\n\r\n    if (this.options.debugConsole) {\r\n      console.log(this.toDebugString());\r\n    }\r\n\r\n    this._needsUpdate = false;\r\n\r\n    return newFinalTokens;\r\n  }\r\n\r\n  /**\r\n   * Determines whether to call draw() based on the parameter and the options set then calls it or sets needsDraw to true.\r\n   * @param forcedSkipDraw This is the parameter provided to some functions that allow you to skip the update.\r\n   * It's factored in along with the defaults to figure out what to do.\r\n   */\r\n  private drawIfShould(forcedSkipDraw?: boolean): boolean {\r\n    if (\r\n      forcedSkipDraw === false ||\r\n      (forcedSkipDraw === undefined && this.options.skipDraw === false)\r\n    ) {\r\n      this.draw();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Create and position the display objects based on the tokens.\r\n   */\r\n  public draw(): void {\r\n    this.resetChildren();\r\n    const { drawWhitespace } = this.options;\r\n    const tokens = drawWhitespace\r\n      ? this.tokensFlat\r\n      : // remove any tokens that are purely whitespace unless drawWhitespace is specified\r\n        this.tokensFlat.filter(isNotWhitespaceToken);\r\n\r\n    let drewDecorations = false;\r\n    let displayObject: DisplayObject;\r\n\r\n    tokens.forEach((t) => {\r\n      if (isTextToken(t)) {\r\n        displayObject = this.createTextFieldForToken(t as TextFinalToken);\r\n        this.textContainer.addChild(displayObject);\r\n        this.textFields.push(displayObject as Text);\r\n\r\n        if (t.textDecorations && t.textDecorations.length > 0) {\r\n          for (const d of t.textDecorations) {\r\n            const drawing = this.createDrawingForTextDecoration(d);\r\n            (displayObject as Text).addChild(drawing);\r\n            this._decorations.push(drawing);\r\n          }\r\n          drewDecorations = true;\r\n        }\r\n      }\r\n      if (isSpriteToken(t)) {\r\n        displayObject = t.content as Sprite;\r\n        this.sprites.push(displayObject as Sprite);\r\n        this.spriteContainer.addChild(displayObject);\r\n      }\r\n\r\n      const { bounds } = t;\r\n      displayObject.x = bounds.x;\r\n      displayObject.y = bounds.y;\r\n    });\r\n\r\n    if (drawWhitespace === false && drewDecorations) {\r\n      console.warn(\r\n        \"Warning: you may want to set the `drawWhitespace` option to `true` when using textDecoration (e.g. underlines) otherwise, spaces will not have text decorations.\"\r\n      );\r\n    }\r\n\r\n    if (this.options.debug) {\r\n      this.drawDebug();\r\n    }\r\n    this._needsDraw = false;\r\n  }\r\n\r\n  private createDrawingForTextDecoration(\r\n    textDecoration: TextDecorationMetrics\r\n  ): Graphics {\r\n    const { bounds } = textDecoration;\r\n    let { color } = textDecoration;\r\n    const drawing = new Graphics();\r\n\r\n    if (typeof color === \"string\") {\r\n      if (color.indexOf(\"#\") === 0) {\r\n        color = \"0x\" + color.substring(1);\r\n        color = parseInt(color, 16) as number;\r\n      } else {\r\n        throw new Error(\r\n          \"Sorry, at this point, only hex colors are supported for textDecorations like underlines. Please use either a hex number like 0x66FF33 or a string like '#66FF33'\"\r\n        );\r\n      }\r\n    }\r\n\r\n    drawing\r\n      .beginFill(color as number)\r\n      .drawRect(bounds.x, bounds.y, bounds.width, bounds.height)\r\n      .endFill();\r\n\r\n    return drawing;\r\n  }\r\n\r\n  private createTextFieldForToken(token: TextFinalToken): Text {\r\n    const { textTransform = \"\" } = token.style;\r\n\r\n    let text = token.content;\r\n    switch (textTransform.toLowerCase()) {\r\n      case \"lowercase\":\r\n        text = text.toLowerCase();\r\n        break;\r\n      case \"uppercase\":\r\n        text = text.toUpperCase();\r\n        break;\r\n      case \"capitalize\":\r\n        text = capitalize(text);\r\n        break;\r\n      default:\r\n    }\r\n\r\n    const textField = new Text(text, token.style);\r\n\r\n    let { fontScaleWidth = 1.0, fontScaleHeight = 1.0 } = token.style;\r\n    fontScaleWidth =\r\n      isNaN(fontScaleWidth) || fontScaleWidth < 0 ? 0 : fontScaleWidth;\r\n    fontScaleHeight =\r\n      isNaN(fontScaleHeight) || fontScaleHeight < 0 ? 0 : fontScaleHeight;\r\n\r\n    let finalScaleWidth = fontScaleWidth;\r\n    let finalScaleHeight = fontScaleHeight;\r\n    const largerScale = Math.max(fontScaleWidth, fontScaleHeight);\r\n\r\n    if (largerScale > 1) {\r\n      if (largerScale === fontScaleHeight) {\r\n        finalScaleWidth /= largerScale;\r\n        finalScaleHeight = 1.0;\r\n      } else {\r\n        finalScaleHeight /= largerScale;\r\n        finalScaleWidth = 1.0;\r\n      }\r\n\r\n      const fs = textField.style.fontSize ?? 0;\r\n      const fontSizePx =\r\n        (typeof fs === \"string\" ? fontSizeStringToNumber(fs) : fs) *\r\n        largerScale;\r\n\r\n      textField.style.fontSize = fontSizePx;\r\n    }\r\n\r\n    textField.scale.set(finalScaleWidth, finalScaleHeight);\r\n    return textField;\r\n  }\r\n\r\n  /**\r\n   * Converts the text properties from this.tokens into a human readable string.\r\n   * This is automatically logged to the console on update when debug option is set to true.\r\n   */\r\n  public toDebugString(): string {\r\n    const lines = this.tokens;\r\n    let s = this.untaggedText + \"\\n=====\\n\";\r\n    const nl = \"\\n    \";\r\n    if (lines !== undefined) {\r\n      s += lines.map((line, lineNumber) =>\r\n        line.map((word, wordNumber) =>\r\n          word\r\n            .map((token, tokenNumber) => {\r\n              let text = \"\";\r\n              if (isTextToken(token)) {\r\n                if (isNewlineToken(token)) {\r\n                  text = `\\\\n`;\r\n                } else {\r\n                  text = `\"${token.content}\"`;\r\n                }\r\n              } else if (isSpriteToken(token)) {\r\n                text = `[Image]`;\r\n              }\r\n              let s = `\\n${text}: (${lineNumber}/${wordNumber}/${tokenNumber})`;\r\n              s += `${nl}tags: ${\r\n                token.tags.length === 0\r\n                  ? \"<none>\"\r\n                  : token.tags\r\n                      .split(\",\")\r\n                      .map((tag) => `<${tag}>`)\r\n                      .join(\", \")\r\n              }`;\r\n              s += `${nl}style: ${Object.entries(token.style)\r\n                .map((e) => e.join(\":\"))\r\n                .join(\"; \")}`;\r\n              s += `${nl}size: x:${token.bounds.x} y:${token.bounds.y} width:${\r\n                token.bounds.width\r\n              } height:${token.bounds.height} bottom:${\r\n                token.bounds.height + token.bounds.y\r\n              } right:${token.bounds.x + token.bounds.width}`;\r\n              s += `${nl}font: fontSize:${token.fontProperties.fontSize} ascent:${token.fontProperties.ascent} descent:${token.fontProperties.descent}`;\r\n              return s;\r\n            })\r\n            .join(\"\\n\")\r\n        )\r\n      );\r\n    }\r\n    return s;\r\n  }\r\n\r\n  public drawDebug(): void {\r\n    const paragraph = this.tokens;\r\n    this._debugGraphics = new Graphics();\r\n    this.debugContainer.addChild(this._debugGraphics);\r\n\r\n    const g = this._debugGraphics;\r\n    g.clear();\r\n\r\n    // const { width, height } = this.getBounds();\r\n    // // frame shadow\r\n    // g.lineStyle(2, DEBUG.OUTLINE_SHADOW_COLOR, 0.5);\r\n    // // g.beginFill();\r\n    // g.drawRect(1, 1, width, height);\r\n    // // g.endFill();\r\n\r\n    // // frame\r\n    // g.lineStyle(2, DEBUG.OUTLINE_COLOR, 1);\r\n    // // g.beginFill();\r\n    // g.drawRect(0, 0, width - 1, height - 1);\r\n    // // g.endFill();\r\n\r\n    function createInfoText(text: string, position: Point): Text {\r\n      const info = new Text(text, DEBUG.TEXT_STYLE);\r\n      info.x = position.x + 1;\r\n      info.y = position.y + 1;\r\n      return info;\r\n    }\r\n\r\n    // for (const line of tokens) {\r\n    for (let lineNumber = 0; lineNumber < paragraph.length; lineNumber++) {\r\n      const line = paragraph[lineNumber];\r\n      const lineBounds = getBoundsNested(line);\r\n\r\n      if (this.defaultStyle.wordWrap) {\r\n        const w = this.defaultStyle.wordWrapWidth ?? this.width;\r\n        g.endFill()\r\n          .lineStyle(0.5, DEBUG.LINE_COLOR, 0.2)\r\n          .drawRect(0, lineBounds.y, w, lineBounds.height)\r\n          .endFill();\r\n      }\r\n\r\n      for (let wordNumber = 0; wordNumber < line.length; wordNumber++) {\r\n        const word = line[wordNumber];\r\n        for (const segmentToken of word) {\r\n          const isSprite = isSpriteToken(segmentToken);\r\n          const { x, y, width } = segmentToken.bounds;\r\n          const baseline =\r\n            y +\r\n            (isSprite\r\n              ? segmentToken.bounds.height\r\n              : segmentToken.fontProperties.ascent);\r\n\r\n          let { height } = segmentToken.bounds;\r\n          if (isSprite) {\r\n            height += segmentToken.fontProperties.descent;\r\n          }\r\n\r\n          if (\r\n            isWhitespaceToken(segmentToken) &&\r\n            this.options.drawWhitespace === false\r\n          ) {\r\n            g.lineStyle(1, DEBUG.WHITESPACE_STROKE_COLOR, 1).beginFill(\r\n              DEBUG.WHITESPACE_COLOR,\r\n              0.2\r\n            );\r\n          } else {\r\n            g.lineStyle(1, DEBUG.WORD_STROKE_COLOR, 1).beginFill(\r\n              DEBUG.WORD_FILL_COLOR,\r\n              0.2\r\n            );\r\n          }\r\n\r\n          if (isNewlineToken(segmentToken)) {\r\n            this.debugContainer.addChild(\r\n              createInfoText(\"\", { x, y: y + 10 })\r\n            );\r\n          } else {\r\n            g.lineStyle(0.5, DEBUG.LINE_COLOR, 0.2)\r\n              .drawRect(x, y, width, height)\r\n              .endFill()\r\n\r\n              .lineStyle(1, DEBUG.BASELINE_COLOR, 1)\r\n              .beginFill()\r\n              .drawRect(x, baseline, width, 1)\r\n              .endFill();\r\n          }\r\n\r\n          let info;\r\n          // info = `${token.bounds.width}${token.bounds.height}`;\r\n          if (isTextToken(segmentToken)) {\r\n            // info += ` ${token.tags}`;\r\n            info = `${segmentToken.tags}`;\r\n            this.debugContainer.addChild(createInfoText(info, { x, y }));\r\n          }\r\n          // this.debugContainer.addChild(createInfoText(info, { x, y }));\r\n        }\r\n      }\r\n    }\r\n    // }\r\n\r\n    // Show the outlines of the actual text fields,\r\n    // not just where the tokens say they should be\r\n    // const fields: Text[] = this.textFields;\r\n    // for (const text of fields) {\r\n    //   g.lineStyle(1, DEBUG.TEXT_FIELD_STROKE_COLOR, 1);\r\n    //   g.drawRect(text.x, text.y, text.width, text.height);\r\n    // }\r\n  }\r\n}\r\n"],"names":["predicate","group","any","_DEFAULT_STYLE","combineRecords","a","b","_extends","last","length","isDefined","undefined","flatReduce","f","acc","nested","flat","reduce","flatEvery","p","t","IMG_REFERENCE_PROPERTY","IMG_DISPLAY_PROPERTY","createEmptyFinalToken","content","bounds","PixiRectangle","fontProperties","ascent","descent","fontSize","style","tags","textDecorations","isWhitespace","s","split","every","char","search","isSpriteToken","Sprite","_isTextToken","isTextToken","isWhitespaceToken","_isNewlineToken","isNewlineToken","isNotWhitespaceToken","input","isEmptyObject","Object","keys","getTagRegex","tagNamesToMatch","matchingTagNames","join","captureGroup","noCaptureGroup","QUOTE","NOT_QUOTE","TAG_NAMES","ATTRIBUTE_VALUE","ATTRIBUTES","WHITESPACE","CHAR","RegExp","TAG_OPEN","EMOJI_TAG","createTagMatchData","match","attributesString","openTagName","index","tag","tagName","isOpening","attributes","trim","obj","attribute","attributePair","name","valueStr","substr","selfClosingTagSearch","slice","call","arguments","not","TAG_SLASH","tagMatchToTagToken","children","capitalize","str","chars","converted","i","charAt","toUpperCase","measureFont","context","TextMetrics","font","getFontPropertiesOfText","textField","forceUpdate","updateText","_textField$style$font","props","fs","NaN","isNaN","Number","Error","DEFAULT_STYLE","align","valign","wordWrap","wordWrapWidth","lineSpacing","fill","combineStyles","combineAllStyles","styles","filter","getStyleForTag","tagStyles","_injectAttributes","convertedAttributes","key","value","parseFloat","convertAttributeValues","injectAttributes","values","rectFromContainer","container","offset","x","y","Rectangle","width","height","translateLine","line","map","point","translatePoint","lineWidth","wordsInLine","firstWord","lastWord","setBoundsX","object","_extends2","positionWordX","word","prevBounds","token","concatBounds","originalBounds","Math","min","max","getBoundsNested","alignLeft","newLine","concat","getTallestToken","tallest","current","_current$bounds$heigh","_tallest$bounds$heigh","h","notEmptyString","SPLIT_MARKER","splitAroundWhitespace","replace","DEFAULT_OPTIONS","debug","debugConsole","splitStyle","imgMap","skipUpdates","skipDraw","drawWhitespace","wrapEmoji","DEBUG","fontFamily","dropShadow","DEFAULT_STYLE_SET","default","freeze","TaggedText","_Sprite","_proto","prototype","text","options","texture","_this","this","_options","_needsUpdate","_needsDraw","_tokens","_text","_tagStyles","_textFields","_sprites","_decorations","_spriteTemplates","_debugGraphics","_textContainer","_decorationContainer","_spriteContainer","_debugContainer","Container","addChild","resetChildren","mergedOptions","mergedDefaultStyles","createSpriteTemplatesFromSourceMap","setText","skipUpdate","updateIfShould","setTagStyles","_this2","entries","forEach","_ref","setStyleForTag","getStyleForTagExt","getStyleForTags","_this3","_ref2","defaultStyle","console","error","removeStylesForTag","setDefaultStyle","defaultStyles","removeChildren","_this4","_ref3","_this4$getStyleForTag","sprite","spriteSource","Texture","HTMLCanvasElement","HTMLVideoElement","from","HTMLImageElement","BaseTexture","isTextureSource","TypeError","baseTexture","addListener","onImageTextureUpdate","spriteTemplates","existingStyle","forcedSkipUpdate","update","styledTokens","tokens","_styles$default","tagStack","styleCache","convertTagTokenToStyledToken","_style$IMG_REFERENCE_","objects","_token$attributes","push","o","tagHash","JSON","stringify","tagWithAttributesToStyle","stylesWithDefault","textDecoration","defaultColor","decorationColor","defaultThickness","decorationThickness","mergeDecoration","decorationLineType","decorationLineTypeCamelCase","_style$textDecoration","_style","_style2","_style3","includes","convertDecorationToLineProps","styledToken","imgKey","cloneOfSprite","cloneSprite","pop","mapTagsToStyles","shouldWrapEmoji","getEmojiRegex","test","containsEmoji","emojiRegex","source","replaceAll","tagStart","_","output","replaceSelfClosingTags","re","tagMatches","exec","tagMatch","segments","rootTokens","tokenStack","_segments","segment","poppedToken","warn","createTokensNew","tagMatchData","_step","remaining","_iterator","_createForOfIteratorHelperLoose","done","startOfTag","endOfTag","extractSegments","parseTagsNew","newFinalTokens","_defaultStyle$lineSpa","_defaultStyle$align","sizer","PixiText","finalTokens","flatMap","generateFinalTokenFromStyledToken","dropShadowBlur","dropShadowDistance","dropShadowAngle","textSegments","suggestion","badStyle","toLowerCase","indexOf","splitText","textTokens","_style$fontScaleWidth","_style$fontScaleHeigh","_sizer$style$strokeTh","textTransform","sw","fontScaleWidth","sh","fontScaleHeight","scaleWidth","scaleHeight","scale","set","stroke","strokeThickness","textBounds","baseline","ascender","xHeight","_style4","color","extractDecorations","isIcon","newStyle","newTags","ww","www","hasWordWrapWidth","maxWidth","cursor","wordWidth","allLines","tallestHeightInLine","addWordBufferToLineBuffer","addLineToListOfLines","addLineToListOfLinesAndMoveCursorToNextLine","setTallestHeight","_token$fontProperties","_token$fontProperties2","_token$bounds$height","_token$bounds","positionTokenAtCursorAndAdvanceCursor","positionWordBufferAtCursorAndAdvanceCursor","isBlockImage","addTokenToWordAndUpdateWordWidth","isNewline","isImage","collapsedWhitespace","lines","_iterator6","_step6","_iterator7","_step7","collapseWhitespacesOnEndOfLines","valignedLines","overrideValign","_step3","previousTallestToken","previousLineBottom","newLines","_iterator3","_tallestToken$bounds$","_tallestToken$bounds","_tallestToken$fontPro","_tallestToken$fontPro2","tallestToken","tallestHeight","tallestAscent","_step4","_iterator4","_step5","newWord","_iterator5","newToken","newBounds","newY","verticalAlignInLines","alignFunction","maxLineWidth","alignRight","alignCenter","nonZeroWidthWords","countNonZeroWidthWords","first","rest","previousWord","result","combinedBounds","getCombinedBounds","spacerWidth","_step2","wordBoundsForLine","_iterator2","wordBounds","alignedLine","alignLines","layout","POSITIVE_INFINITY","calculateFinalTokens","drawIfShould","log","toDebugString","forcedSkipDraw","draw","_this5","displayObject","tokensFlat","drewDecorations","createTextFieldForToken","textContainer","textFields","drawing","createDrawingForTextDecoration","sprites","spriteContainer","drawDebug","Graphics","substring","parseInt","beginFill","drawRect","endFill","_token$style$textTran","Text","_token$style","_token$style$fontScal","_token$style$fontScal2","finalScaleWidth","finalScaleHeight","largerScale","fontSizePx","size","_size$split","unit","fontSizeStringToNumber","untaggedText","nl","lineNumber","wordNumber","tokenNumber","e","paragraph","debugContainer","g","createInfoText","position","info","clear","lineBounds","_this$defaultStyle$wo","w","lineStyle","segmentToken","isSprite","_segmentToken$bounds","get","_this$tagStyles"],"mappings":"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"}